<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Javascript 26k words Summary | Harry Blog</title><meta name="keywords" content="frontend,javascript,interview,summary"><meta name="author" content="Harry Qu"><meta name="copyright" content="Harry Qu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="# 2.6 万字 JS 干货分享，带你领略前端魅力！ # 前言 本篇文章属于知识总结型，归纳出许多比较零散的知识点，都是干货噢～ 如果你是小白那么这篇文章正好适合你，如果你是老手那么不妨巩固一下看看还有哪些边角料没补！ 建议：适合有 js 基础的小伙伴观看，篇幅较长，建议先收藏再慢慢浏览  整整花了一周时间总结了一些比较重点也有些比较偏的知识，希望各位小伙伴慢慢品尝，如果有不对的地方或者是需要优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript 26k words Summary">
<meta property="og:url" content="https://harryqu1229.github.io/2022/01/13/js%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Harry Blog">
<meta property="og:description" content="# 2.6 万字 JS 干货分享，带你领略前端魅力！ # 前言 本篇文章属于知识总结型，归纳出许多比较零散的知识点，都是干货噢～ 如果你是小白那么这篇文章正好适合你，如果你是老手那么不妨巩固一下看看还有哪些边角料没补！ 建议：适合有 js 基础的小伙伴观看，篇幅较长，建议先收藏再慢慢浏览  整整花了一周时间总结了一些比较重点也有些比较偏的知识，希望各位小伙伴慢慢品尝，如果有不对的地方或者是需要优化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://harryqu1229.github.io/img/default-covers/sun.png">
<meta property="article:published_time" content="2022-01-12T11:00:00.000Z">
<meta property="article:modified_time" content="2022-06-12T01:11:47.237Z">
<meta property="article:author" content="Harry Qu">
<meta property="article:tag" content="frontend">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="summary">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://harryqu1229.github.io/img/default-covers/sun.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://harryqu1229.github.io/2022/01/13/js%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":100,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#C78550","bgDark":"#c08eaf","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Javascript 26k words Summary',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-12 13:11:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">158</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">57</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-graduation-cap"></i><span> Journey</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Hobbies</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://geekboots.sfo2.cdn.digitaloceanspaces.com/post/javascript-1567486564472.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Harry Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-graduation-cap"></i><span> Journey</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Hobbies</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Javascript 26k words Summary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-12T11:00:00.000Z" title="Created 2022-01-13 00:00:00">2022-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-12T01:11:47.237Z" title="Updated 2022-06-12 13:11:47">2022-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Summary/">Summary</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Summary/frontend/">frontend</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">29.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>108min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Javascript 26k words Summary"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="26万字js干货分享带你领略前端魅力"><a class="markdownIt-Anchor" href="#26万字js干货分享带你领略前端魅力">#</a> 2.6 万字 JS 干货分享，带你领略前端魅力！</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2>
<p>本篇文章属于<strong>知识总结</strong>型，归纳出许多比较零散的知识点，都是<strong>干货</strong>噢～</p>
<p>如果你是小白那么这篇文章正好适合你，如果你是老手那么不妨巩固一下看看还有哪些边角料没补！</p>
<p>建议：适合<strong>有 js 基础</strong>的小伙伴观看，<strong>篇幅较长</strong>，建议先<strong>收藏</strong>再慢慢浏览</p>
<blockquote>
<p>整整花了一周时间总结了一些比较重点也有些比较偏的知识，希望各位小伙伴慢慢品尝，如果有不对的地方或者是需要优化的地方望请告知，尽量给大家呈现最有价值的文章。个人水平有限，还请各位大佬指点迷津。希望各位看了这篇文章能有自己的想法，在前端道路上还很漫长，与我一同探索吧！</p>
</blockquote>
<h3 id="个人技术文档"><a class="markdownIt-Anchor" href="#个人技术文档">#</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.5102it.cn" title="https://docs.5102it.cn">个人技术文档</a></h3>
<h2 id="目录"><a class="markdownIt-Anchor" href="#目录">#</a> 目录</h2>
<p>一、 <a href="#1" title="#1">变量类型</a></p>
<p>二、 <a href="#2" title="#2">深拷贝与浅拷贝</a></p>
<p>三、 <a href="#3" title="#3">原型与原型链</a></p>
<p>四、 <a href="#4" title="#4">实现 class 与 extends</a></p>
<p>五、 <a href="#5" title="#5">继承与实现</a></p>
<p>六、 <a href="#6" title="#6">作用域、执行上下文与闭包</a></p>
<p>七、 <a href="#7" title="#7">this</a></p>
<p>八、 <a href="#8" title="#8">apply、call、bind 实现</a></p>
<p>九、 <a href="#9" title="#9">同步与异步</a></p>
<p>十、 <a href="#10" title="#10">AMD、CMD、CommonJS 与 ES6 模块化</a></p>
<p>十一、 <a href="#11" title="#11">script 标签之 async 与 defer</a></p>
<p>十二、 <a href="#12" title="#12">改变数组本身的 api</a></p>
<p>十三、 <a href="#13" title="#13">window 之 location、navigator</a></p>
<p>十四、 <a href="#14" title="#14">ajax 与 fetch</a></p>
<p>十五、 <a href="#15" title="#15">WebSocket</a></p>
<p>十六、 <a href="#16" title="#16">短轮询、长轮询与 WebSocket</a></p>
<p>十七、 <a href="#17" title="#17">长连接与短连接</a></p>
<p>十八、 <a href="#18" title="#18">存储</a></p>
<p>十九、 <a href="#19" title="#19">跨域</a></p>
<p>二十、 <a href="#20" title="#20">setTimeout 与 setInterval</a></p>
<p>二十一、 <a href="#21" title="#21">requestAnimationFrame</a></p>
<p>二十二、 <a href="#22" title="#22">事件</a></p>
<p>二十三、 <a href="#23" title="#23">总结</a></p>
<p>二十四、 <a href="#24" title="#24">其他文章</a></p>
<h2 id="一-变量类型"><a class="markdownIt-Anchor" href="#一-变量类型">#</a> 一、变量类型</h2>
<h3 id="与"><a class="markdownIt-Anchor" href="#与">#</a> <strong>== 与 ===</strong></h3>
<h4 id="对于的判断"><a class="markdownIt-Anchor" href="#对于的判断">#</a> 对于 == 的判断</h4>
<ul>
<li>并不是那么严谨的判断左右两端是否相等</li>
<li>它会优先对比数据的类型是否一致</li>
<li>不一致则<strong>进行隐式转换</strong>，一致则判断值的大小，得出结果</li>
<li>继续判断两个类型是否为 null 与 undefined，如果是则返回 true</li>
<li>接着判断是否为 string 与 number，如果是把 string 转换为 number 再对比大小</li>
<li>判断其中一方是否为 boolean，如果是就转为 number 再进一步判断</li>
<li>判断一方是否为 object，另一方为 string、number、symbol，如果是则把 object 转为原始类型再判断</li>
</ul>
<h5 id="比较情况"><a class="markdownIt-Anchor" href="#比较情况">#</a> 比较情况</h5>
<ol>
<li>数组 == 值，(值类型指的是原始类型) 会先转成数值再比较，与字符串比较会先转成字符串再比较</li>
<li>引用 == 值，会把引用类型转成原始类型再比较</li>
<li>值 == 值，直接比较类型再比较值的大小</li>
<li>字符串 == 数字，则把字符串转为数值再比较</li>
<li>其他类型 == boolean，则把 boolean 转成数值再进一步比较</li>
<li>undefined == null，也会发生隐式转换，且 2 者可以相互转换，即 2 者相等，与自身也相等</li>
<li>对象 == 非对象，如果非对象为 string 或 number，则返回 ToPrimitive (对象) == 非对象，的结果；ToPrimitive 方法的参数如果是原始类型则直接返回；如果是对象，则调用 valueOf 方法，如果是原始值再进行原始类型转换和大小对比；如果不是原始值则调用 toString，且结果为原始值则进行原始类型比较，如果不是原始值则抛出错误</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以下结果都为true
console.log([5]&#x3D;&#x3D;5,[&#39;5&#39;]&#x3D;&#x3D;5)
console.log(&#123;name:&#39;5&#39;&#125;&#x3D;&#x3D;&#39;[object Object]&#39;)
console.log(&#39;5&#39;&#x3D;&#x3D;5,true&#x3D;&#x3D;1,false&#x3D;&#x3D;0)
console.log(undefined&#x3D;&#x3D;null)
console.log([5,6]&#x3D;&#x3D;&#39;5,6&#39;,[&#39;5&#39;,&#39;6&#39;]&#x3D;&#x3D;&#39;5,6&#39;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>大白话：优先比较类型，同类型，比大小，非原始，调 ToPrimitive，为对象调 valueOf，还非原始调 toString，最后还非原始则报错，如果为原始则进行类型对比，如果不同类型再转换，之后对比大小。</p>
</blockquote>
<p>所谓 == 比较就是要转换成同类型比较，如果无法转成同类型就报错</p>
<blockquote>
<p>优先比类型，再比 null 与 undefined，再比 string 和 number，再比 boolean 与 any，再比 object 与 string、number、symbol；以上如果转为原始类型比较，则进行类型转换，直到类型相同再比较值的大小。这就是 == 的隐式转换对比，比较绕，给个图就清晰了！</p>
</blockquote>
<p>如下为判断步骤</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d4f703af20a1~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>思考？如何判断此表达式（注意 ==! 与！<mark>） **[]</mark>![]**</p>
<ul>
<li>基于运算符的优先级此式会先运算！[] 的结果</li>
<li>! 优先于 ==，且 [] 为真值 (转成 boolean，结果为 true 的就为真值，包括 {}；转成 false 的就为假值)，![] 结果为 false，所以当前表达式转化为 []==false</li>
<li>通过之前总结的转换关系，任何类型与 boolean 类型比较，所以 []==false 转化为 []==0 比较</li>
<li>此时变为 object 与 0 比较，调用 object 的转换成原始类型的方法 valueOf 其结果还是 valueOf</li>
<li>再调用 toString 结果为’’，再进行 string 转成 number，则 [] 转成数字类型 0</li>
<li>表达式进一步转换成 0==0，结果为 true。</li>
</ul>
<p>虽然过程复杂，记住判断的思路即可，非对象之间，先类型转换再比大小，对象比较则调用获取原始值方法再进一步比较。</p>
<p>如下为 toString 与 valueOf 转换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d4e8d3757d58%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<h4 id="对于的判断-2"><a class="markdownIt-Anchor" href="#对于的判断-2">#</a> 对于 === 的判断</h4>
<ul>
<li>=== 属于<strong>严格判断</strong>，直接判断两者类型是否相同，不同则返回 false</li>
<li>如果相同再比较大小，<strong>不会进行任何隐式转换</strong></li>
<li>对于引用类型来说，比较的都是引用内存地址，所以 === 这种方式的比较，除非两者存储的内存地址相同才相等，反之 false</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const a&#x3D;[]
const b&#x3D;a
a&#x3D;&#x3D;&#x3D;b &#x2F;&#x2F;true
---------------
const a&#x3D;[]
const b&#x3D;[]
a&#x3D;&#x3D;&#x3D;b &#x2F;&#x2F;false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7大原始类型与object类型"><a class="markdownIt-Anchor" href="#7大原始类型与object类型">#</a> 7 大原始类型与 Object 类型</h4>
<ol>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>BigInt</li>
<li>String</li>
<li>Symbol</li>
<li><strong>Object</strong></li>
</ol>
<h4 id="类型判断"><a class="markdownIt-Anchor" href="#类型判断">#</a> 类型判断</h4>
<h5 id="原始类型判断"><a class="markdownIt-Anchor" href="#原始类型判断">#</a> 原始类型判断</h5>
<ul>
<li><strong>原始类型</strong> string、number、undefined、boolean、symbol、bigint 都能<strong>通过 typeof</strong> (返回字符串形式) 直接判断类型，还有对象类型 function 也可判断</li>
<li><strong>除了 null</strong> 无法通过 typeof (为 object) 直接判断类型 (历史遗留)，包括对象类型，typeof 把 null 当作对象类型处理，所以 typeof 无法判断对象类型，<strong>typeof 也能判断 function</strong></li>
</ul>
<h5 id="非原始类型判断以及null"><a class="markdownIt-Anchor" href="#非原始类型判断以及null">#</a> 非原始类型判断 (以及 null)</h5>
<p>判断数组</p>
<ul>
<li>使用 <code>Array.isArray()</code>  判断数组</li>
<li>使用 <code>[] instanceof Array</code>  判断是否在 Array 的原型链上，即可判断是否为数组</li>
<li><code>[].constructor === Array</code>  通过其构造函数判断是否为数组</li>
<li>也可使用 <code>Object.prototype.toString.call([])</code>  判断值是否为’[object Array]' 来判断数组</li>
</ul>
<p>判断对象</p>
<ul>
<li><code>Object.prototype.toString.call(&#123;&#125;)</code>  结果为’[object Object]' 则为对象</li>
<li><code>&#123;&#125; instanceof Object</code>  判断是否在 Object 的原型链上，即可判断是否为对象</li>
<li><code>&#123;&#125;.constructor === Object</code>  通过其构造函数判断是否为对象</li>
</ul>
<p>判断函数</p>
<ul>
<li>使用 <code>func typeof function</code>  判断 func 是否为函数</li>
<li>使用 <code>func instanceof Function</code>  判断 func 是否为函数</li>
<li>通过 <code>func.constructor === Function</code>  判断是否为函数</li>
<li>也可使用 <code>Object.prototype.toString.call(func)</code>  判断值是否为’[object Function]' 来判断 func</li>
</ul>
<p>判断 null</p>
<ul>
<li>最简单的是通过 <code>null===null</code>  来判断是否为 null</li>
<li><code>(!a &amp;&amp; typeof (a) != 'undefined' &amp;&amp; a != 0 &amp;&amp; a==a)</code>  判断 a 是否为 null</li>
<li><code>Object.prototype.__proto__===a</code>  判断 a 是否为原始对象原型的原型即 null</li>
<li><code>typeof (a) == 'object' &amp;&amp; !a</code>  通过 typeof 判断 null 为对象，且对象类型只有 null 转换为 Boolean 为 false</li>
</ul>
<p>判断是否为 NaN</p>
<ul>
<li><code>isNaN(any)</code>  直接调用此方法判断是否为非数值</li>
</ul>
<p>一些其他判断</p>
<ul>
<li><code>Object.is(a,b)</code>  判断 a 与 b 是否完全相等，与 === 基本相同，不同点在于 Object.is 判断 <code>+0不等于-0</code> ， <code>NaN等于自身</code></li>
<li>一些其他对象类型可以基于原型链判断和构造函数判断</li>
<li><code>prototypeObj.isPrototypeOf(object)</code>  判断 object 的原型是否为 prototypeObj，不同于 instanceof，此方法直接判断原型，而非 instanceof 判断的是右边的原型链</li>
</ul>
<p>一个简单的类型验证函数</p>
<pre class="line-numbers language-none"><code class="language-none">function isWho(x) &#123;
  &#x2F;&#x2F; null
  if (x &#x3D;&#x3D;&#x3D; null) return &#39;null&#39;
  const primitive &#x3D; [&#39;number&#39;, &#39;string&#39;, &#39;undefined&#39;,
    &#39;symbol&#39;, &#39;bigint&#39;, &#39;boolean&#39;, &#39;function&#39;
  ]
  let type &#x3D; typeof x
  &#x2F;&#x2F;原始类型以及函数
  if (primitive.includes(type)) return type
  &#x2F;&#x2F;对象类型
  if (Array.isArray(x)) return &#39;array&#39;
  if (Object.prototype.toString.call(x) &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;) return &#39;object&#39;
  if (x.hasOwnProperty(&#39;constructor&#39;)) return x.constructor.name
  const proto &#x3D; Object.getPrototypeOf(x)
  if (proto) return proto.constructor.name
  &#x2F;&#x2F; 无法判断
  return &quot;can&#39;t get this type&quot;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二-深拷贝与浅拷贝"><a class="markdownIt-Anchor" href="#二-深拷贝与浅拷贝">#</a> 二、深拷贝与浅拷贝</h2>
<p>在项目中有许多地方需要数据克隆，特别是引用类型对象，我们无法使用普通的赋值方式克隆，虽然我们一般使用第三方库如 lodash 来实现深拷贝，但是我们也需要知道一些其中的原理</p>
<h3 id="浅拷贝"><a class="markdownIt-Anchor" href="#浅拷贝">#</a> 浅拷贝</h3>
<ul>
<li><code>Object.assign(&#123;&#125;,obj)</code>  浅拷贝 object</li>
<li><code>obj1=&#123;...obj2&#125;</code>  通过 spread 展开运算符浅拷贝 obj2</li>
<li><code>Object.fromEntries(Object.entries(obj))</code>  通过生成迭代器再通过迭代器生成对象</li>
<li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code>  浅拷贝 obj</li>
<li><code>Object.defineProperties(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code>  浅拷贝 obj</li>
</ul>
<p>简单实现浅拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; a原拷贝对象，b新对象
for (const key in a) &#123;
  b[key] &#x3D; a[key]
&#125;
------------------------------------------
for (const key of Object.keys(a)) &#123;
  b[key] &#x3D; a[key]
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>浅拷贝</strong>只拷贝一层属性对于<strong>引用类型无法拷贝</strong></p>
<h3 id="深拷贝"><a class="markdownIt-Anchor" href="#深拷贝">#</a> 深拷贝</h3>
<ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>  通过<strong> JSON 的 2 次转换</strong>深拷贝 obj，不过无法拷贝<strong> undefined</strong> 与<strong> symbol</strong> 属性，无法拷贝<strong>循环引用</strong>对象</li>
<li>自己实现深拷贝</li>
</ul>
<p>简单深拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;简单版深拷贝，只能拷贝基本原始类型和普通对象与数组，无法拷贝循环引用
function simpleDeepClone(a) &#123;
  const b&#x3D;Array.isArray(a) ? [] : &#123;&#125;
  for (const key of Object.keys(a)) &#123;
    const type &#x3D; typeof a[key]
    if (type !&#x3D;&#x3D; &#39;object&#39; || a[key] &#x3D;&#x3D;&#x3D; null) &#123;
      b[key] &#x3D; a[key]
    &#125; else &#123;
      b[key] &#x3D; simpleDeepClone(a[key])
    &#125;
  &#125;
  return b
&#125;
&#x2F;&#x2F;精简版深拷贝只能拷贝基本原始类型和普通对象与数组，可以拷贝循环引用
function deepClone(a, weakMap &#x3D; new WeakMap()) &#123;
  if (typeof a !&#x3D;&#x3D; &#39;object&#39; || a &#x3D;&#x3D;&#x3D; null) return a
  if (s &#x3D; weakMap.get(a)) return s
  const b &#x3D; Array.isArray(a) ? [] : &#123;&#125;
  weakMap.set(a, b)
  for (const key of Object.keys(a)) b[key] &#x3D; clone(a[key], weakMap)
  return b
&#125;
&#x2F;&#x2F;js原生深拷贝，无法拷贝Symbol、null、循环引用
function JSdeepClone(data) &#123;
  if (!data || !(data instanceof Object) || (typeof data &#x3D;&#x3D; &quot;function&quot;)) &#123;
    return data || undefined;
  &#125;
  const constructor &#x3D; data.constructor;
  const result &#x3D; new constructor();
  for (const key in data) &#123;
    if (data.hasOwnProperty(key)) &#123;
      result[key] &#x3D; deepClone(data[key]);
    &#125;
  &#125;
  return result;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>比较完善的深拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;深拷贝具体版，非完全，但大部分都可以
function deepClonePlus(a, weakMap &#x3D; new WeakMap()) &#123;
  const type &#x3D; typeof a
  if (a &#x3D;&#x3D;&#x3D; null || type !&#x3D;&#x3D; &#39;object&#39;) return a
  if (s &#x3D; weakMap.get(a)) return s
  const allKeys &#x3D; Reflect.ownKeys(a)
  const newObj &#x3D; Array.isArray(a) ? [] : &#123;&#125;
  weakMap.set(a, newObj)
  for (const key of allKeys) &#123;
    const value &#x3D; a[key]
    const T &#x3D; typeof value
    if (value &#x3D;&#x3D;&#x3D; null || T !&#x3D;&#x3D; &#39;object&#39;) &#123;
      newObj[key] &#x3D; value
      continue
    &#125;
    const objT &#x3D; Object.prototype.toString.call(value)
    if (objT &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39; || objT &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;) &#123;
      newObj[key] &#x3D; deepClonePlus(value, weakMap)
      continue
    &#125;
    if (objT &#x3D;&#x3D;&#x3D; &#39;[object Set]&#39; || objT &#x3D;&#x3D;&#x3D; &#39;[object Map]&#39;) &#123;
      if (objT &#x3D;&#x3D;&#x3D; &#39;[object Set]&#39;) &#123;
        newObj[key] &#x3D; new Set()
        value.forEach(v &#x3D;&gt; newObj[key].add(deepClonePlus(v, weakMap)))
      &#125; else &#123;
        newObj[key] &#x3D; new Map()
        value.forEach((v, i) &#x3D;&gt; newObj[key].set(i, deepClonePlus(v, weakMap)))
      &#125;
      continue
    &#125;
    if (objT &#x3D;&#x3D;&#x3D; &#39;[object Symbol]&#39;) &#123;
      newObj[key] &#x3D; Object(Symbol.prototype.valueOf.call(value))
      continue
    &#125;
    newObj[key] &#x3D; new a[key].constructor(value)
  &#125;
  return newObj
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>刨析深拷贝 (个人思路)</p>
<ul>
<li>本人使用递归算法来实习深拷贝，由于使用递归，会让代码看起来更加易懂，在不触及调用栈溢出的情况下，推荐使用递归</li>
<li>深拷贝，其实考验的就是如何把引用类型给拷贝过来，还有 Symbol 类型比较特殊，如何实现一个比较完整的深拷贝就要涉及<strong>不同类型</strong>的拷贝方式</li>
</ul>
<ol>
<li>首先考虑简单的<strong>原始类型</strong>，由于原始类型在内存中保存的是值可以直接通过值的赋值操作，先判断传入参数是否为原始类型，包括 null 这里归为原始类型来判断，没必要进入对象环节，函数直接赋值不影响使用</li>
<li>经过原始类型的筛选，剩下<strong>对象类型</strong>，取出所有对象的键，通过 <code>Reflect.OwnKeys(obj)</code>  取出对象自身所有的键，包括 Symbol 的键也能取出</li>
<li>由于对象有 2 种体现形式，<strong>数组</strong>和<strong>普通对象</strong>，对于这 2 者要单独判断，先生成一个拷贝容器即 newObj</li>
<li>接下来就可以开始遍历 步骤 2 中获取到对象所有的键 (仅自身包含的键), 通过 for…of 遍历，取出当前要拷贝的对象 a，对应于当前遍历键的值，即 a [key]</li>
<li>对 a [key] 值的类型进行判断，此值类型的可能性包括所有的类型，所以又回到步骤 1 中先判断原始类型数据；如果是原始类型可以直接赋值跳过这一轮，进行下一轮遍历</li>
<li>经过上一步的筛选，此时剩下的只是对象类型，由于对象类型无法通过 typeof 直接区分，所以可以借用原始对象原型方法  <code>Object.prototype.toString.call(obj)</code>  来进行<strong>对象具体类型</strong>的判断</li>
<li>toString 判断的结果会以’[object xxx]’，xxx 为对应对象类型形式体现，基于这种转换可以清晰判断对象的具体类型，之后再对各种类型进行相应的深拷贝即可</li>
<li>以上并未使用递归，由于上述的拷贝，还未涉及多层次的嵌套关系并不需要使用递归</li>
<li>接下来将要判断<strong>嵌套类型</strong>数据，(此顺序可变，不过出现频率高的尽量放在前头) 首先判断普通对象和数组，如果是，则直接扔给递归处理，由于处理数组和普通对象的逻辑已经在这之前处理好了，现在只需重复上面的步骤，所以直接<strong>递归调用</strong>就好，递归到最后一层，应该是原始类型的数据，不会进入无限调用</li>
<li>接下来是判断 2 种<strong>特殊类型</strong> Set 和 Map，由于这 2 种类型的拷贝方式不同，进一步通过 if 分支对其判断，遍历里边所存放的值，Set 使用 add 方法向新的拷贝容器添加与拷贝对象相同的值，此处值的拷贝也应该使用深拷贝，即直接把值丢给递归函数，它就会返回一个拷贝好的值。Map 类似，调用 set 方法设置键和值，不过正好 Map 的键可以存放各种类型</li>
<li>到了拷贝 Symbol 环节，这个类型相对特殊一点，Symbol 的值是唯一的，所以要获取原 Symbol 所对应的 Symbol 值，则必须通过借用 Symbol 的原型方法来指明要获取 Symbol 所对应 Symbol 的原始值，基于原始值创建一个包装器对象，则这个对象的值与原来相同</li>
<li>筛选到这里，剩余的对象，基本上就是一些内置对象或者是不需要递归遍历属性的对象，那么就可以基于这些对象<strong>原型的构造函数</strong>来实例化相应的对象</li>
<li>最后遍历完所有的属性就可以返回这个拷贝后的新容器对象，作为拷贝对象的替代</li>
<li>基于循环引用对象的解析，由于循环引用对象会造成循环递归导致调用栈溢出，所以要考虑到一个对象不能被多次拷贝。基于这个条件可以使用 Map 对象来保存一个拷贝对应的表，因为 Map 的键的特殊效果可以保存对象，因此正好适用于对拷贝对象的记录，且值则是对应的新拷贝容器，当下次递归进来的时候先在拷贝表里查询这个键是否存在，如果存在说明已经拷贝过，则直接返回之前拷贝的结果，反之继续</li>
<li>由于 Map 存放的键属于<strong>强引用类型</strong>，且深拷贝的数据量也不小，如果这些拷贝后的拷贝表不及时释放可能会造成垃圾堆积影响性能，因此需要使用到<strong> weakMap 方法代替 Map</strong>，weakMap 存放的键为<strong>弱引用类型</strong>，且<strong>键必须为对象类型</strong>，正好之前的 newObj 就是对象类型可以存放，使用弱引用的好处，可以优化垃圾回收，weakMap 存放的是拷贝表，此拷贝表在拷贝完成之后就没有作用了，之前存放的拷贝对象，经过深拷贝给新拷贝容器，则这些旧对象在销毁之后，对应于拷贝表里的对象也应该随之清除，不应该还保留，这就是使用弱引用来保存表的原因。</li>
</ol>
<p>以上就是本人在实现过程中的思路，可能讲的比较啰嗦，但是我还是希望使用通俗的话让各位明白，表达能力有限，望谅解。</p>
<p>接下来让我们看看 WeakMap 的好处</p>
<pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123;
  name: &#123;
    age: [&#123;
      who: &#39;me&#39;
    &#125;]
  &#125;
&#125;
let wm &#x3D; new WeakMap()
deepClonePlus(obj, wm)
obj&#x3D;null
console.dir(wm) &#x2F;&#x2F; No properties 即为空
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面可以看出如果原拷贝对象被清空那么 WeakMap 保存的拷贝表也将被清空，总的来说方便一点，总比麻烦一点好</p>
<p>看看这种情况</p>
<pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;
  name: &#123;
    age: [&#123;
      who: &#39;me&#39;
    &#125;]
  &#125;
&#125;
let wm &#x3D; new WeakMap()
console.time(&#39;start&#39;)
for (let i &#x3D; 0; i &lt; 1000000; i++) &#123;
  deepClonePlus(obj, wm) &#x2F;&#x2F; wm为手动传入的weakmap
  &#x2F;&#x2F; 此处为了与下面对比，这里故意重置weakmap存储的拷贝值
  wm &#x3D; new WeakMap() 
&#125;
console.timeEnd(&#39;start&#39;) &#x2F;&#x2F; 耗时2645ms
------------------------------------------------
let wm &#x3D; new WeakMap()
let m
console.time(&#39;start&#39;)
for (let i &#x3D; 0; i &lt; 1000000; i++) &#123;
  deepClonePlus(obj, wm)
  &#x2F;&#x2F; 此次为对照组，也执行创建WeakMap但是不重置之前拷贝的wm
  m &#x3D; new WeakMap()
&#125;
console.timeEnd(&#39;start&#39;) &#x2F;&#x2F; 耗时73ms
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上对比可以看出如果是多次拷贝同一对象，最好使用 WeakMap 来存储拷贝表，那么之后的每次拷贝只需从拷贝表中取出值即可，由于是浅拷贝所以时间较短 (<strong>注意：不过这种直接从 WeakMap 中取出的值属于浅拷贝，使用同一个 wm 对象拷贝出来的都是浅拷贝，如果每个都需要深拷贝那么只能每次重新创建 WeakMap</strong>)</p>
<h2 id="三-原型与原型链"><a class="markdownIt-Anchor" href="#三-原型与原型链">#</a> 三、原型与原型链</h2>
<p>为了方便后续讲解，这里先介绍几个知识点：</p>
<p><strong>一、 <code>__proto__</code> 属性</strong></p>
<blockquote>
<p>对象的 <code>__proto__</code> 属性并非 ECMAScript 标准，由于早期无法获取对象原型即对象内部 [[Prototype]] 属性，各大浏览器厂家对 Object.prototype 通过访问描述符实现 <code>__proto__</code> 的 getter 与 setter 来达到访问调用对象的 [[Prototype]]，[[Prototype]] 属性属于对象内部属性无法直接访问，此属性指向对象原型。</p>
</blockquote>
<p><code>__proto__</code> 大致实现</p>
<pre class="line-numbers language-none"><code class="language-none">Object.defineProperty(Object.prototype,&#39;__proto__&#39;,&#123;
  get: function()&#123;
    return Object.getPrototypeOf(this)  &#x2F;&#x2F; 获取引用对象的[[Prototype]]
  &#125;,
  set: function(o)&#123;
    Object.setPrototypeOf(this,o) &#x2F;&#x2F; 设置引用对象[[Prototype]]属性关联的原型为o
    return o
  &#125;
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以本质上是通过访问器属性来获取与设置对象关联的原型，可以理解通过 <code>__proto__</code> 能获取与设置原型的引用</p>
<p>这里先把<strong>普通对象的 <code>__proto__</code> 属性就称呼为对象原型</strong>，以便接下来的讲解</p>
<p><strong>二、函数的 prototype 属性</strong></p>
<blockquote>
<p>所有函数都有的 prototype 属性，js 中函数也属于对象的子类型，所以函数也具备对象的 <code>__proto__</code> 与普通对象类似都指向其原型。而这里的 prototype 属性，是函数独有的。当函数使用 new 关键字修饰时，我们可以理解为此函数被当作构造函数使用也就是构造器。当函数被用作构造函数调用时，其 prototype 发挥了作用，使得由构造器 new 出来对象的 <code>__proto__</code> 指向构造函数的 prototype。</p>
</blockquote>
<p>以下演示函数 prototype 属性在实例化时的作用</p>
<pre class="line-numbers language-none"><code class="language-none">function Foo()&#123;&#125; &#x2F;&#x2F; 定义构造函数
console.dir(Foo.prototype) &#x2F;&#x2F; 定义Foo构造函数时，自动创建的“干净的实例原型”，在原型链第二幅图的左下角有体现

const obj &#x3D; new Foo() &#x2F;&#x2F;创建一个实例对象

console.dir(obj.__proto__&#x3D;&#x3D;&#x3D;Foo.prototype) &#x2F;&#x2F; true，表名实例关联的原型即为构造函数的prototype指向的原型对象
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了便于讲解，这里把<strong>函数的 prototype 称呼为构造器原型</strong>，以便接下来的讲解。这里要区分函数的 <code>__proto__</code> 属性是作为对象时，关联的原型 (即对象原型)，函数的 <code>prototype</code>  作为构造函数调用时关联的原型 (即构造器原型)，这里要先弄清楚其中的区别，以便接下来的讲解</p>
<p><strong>三、各类方法与属性的统称</strong></p>
<blockquote>
<p>构造函数中定义的方法，我们统称为<strong>静态方法</strong>，构造函数中定义的属性我们统称为<strong>静态属性</strong>。在原型中定义的属性，我们统称为<strong>原型属性</strong>，在原型中定义的方法，我们统称为<strong>原型方法</strong>。实例中的属性以及方法，我们也就称呼为<strong>实例属性 / 方法</strong>。当然方法也属于属性，只是我们通常把定义在对象中的函数称为方法</p>
</blockquote>
<h3 id="原型"><a class="markdownIt-Anchor" href="#原型">#</a> 原型</h3>
<ul>
<li>只有对象类型才有原型概念</li>
<li>普通对象 (即使用对象字面量或者 Object 构造器创建的对象) 的原型为 <code>__proto__</code> 属性，此属性其实是个访问器属性，并不是真实存在的属性，或者可以使用 es6 的 <code>Reflect.getPrototypeOf(obj)</code>  和 <code>Object.getPrototypeOf(obj)</code>  方法获取对象的原型，其关系 <code>Reflect.getPrototypeOf(&#123;&#125;) === Object.getPrototypeOf(&#123;&#125;) === &#123;&#125;.__proto__</code></li>
<li>普通函数有 2 个属性，一个是是 <code>__proto__</code> (与普通对象类似)，还有一个是函数专有的 <code>prototype</code>  属性，因为函数有双重身份，即可以是实例也可以是构造器，所以关系比较特殊</li>
<li>不是所有的对象都会有原型，比如对象原型 <code>Object.prototype</code>  的原型 <code>Object.prototype.__proto__</code> 就指向 null，字典对象的原型也为 null (把对象的 <code>__proto__</code> 设置为 null，或者使用 <code>Object.create(null)</code>  创建一个没有原型的字典对象，但是这个对象还是属于对象类型)，所以原始对象原型 (Object.prototype) 就是最原始的原型，其他对象类型都要继承自它。</li>
<li>箭头函数虽然属于函数，由 Function 产生，但是没有 prototype 属性没有构造器特性，所以也就没有所谓的 constructor，就不能作为构造器使用</li>
</ul>
<h3 id="原型链"><a class="markdownIt-Anchor" href="#原型链">#</a> 原型链</h3>
<p>这里会详细介绍原型、原型链、实例、构造器的关系 先看最原始的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d5011fdf60d7%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>由如上关系可以验证 <code>console.log(Function.prototype.__proto__.constructor.__proto__.constructor === Function) //true</code></p>
<ul>
<li>所有函数都是由 Function 函数构造器实例化而来</li>
<li>所有实例的原型都指向构造它的构造器的 prototype</li>
<li>每个构造器自身特有的方法就是<strong>静态方法</strong>，原型上的方法可供所有继承它或间接继承它的实例使用</li>
<li>构造器也是函数，也是被 Function 实例化出来的，所以构造器的 <code>__proto__</code> 就是 Function，但是构造器的 prototype 属性指向的原型，是此构造器实例化出来的实例所指向的原型；简单说构造器的 prototype 就是作为它的实例的原型</li>
</ul>
<p>看看函数的原型链</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d5061a3d5f66~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>在 js 中函数有多重身份，函数可以作为类就是构造器使用，定义静态方法，作为普通函数调用，</li>
<li>只有由原始函数构造器 (Function) 实例化的函数才拥有直接使用函数原型 (Function.prototype) 上面的内置方法，创建函数只能通过原始函数构造器生成，</li>
<li>普通函数作为构造器使用 (new) 时相当于类 (class) 使用，类的 prototype 就是实例的原型，我们可以给原型添加属性，给类添加属性时就相当于给构造器添加静态属性</li>
<li>普通函数在创建实例的时候，会生成一个实例的原型，此原型指向 Object.prototype 即原始对象原型，也就是继承对象原型，这么一来实例也继承了对象的原型，则实例也属于对象类型</li>
</ul>
<h2 id="四-实现class与extends"><a class="markdownIt-Anchor" href="#四-实现class与extends">#</a> 四、实现 class 与 extends</h2>
<h3 id="实现class"><a class="markdownIt-Anchor" href="#实现class">#</a> 实现 class</h3>
<ul>
<li>es6 加入的 class 其实是为了开发者方便创建类，与其他语言在写法上尽量一致，但是 js 原生并没有类这个东西，为了实现类的效果，可以通过 js 的构造器来实现，class 使用 new 关键字生成实例，构造器也是通过 new 来实例化，那么可以推断 class 本质也是个构造器</li>
<li>手动实现 class</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const Class &#x3D; (function () &#123;
  function Constructor(name) &#123;
    this.name &#x3D; name
  &#125;
  &#x2F;&#x2F;添加原型方法
  Constructor.prototype.getName &#x3D; function name(name) &#123;
    console.log(&#39;原型方法getName:&#39; + this.name);
  &#125;
  &#x2F;&#x2F;添加原型属性
  Constructor.prototype.age &#x3D; &#39;原型属性age&#39;
  &#x2F;&#x2F;添加静态方法
  Constructor.log &#x3D; function log() &#123;
    console.log(&#39;我是构造器的静态方法log&#39;);
  &#125;
  &#x2F;&#x2F;添加静态属性
  Constructor.isWho &#x3D; &#39;构造器静态属性isWho&#39;
  return Constructor
&#125;)()
const i &#x3D; new Class(&#39;我是实例&#39;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现 class 语法糖，只需封装一层函数。</p>
<ul>
<li>返回的 Constructor 就是实例的构造器，其 prototype 是个空白的对象这是由于 Function 造成的</li>
<li>new 后面调用的函数必须是一个构造器函数，用于构造实例，此构造器的 this 指向实例</li>
<li>构造器内部需要实现依照传入的参数设置实例的属性</li>
<li>定义 Class 时需要实现原型属性和静态属性的挂载</li>
</ul>
<p>以上只实现 class 的定义，接下来要实现能够兼容继承的写法</p>
<h3 id="实现extends"><a class="markdownIt-Anchor" href="#实现extends">#</a> 实现 extends</h3>
<ul>
<li>继承需要满足原型的继承</li>
<li>还需要满足可调用父类构造器</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;父类
const Parent &#x3D; (function () &#123;
  function Constructor(age) &#123;
    this.age &#x3D; age
  &#125;
  Constructor.prototype.getName &#x3D; function () &#123;
    console.log(this.name);
  &#125;
  return Constructor
&#125;)()
&#x2F;&#x2F;子类
const Class &#x3D; (function (_Parent &#x3D; null) &#123;
  if (_Parent) &#123;
    Constructor.prototype &#x3D; Object.create(_Parent.prototype, &#123;
      constructor: &#123;
        value: Constructor,
        enumerable: false,
        writable: true,
        configurable: true
      &#125;
    &#125;)
    Constructor.__proto__ &#x3D; _Parent
  &#125;
  function Constructor(name, age) &#123;
    _Parent ? _Parent.call(this, age) : this
    this.name &#x3D; name
  &#125;
  Constructor.prototype.getAge &#x3D; function () &#123;
    console.log(this.age);
  &#125;
  return Constructor
&#125;)(Parent)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>实现原型继承，可以使用之前的继承写法，注意 class 形式的继承，会把父类设为子类的 <code>__proto__</code></li>
<li>在构造函数内判断是否有父类，如果有就要调用父类的构造函数，把当前的 this 传入，这样才能生成父类构造器中定义的属性，这才算是真正的继承。继承不单继承原型还能实现继承父类构造器中定义的属性</li>
<li>对于原型方法和静态方法也是类似定义，注意定义的方法如果用到 this 需要使用 function 关键字定义函数，不可使用匿名函数，否则 this 无法指向调用对象本身</li>
</ul>
<h2 id="五-继承与实现"><a class="markdownIt-Anchor" href="#五-继承与实现">#</a> 五、继承与实现</h2>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承">#</a> 继承</h3>
<ul>
<li>js 中的继承一般分为三部分：原型属性继承、静态属性继承、实例属性继承，一个原型上面定义的方法一般都是基于其实例的用途来定义的，也就是说，原型的方法应该是实例经常用到的通用方法，而构造器方法一般是特定情况下可能会用到的方法，可按需调用，原型方法只能供其实例来使用</li>
<li>继承可以让原型链丰富，根据需求定制不同的原型链，不会存在内存浪费的情况，原型只会保留一份，用到的时候调用就行，还能节省空间</li>
</ul>
<h3 id="原型继承"><a class="markdownIt-Anchor" href="#原型继承">#</a> 原型继承</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/171ca09c9d401748%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>可以看出原型一般是一些共有的特性，实例是特有的特性，继承的越多越具体，原型链的最顶端是最抽象的，越底端越具体，这样一来我们可以根据需求在恰当位置继承来实现个性化的定制属性，统一而又有多样化</li>
</ul>
<h3 id="原型之间的继承"><a class="markdownIt-Anchor" href="#原型之间的继承">#</a> 原型之间的继承</h3>
<pre class="line-numbers language-none"><code class="language-none">function Parent()&#123;&#125; &#x2F;&#x2F; 定义父类构造器
function Children()&#123;&#125; &#x2F;&#x2F; 定义子类构造器

let ChildPrototype &#x3D; Children.prototype &#x2F;&#x2F; 构造器原型
let ChildPrototypeProto &#x3D; Children.prototype.__proto__ &#x2F;&#x2F; 构造器原型的对象原型

&#x2F;&#x2F; 方法一
ChildPrototypeProto &#x3D; Parent.prototype &#x2F;&#x2F; 父类构造器原型作为子类构造器原型(ChildPrototype)的对象原型(ChildPrototypeProto)

&#x2F;&#x2F;方法二
ChildPrototype &#x3D; Object.create(Parent.prototype) &#x2F;&#x2F; Object.create返回一个对象，其__proto__指向传入的参数，也就实现返回的对象继承参数对象

&#x2F;&#x2F;方法三
Object.setPrototypeOf(ChildPrototype, Parent.prototype) &#x2F;&#x2F; 直接设置参数1的原型(__proto__)为参数2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上仅实现了原型之间的继承</p>
<h3 id="静态属性继承"><a class="markdownIt-Anchor" href="#静态属性继承">#</a> 静态属性继承</h3>
<ul>
<li>静态属性的继承，意味着父构造器中定义的静态属性，在子构造器中可以直接调用。不仅实例可以通过对象原型实现继承，构造器也可以通过对象原型继承。之前提到过函数有 <code>prototype</code>  与 <code>__proto__</code> ，其中 <code>prototype</code>  是给实例用的，而 <code>__proto__</code> 是给自己用的。</li>
<li>默认的构造函数的对象原型都指向原始函数构造器原型 (即 Function.prototype)，可以理解所有函数都是由原始函数构造器生成</li>
<li>通过构造函数自身的对象原型 ( <code>__proto__</code> )，来实现静态属性继承</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">function Parent() &#123;&#125; &#x2F;&#x2F; 定义父构造函数
function Children() &#123;&#125; &#x2F;&#x2F;定义子构造函数

&#x2F;&#x2F; 定义父构造函数的静态方法
Parent.foo &#x3D; function () &#123;
  console.log(this.name)
&#125;

&#x2F;&#x2F; 方法一
Children.__proto__ &#x3D; Parent &#x2F;&#x2F; 子构造函数的对象原型指向父构造函数，也就实现继承

&#x2F;&#x2F; 方法二
Object.setPrototypeOf(Children, Parent) &#x2F;&#x2F; 同原型继承

console.log(Children.foo) &#x2F;&#x2F; function()&#123; console.log(this.name) &#125; ,实现继承
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上即为构造函数之间通过对象原型继承静态属性，注：函数也是对象</p>
<h3 id="实例属性继承"><a class="markdownIt-Anchor" href="#实例属性继承">#</a> 实例属性继承</h3>
<ul>
<li>实例自带的属性是由构造函数实例化时默认生成的，那么要实现实例属性的继承，势必要实现子构造函数中调用父构造函数，这样才能实现子构造函数实例化出来的对象也具备父构造函数给予的默认属性</li>
<li>在 class 语法糖的 constructor 中的 super () 函数就是实现这个继承</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 定义父构造函数
function Parent(name) &#123;
  this.name &#x3D; name
&#125;

&#x2F;&#x2F;定义子构造函数
function Children(name,age) &#123;
  Parent.call(this,name)  &#x2F;&#x2F; 这里调用父构造器，实现实例属性继承
  this.age &#x3D; age
&#125;

const obj &#x3D; new Children(&#39;tom&#39;, 5)

console.log(obj) &#x2F;&#x2F; &#123;name: &#39;tom&#39;, age: 5&#125; ，实现实例属性继承
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过实例属性继承，可以把父构造器中默认生成的实例属性追加到子构造器实例化出来的对象上</p>
<p>综合以上继承，现在实现真正的继承</p>
<h3 id="继承的实现"><a class="markdownIt-Anchor" href="#继承的实现">#</a> 继承的实现</h3>
<ul>
<li>通过 es6 的 extends 关键字来继承原型</li>
<li>手动实现原型继承</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 定义父构造函数，功能：初始化实例name属性
function Parent(name) &#123;
  &#39;use strict&#39;
  this.name &#x3D; name
&#125;
&#x2F;&#x2F; 定义父构造函数的静态方法，功能：设置调用对象的name属性
Parent.setName &#x3D; function setName(obj, name) &#123;
  obj.name &#x3D; name
&#125;
&#x2F;&#x2F; 定义父构造器原型(prototype)的方法，功能：获取调用对象的name属性
Parent.prototype.getName &#x3D; function getName() &#123;
  return this.name
&#125;

&#x2F;*-----以上已定义父类的原型方法(获取name)，父类静态方法(设置name)，以及构造器默认初始化的属性name------*&#x2F;

&#x2F;&#x2F; 定义子构造函数，功能：初始化实例age属性，以及通过父构造器初始化实例name属性
function Children(name, age) &#123;
  &#39;use strict&#39;
  Parent.call(this, name) &#x2F;&#x2F; 调用父构造器，初始化name属性
  this.age &#x3D; age &#x2F;&#x2F; 子构造器初始化age属性
&#125;
&#x2F;&#x2F; 定义子构造函数的静态方法，功能：设置调用对象的age属性
Children.setAge &#x3D; function setAge(obj, age) &#123;
  obj.age &#x3D; age
&#125;

&#x2F;&#x2F; 原型继承
&#x2F;&#x2F; 设置Children.prototype[&#39;[[Prototype]]&#39;]&#x3D; Parent.prototype，此处的&#39;[[Prototype]]&#39;与设置__proto__相同
Children.prototype &#x3D; Object.create(Parent.prototype)
&#x2F;&#x2F; 注意此处原型继承之后，不带有constructor属性，应该手动指明为Children
Object.defineProperty(Children.prototype, &#39;constructor&#39;, &#123;
  value: Children,
  writable: true, &#x2F;&#x2F; 可写
  enumerable: false, &#x2F;&#x2F; 不可枚举
  configurable: true, &#x2F;&#x2F; 可配置
&#125;)
&#x2F;&#x2F;以上2句可以直接写成一句
&#x2F;*
Children.prototype &#x3D; Object.create(Parent.prototype, &#123;
  constructor: &#123;
    value: Children,
    writable: true, &#x2F;&#x2F; 可写
    enumerable: false, &#x2F;&#x2F; 不可枚举
    configurable: true, &#x2F;&#x2F; 可配置
  &#125;
&#125;)
*&#x2F;

&#x2F;&#x2F; 由于子构造器原型方法必须在继承之后再定义，否则会被继承覆盖
&#x2F;&#x2F; 定义子构造器原型(prototype)的方法，功能：获取调用对象的age属性
Children.prototype.getAge &#x3D; function getAge() &#123;
  return this.age
&#125;

&#x2F;&#x2F; 构造函数(继承静态属性)继承
&#x2F;&#x2F; 设置Children.__proto__ &#x3D; Parent，注意此处不能使用Children &#x3D; Object.create(Parent)，因为Object.create返回的是一个对象不能替换构造函数
Object.setPrototypeOf(Children, Parent)

&#x2F;&#x2F; 测试父级
const obj &#x3D; new Parent(&#39;tom&#39;) &#x2F;&#x2F; 实例化父级实例
console.log(obj.getName()) &#x2F;&#x2F; tom
Parent.setName(obj, &#39;jerry&#39;) &#x2F;&#x2F; 通过父级静态方法设置name
console.log(obj.getName()) &#x2F;&#x2F; jerry
console.log(obj instanceof Parent) &#x2F;&#x2F; true

&#x2F;&#x2F; 测试子级
const obj1 &#x3D; new Children(null, 5) &#x2F;&#x2F; 实例化子级实例
console.log(obj1.getAge()) &#x2F;&#x2F; 5
Children.setAge(obj1, 8) &#x2F;&#x2F; 通过子级静态方法设置age
console.log(obj1.getAge()) &#x2F;&#x2F; 8
console.log(obj1 instanceof Parent) &#x2F;&#x2F; true
console.log(obj1 instanceof Children) &#x2F;&#x2F; true

&#x2F;&#x2F; 完整测试继承
const test &#x3D; new Children(&#39;tom&#39;, 5) &#x2F;&#x2F; 实例化子级实例,name&#x3D;&#39;tom&#39;,age&#x3D;5
console.log(test.getName()) &#x2F;&#x2F; tom
Parent.setName(test, &#39;jerry&#39;) &#x2F;&#x2F; 通过父级静态方法设置name&#x3D;jerry
console.log(test.getName()) &#x2F;&#x2F; jerry

console.log(test.getAge()) &#x2F;&#x2F; 5
Children.setAge(test, 8) &#x2F;&#x2F; 通过子级静态方法设置age&#x3D;8
console.log(test.getAge()) &#x2F;&#x2F; 8

class P &#123;
  constructor(name) &#123;
    this.name &#x3D; name
  &#125;
  static setName(obj, name) &#123;
    obj.name &#x3D; name
  &#125;
  getName() &#123;
    return this.name
  &#125;
&#125;
class C extends P &#123;
  constructor(name, age) &#123;
    super(name)
    this.age &#x3D; age
  &#125;
  static setAge(obj, age) &#123;
    obj.age &#x3D; age
  &#125;
  getAge() &#123;
    return this.age
  &#125;
&#125;

&#x2F;&#x2F; 这里就不带测试了，可以自行验证，比对一下有什么区别
console.dir(Children)
console.dir(C)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/30/171c9f55ad79e61e~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>实现继承，需要对原型、构造器、实例属性都加以实现继承</p>
<h2 id="六-作用域-执行上下文与闭包"><a class="markdownIt-Anchor" href="#六-作用域-执行上下文与闭包">#</a> 六、作用域、执行上下文与闭包</h2>
<h3 id="作用域与作用域链"><a class="markdownIt-Anchor" href="#作用域与作用域链">#</a> 作用域与作用域链</h3>
<h4 id="作用域"><a class="markdownIt-Anchor" href="#作用域">#</a> 作用域</h4>
<ul>
<li>所有未定义的变量直接赋值会自动声明为全局作用域的变量 (隐式全局变量可以用 delete 删除，var 定义的则不行)</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">a&#x3D;1 &#x2F;&#x2F; 隐式全局变量 严格模式报错
var b&#x3D;2 &#x2F;&#x2F; 显式全局变量
console.log(a,b) &#x2F;&#x2F;1 2
delete a  &#x2F;&#x2F; 严格模式报错
delete b  &#x2F;&#x2F; 严格模式报错
console.log(b,a) &#x2F;&#x2F; 2   a is not defined 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>window 对象的所有属性拥有全局作用域</li>
<li>内层作用域可以访问外层作用域，反之不行</li>
<li>var 声明的变量，在除了函数作用域之外，在其他块语句中不会创建独立作用域</li>
<li>let 和 const 声明的变量存在块语句作用域，且不会变量提升</li>
<li>同作用域下不能重复使用 let、const 声明同名变量，var 可以，后者覆盖前者</li>
<li>for 循环的条件语句的作用域与其循环体的作用域不同，条件语句块属于循环体的父级作用域</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以下语句使用let声明不报错，说明为不同作用域
for (let i &#x3D; 0; i &lt; 5; i++) &#123;
  let i &#x3D; 5
&#125;
--------------------------------------------
&#x2F;&#x2F; 此语句报错，说明循环体为条件语句块的子作用域
&#x2F;&#x2F; for循环执行顺序为：条件语句块1-&gt;条件语句块2-&gt;循环体-&gt;条件语句块3-&gt;条件语句块2 依次类推
for (let i &#x3D; 0; i &lt; 5; i&#x3D;x) &#123; &#x2F;&#x2F; x is not defined
  let x &#x3D; 5
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链">#</a> 作用域链</h4>
<ul>
<li>作用域链也就是所谓的变量查找的范围</li>
<li>在当前作用域引用变量时，如果没有此变量，则会一路往父级作用域查找此变量，直到全局作用域，如果都没有，在非严格情况下会自动声明，所以是 undefined，在严格条件下则会报错</li>
<li>变量的查找路径依据的是在创建这个作用域的地方向上查找，并非是在执行时的作用域，如下 b 变量的值为 2。可以看出当执行到需要 b 变量时，当前作用域下并没有 b，所以要到定义这个 b 变量的静态作用域中寻找，即创建时候的作用域链上查找 b 的值</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">b &#x3D; 1
function a() &#123;
  &#x2F;&#x2F; 定义b，找到
  const b &#x3D; 2
  function s() &#123;
    &#x2F;&#x2F; 使用到b，当前作用域并没有，向上找
    console.log(b);
  &#125;
  return s
&#125;
const s &#x3D; a()
var b &#x3D; 3
s() &#x2F;&#x2F; 2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>作用域在脚本解析阶段就已经规定好了，所以与执行阶段无关，且无法改变</li>
</ul>
<h3 id="执行上下文"><a class="markdownIt-Anchor" href="#执行上下文">#</a> 执行上下文</h3>
<ul>
<li>执行上下文在运行时确定，随时可能改变</li>
<li>调用栈中存放多个执行上下文，按照后进先出的规则进行创建和销毁，最底部的执行上下文，也就是栈低的执行上下文为全局上下文，最早被压入栈中，其上下文中的 this 指向 window，严格模式下为 undefined</li>
<li>创建执行上下文时，会绑定当前 this，确定词法环境，存储当前环境下函数声明内容，变量 let 与 const 绑定但未关联任何值，确认变量环境时，绑定 var 的初始值为 undefined</li>
<li>在 var 声明之前，调用 var 声明的变量时值为 undefined，因为创建了执行上下文，var 声明的变量已经绑定初始 undefined，而在 let 和 const 声明之前调用其声明的变量时，由于只绑定在了执行上下文中，但并未初始任何值，所以在声明之前调用则会抛出引用错误 (即 TDZ 暂时性死区)，这也就是函数声明与 var 声明在执行上下文中的提升</li>
</ul>
<p>这里了解一下函数、变量提升</p>
<pre class="line-numbers language-none"><code class="language-none">console.dir(foo) &#x2F;&#x2F; foo()&#123;&#125;
function foo() &#123;&#125;
var foo &#x3D; 5
&#x2F;*
console.dir(foo) &#x2F;&#x2F; undefined
var foo &#x3D; 5
*&#x2F;
------------------------------
var foo &#x3D; 5
function foo() &#123;&#125;
console.dir(foo) &#x2F;&#x2F; 5
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上代码结果可以得出结论：</p>
<ul>
<li>上面代码块能够体现，在解析阶段会将函数与变量提升，且函数的优先级比 var 声明的变量高，因为打印的是函数声明，如果 var 声明的优先级高，那么应该是 undefined</li>
<li>从下面的代码块中可以看出 foo 在代码执行的时候被赋值为 5，而函数声明在解析阶段已经结束，在执行阶段没有效果</li>
<li>还有一点 个人认为在解析阶段，函数声明与变量声明提升之后在代码块中的位置顺序没什么关系</li>
</ul>
<h3 id="闭包"><a class="markdownIt-Anchor" href="#闭包">#</a> 闭包</h3>
<ul>
<li>所谓闭包就是函数与其词法环境 (创建当前作用时的任何局部变量) 的引用。闭包可以使内部函数访问到外部函数的作用域，当函数被创建时即生成闭包</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">function fn1() &#123;
  var name &#x3D; &#39;hi&#39;;
  function fn2() &#123;
    console.log(name);
  &#125;
  return fn2
&#125;
fn1()() &#x2F;&#x2F; hi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当你从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即当前词法环境</li>
<li>闭包只会保留环境中任何变量的最后一个值，这是因为闭包所保存的是整个变量的对象</li>
<li>闭包的作用域链包含着它自己的作用域，以及包含它父级函数的作用域和全局作用域</li>
<li>当返回一个闭包时，保留此闭包下的所有被外部引用的对象</li>
<li>闭包之间是独立的，在闭包环境下可以创建多个不同的闭包环境暴露给外部，从而实现不同的效果</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">function makeAdder(x) &#123;
  return function(y) &#123;
    return x + y;
  &#125;;
&#125;
var add5 &#x3D; makeAdder(5);
var add10 &#x3D; makeAdder(10);
console.log(add5(2));  &#x2F;&#x2F; 7
console.log(add10(2)); &#x2F;&#x2F; 12
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>暴露闭包的方式不止返回内部函数一种，还可以使用回调函数产生闭包环境，或者把内部函数赋值给其他外部对象使用</li>
<li>闭包在没有被外部使用的情况下，随执行结束销毁，如何产生闭包并且保留闭包环境的关键就在于不让其环境被垃圾回收系统自动清除，那么就要使内部环境中的引用被外部保留，这样才能保留闭包</li>
<li>闭包虽然方便我们操作和保留内部环境，但是闭包在处理速度和内存消耗方面对脚本性能具有负面影响，除非在特定的情况下使用</li>
</ul>
<p>这里看个有趣的东西</p>
<pre class="line-numbers language-none"><code class="language-none">function foo()&#123;
  let a&#x3D;&#123;name:&#39;me&#39;&#125;
  let b&#x3D;&#123;who:&#39;isMe&#39;&#125;
  let wm&#x3D;new WeakMap()
  function bar()&#123;
    console.log(a)  &#x2F;&#x2F; a被闭包保留
    wm.set(b,1) &#x2F;&#x2F; 弱引用b对象
    return wm &#x2F;&#x2F;wm被闭包保留
  &#125;
  return bar
&#125;
const wm&#x3D;foo()()
console.dir(wm) &#x2F;&#x2F; No properties 即为空
-------------------------------------------
function foo()&#123;
  let a&#x3D;&#123;name:&#39;me&#39;&#125;
  let wm&#x3D;new WeakMap()
  function bar()&#123;
    console.log(a)
    wm.set(a,1)
    return wm
  &#125;
  return bar
&#125;
const wm&#x3D;foo()()
console.dir(wm) &#x2F;&#x2F; 保存了对象a与其值1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>从上块代码中可以看出，bar 被 return 到外部环境，所以其内部形成闭包，bar 中使用到的变量 (a,wm) 都会被保留下来，但是最后打印 wm 的时候为空？这是因为外部并没有引用到 b 对象，只是通过 wm 弱引用保存 b 的值，从 wm 为空可以看出，闭包内部的 b 被清除，所以 wm 也自动清除 b 的弱引用，可以论证之前所说，闭包只保留外部用到的变量</li>
<li>从下块代码能直接看出 a 就是闭包中的 a，bar 在外部执行时需要用到 a 与 wm 所以保留了下来</li>
<li>有人可能会不解，为什么上块代码中的 b 也被 wm.set (b,1) 引用，但是最终就没有呢，那是因为 WeakMap 中保留的是 b 的弱引用，可以理解为，wm 中的 b 是依赖原函数中的 b 而存在，当 wm 被 return 时，闭包中的 b，没有被任何外部所依赖，而是别人依赖它。可以这么理解 b 牵着别人走，因为 b 没有被外面人牵着走，所以 b 这个链子就被断开，也影响到 b 牵的人一块丢了</li>
</ul>
<h2 id="七-this"><a class="markdownIt-Anchor" href="#七-this">#</a> 七、this</h2>
<p>先看一张图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d51548402b0f~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>this 的绑定在创建执行上下文时确定</li>
<li>大多数情况函数调用的方式决定 this 的值，this 在执行时无法赋值</li>
<li>this 的值为当前执行的环境对象，非严格下总是指向一个对象，严格下可以是任意值</li>
<li>全局环境下 this 始终指向 window，严格模式下函数的调用没有明确调用对象的情况下，函数内部 this 指向 undefined，非严格下指向 window</li>
<li>箭头函数的 this 永远指向创建当前词法环境时的 this</li>
<li>作为构造函数时，函数中的 this 指向实例对象</li>
<li>this 的绑定只受最靠近调用它的成员的引用</li>
<li>执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定 this，所以 this 的指向永远是在执行时确定</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">function foo()&#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下undefined
&#125;
foo()
-----------------------------------------------
function foo()&#123;
  console.dir(this) &#x2F;&#x2F;非严格Number对象，严格模式 5
&#125;
foo.call(5)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>严格与非严格模式下的 this 指向是不同的，非严格总是指向一个对象，严格模式可以为任意值</p>
<p>执行前</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d51c276f0ae3~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>执行后</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d51da155695f%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>以上 2 图可以使用 chrome 开发工具来进行查看程序执行时的相关数据，可以看到严格模式下简单调用的函数内部的 this 指向 undefined</p>
<h3 id="普通函数中的this"><a class="markdownIt-Anchor" href="#普通函数中的this">#</a> 普通函数中的 this</h3>
<h4 id="直接调用"><a class="markdownIt-Anchor" href="#直接调用">#</a> 直接调用</h4>
<p>在没有明确调用者情况下函数内部 this 指向 window，严格模式下都为 undefined，除非绑定函数的 this 指向，才会改变 this</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 直接调用函数
function foo() &#123;
  console.dir(this) &#x2F;&#x2F;window,严格下 undefined
  function boo()&#123;
    console.dir(this) &#x2F;&#x2F;window,严格下 undefined
  &#125;
  boo()
&#125;
----------------------------------------------
&#x2F;&#x2F; 取出对象中的函数，再进行调用
const obj &#x3D; &#123;
  foo: function foo() &#123;
    console.dir(this) &#x2F;&#x2F;window,严格下 undefined
    function boo() &#123;
      console.dir(this) &#x2F;&#x2F;window,严格下 undefined
    &#125;
    return boo
  &#125;
&#125;
const foo &#x3D; obj.foo
foo()()
----------------------------------------------
&#x2F;&#x2F; 直接通过对象调用函数，再调用返回的函数，可以看出this的指向随调用对象改变
const obj &#x3D; &#123;
  foo: function foo() &#123;
    console.dir(this) &#x2F;&#x2F;obj,严格下 obj
    function boo() &#123;
      console.dir(this) &#x2F;&#x2F;window,严格下 undefined
    &#125;
    return boo
  &#125;
&#125;
const foo &#x3D; obj.foo()
foo()
----------------------------------------------
&#x2F;&#x2F; 基于回调函数也是如此
function foo(func) &#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
  func()
&#125;
foo(function () &#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="基于调用者以及不同调用方式"><a class="markdownIt-Anchor" href="#基于调用者以及不同调用方式">#</a> 基于调用者以及不同调用方式</h4>
<p>函数调用也就是在函数名后面加个 ()，表示调用，如果函数名前没有加任何东西，那么默认为<strong>简单调用</strong>，在严格与非严格环境下，简单调用的函数内部 this 指向 undefined 与 window，但是全局环境下的 this 永远为 window</p>
<p>基于对象</p>
<p>当函数作为<strong>对象的方法</strong>调用时，不受函数定义方式或者位置影响</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 函数this指向调用者对象
const obj &#x3D; &#123;
  foo: function () &#123;
    console.dir(this) &#x2F;&#x2F; obj1,严格下 obj1
    function boo() &#123;
      console.dir(this) &#x2F;&#x2F; window,严格下 undefined
    &#125;
    boo()
    return boo
  &#125;
&#125;
const obj1 &#x3D; &#123;&#125;
obj1.boo &#x3D; obj.foo
obj1.boo()
----------------------------------------------
&#x2F;&#x2F; 不同调用对象时，this指向调用者
const obj &#x3D; &#123;
  foo: function () &#123;
    console.dir(this) &#x2F;&#x2F; obj,严格下 obj
    function boo() &#123;
      console.dir(this)
    &#125;
    boo() &#x2F;&#x2F; window,严格下 undefined
    return boo
  &#125;
&#125;
const obj1 &#x3D; &#123;&#125;
obj1.boo &#x3D; obj.foo()
obj1.boo() &#x2F;&#x2F; obj1,严格下 obj1
----------------------------------------------
&#x2F;&#x2F; this指向最近的调用者
const obj &#x3D; &#123;
  name: &#39;obj&#39;,
  obj1: &#123;
    name: &#39;obj1&#39;,
    foo: function () &#123;
      console.dir(this.name) &#x2F;&#x2F; obj1
    &#125;
  &#125;
&#125;
obj.obj1.foo()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基于 new 关键字</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 基于new关键字调用的函数内部this指向实例
function foo() &#123;
  console.dir(this) &#x2F;&#x2F; foo实例
  console.log(this instanceof foo) &#x2F;&#x2F;true
  console.log(foo.prototype.isPrototypeOf(this)) &#x2F;&#x2F;true
  that &#x3D; this
&#125;
var that
const f &#x3D; new foo()
console.log(that &#x3D;&#x3D;&#x3D; f) &#x2F;&#x2F; true
----------------------------------------------
&#x2F;&#x2F; 嵌套函数内部this与调用函数所在环境的this无关
function foo() &#123;
  console.dir(this) &#x2F;&#x2F; foo实例
  function boo() &#123;
    console.dir(this) &#x2F;&#x2F;window,严格下undefined
  &#125;
  boo()
&#125;
const f &#x3D; new foo()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基于定时器与微任务</p>
<p>微任务中的简单调用的函数 this 指向 window 严格下指向 undefined，而<strong>定时器中的回调函数不管在严格还是非严格环境下 this 永远指向 window</strong>，说明一点，调用 window 对象的方法时 this 指向 window 也就是全局对象，换句话说，简单调用的函数如果属于 window 本身自带的方法那么这个方法的 this 指向 window</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 异步任务中简单调用的函数都是进入队列，最后由全局环境调用
const id &#x3D; setInterval(function () &#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下 window
  setTimeout(() &#x3D;&gt; &#123;
    console.dir(this) &#x2F;&#x2F; window ,严格下 window
    clearInterval(id)
  &#125;);
&#125;)
----------------------------------------------
new Promise(function (resolve, reject) &#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
  resolve()
&#125;).then(function (res) &#123;
  console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
&#125;);
----------------------------------------------
(async function foo() &#123;
  function boo() &#123;
    console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
  &#125;
  await boo()
  console.dir(this) &#x2F;&#x2F; window ,严格下 undefined
&#125;)()
----------------------------------------------
&#x2F;&#x2F; 定时器的回调最终都会被作为简单函数被执行，定时器属于window对象的方法
function foo()&#123;
  setTimeout(function ()&#123;
    console.log(this) &#x2F;&#x2F;window ,严格下window
  &#125;)
&#125;
foo.call(5)
----------------------------------------------
&#x2F;&#x2F; 函数内部的this就是指向调用者，并且可以看出简单调用的回调函数中的this也指向window
const obj &#x3D; &#123;
  foo(callback) &#123;
    callback()
    console.log(this.foo &#x3D;&#x3D;&#x3D; obj.foo) &#x2F;&#x2F; true
    console.log(this &#x3D;&#x3D;&#x3D; obj) &#x2F;&#x2F; true
  &#125;
&#125;
obj.foo(function () &#123;
  console.log(this) &#x2F;&#x2F;window ,严格下undefined
&#125;)
----------------------------------------------
&#x2F;&#x2F; 通过arguments调用的回调函数中的this指向调用者，注意严格与非严格下的arguments对象有所不同
const obj &#x3D; &#123;
  foo(callback) &#123;
    arguments[0]()
    console.log(this.foo &#x3D;&#x3D;&#x3D; obj.foo) &#x2F;&#x2F; true
    console.log(this &#x3D;&#x3D;&#x3D; obj) &#x2F;&#x2F; true
  &#125;
&#125;
obj.foo(function () &#123;
  console.log(this) &#x2F;&#x2F;arguments对象 ，严格下 arguments对象
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="箭头函数中的this"><a class="markdownIt-Anchor" href="#箭头函数中的this">#</a> 箭头函数中的 this</h3>
<p>es6 引入的箭头函数，是不具有 this 绑定，不过在其函数体中可以使用 this，而这个 this 指向的是箭头函数当前所处的词法环境中的 this 对象，可以理解为，this 在箭头函数中是透明的，箭头函数包不住 this，所以函数内部与外部的 this 为同一值</p>
<ul>
<li>判断箭头函数的 this 指向，我们可以把箭头函数看成透明，其上下文中的 this 就是它的 this</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 可以看出箭头函数中的this就是其所在环境的this，箭头函数无法固定this，由其环境决定
const foo &#x3D; () &#x3D;&gt; &#123;
  console.dir(this) &#x2F;&#x2F;window ,严格下还是window
&#125;
foo()
----------------------------------------------
&#x2F;&#x2F; 可见对象中的this指向window，箭头函数中的this指向对象中的this。由于只有创建执行上下文才会绑定this指向，而除了全局上下文，只有函数作用域才会创建上下文环境从而绑定this，创建对象不会绑定this，所以还是全局this
const obj&#x3D;&#123;
  this:this,
  foo:()&#x3D;&gt;&#123;
    console.dir(this) &#x2F;&#x2F;window ，严格下 window
  &#125;
&#125;
console.dir(obj.this) &#x2F;&#x2F;window ，严格下 window
obj.foo()
---------------------------------------------
&#x2F;&#x2F; 对象方法内部嵌套箭头函数，则此箭头函数的this属于外部非箭头函数this。当调用obj.foo时foo函数创建的执行上下文中的this绑定对象obj，而箭头函数并不会绑定this，所以其this属于foo下的this，即对象obj
const obj &#x3D; &#123;
  foo: function () &#123;
    return () &#x3D;&gt; &#123;
      console.dir(this) &#x2F;&#x2F;obj ，严格下 obj
    &#125;
  &#125;
&#125;
obj.foo()()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="如何改变函数的this指向"><a class="markdownIt-Anchor" href="#如何改变函数的this指向">#</a> 如何改变函数的 this 指向</h3>
<p>最简单的方法通过 apply、call、bind 来给函数绑定 this</p>
<ul>
<li>apply 方法中第一个参数为被调用的函数中的 this 指向，传入你想要绑定的 this 值即可，第二个参数为被调用函数的参数集合，通常是个数组</li>
<li>call 与 apply 方法基本一致，区别在于传入参数形式不同，call 传入的参数为可变参数列表，参数按逐个传入</li>
<li>bind 方法与以上不同的是不会直接调用函数，只是先绑定函数的 this，到要使用的时候调用即可，此方法返回一个绑定 this 与参数之后的新函数，其传入参数形式同 call</li>
<li>通过变量保留指定 this 来达到固定 this</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过变量保留父级this，进行对_this变量修改也就达到修改原this的效果
const obj &#x3D; &#123;
  name: &#39;obj&#39;,
  foo: function () &#123;
    let _this &#x3D; this
    function boo() &#123;
      _this.name &#x3D; &#39;OBJ&#39;
      console.dir(obj.name) &#x2F;&#x2F; OBJ
    &#125;
    return boo
  &#125;
&#125;
obj.foo()()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="八-apply-call-bind实现"><a class="markdownIt-Anchor" href="#八-apply-call-bind实现">#</a> 八、apply、call、bind 实现</h2>
<p>这 3 者的实现其实差不多，bind 实现可能会有点不一样，都要实现 this 的改变</p>
<h3 id="手动实现apply"><a class="markdownIt-Anchor" href="#手动实现apply">#</a> 手动实现 apply</h3>
<ul>
<li>思路就是想办法使函数被传入的 thisArg 调用，那么函数的 this 就指向调用者</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Function.prototype.Apply &#x3D; function (thisArg, args &#x3D; Symbol.for(&#39;args&#39;)) &#123;
  console.dir(this)            &#x2F;&#x2F;this为这个方法的调用者&#x3D;&gt;foo函数
  const fn &#x3D; Symbol(&#39;fn&#39;)      &#x2F;&#x2F;生成一个不重复的键
  thisArg[fn] &#x3D; this || window &#x2F;&#x2F;把foo函数作为传入this的一个方法
  args &#x3D;&#x3D;&#x3D; Symbol.for(&#39;args&#39;) 
  ? thisArg[fn]()
  : thisArg[fn](...args)       &#x2F;&#x2F;调用这方法，传参
  delete thisArg[fn]           &#x2F;&#x2F;使用完删除
&#125;
var name &#x3D; &#39;foo&#39;
var age &#x3D; 5
function foo(age,height) &#123;
  console.log(this.name) &#x2F;&#x2F; obj
  console.log(age)       &#x2F;&#x2F; 3
  console.log(height)    &#x2F;&#x2F; null
&#125;
const obj &#x3D; &#123;
  name: &#39;obj&#39;,
  age: 3
&#125;
foo.Apply(obj,[obj.age,null])
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="手动实现call"><a class="markdownIt-Anchor" href="#手动实现call">#</a> 手动实现 call</h3>
<p>基本思路同 apply，就是传参形式改变一下，这里通过 arguments 获取参数列表</p>
<pre class="line-numbers language-none"><code class="language-none">Function.prototype.Call &#x3D; function (thisArg) &#123;
  console.dir(this)            &#x2F;&#x2F;this为这个方法的调用者&#x3D;&gt;foo函数
  const fn &#x3D; Symbol(&#39;fn&#39;)      &#x2F;&#x2F;生成一个不重复的键
  thisArg[fn] &#x3D; this || window &#x2F;&#x2F;把foo函数作为传入this的一个方法
  const args &#x3D; Array.from(arguments).slice(1)
  args.length ? thisArg[fn](...args) : thisArg[fn]()  &#x2F;&#x2F;调用这方法，传参
  delete thisArg[fn]           &#x2F;&#x2F;使用完删除
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="手动实现bind"><a class="markdownIt-Anchor" href="#手动实现bind">#</a> 手动实现 bind</h3>
<p>bind 函数要能够返回严格绑定 this 与参数后的函数，调用这个返回的函数时有可能还会传入参数，那么需要拼接参数</p>
<pre class="line-numbers language-none"><code class="language-none">Function.prototype.Bind &#x3D; function (thisArg) &#123;
  const fn &#x3D; Symbol(&#39;fn&#39;)       &#x2F;&#x2F;生成一个不重复的键
  thisArg[fn] &#x3D; this || window  &#x2F;&#x2F;把foo函数作为传入this的一个方法
  const f &#x3D; thisArg[fn]         &#x2F;&#x2F; 负责一份函数
  delete thisArg[fn]            &#x2F;&#x2F;删除原来对象上的函数，但是保留了this指向
  const args &#x3D; Array.from(arguments).slice(1)
  return function () &#123;
    const arg &#x3D; args.concat(...arguments)
    f(...arg)
  &#125;
&#125;
var name &#x3D; &#39;foo&#39;
var age &#x3D; 5
var height &#x3D; 4
function foo(age, height) &#123;
  console.log(this.name)       &#x2F;&#x2F; obj
  console.log(age)             &#x2F;&#x2F; 3
  console.log(height)          &#x2F;&#x2F; 2
&#125;
const obj &#x3D; &#123;
  name: &#39;obj&#39;,
  age: 3
&#125;
foo.Bind(obj, obj.age)(2)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="九-同步与异步"><a class="markdownIt-Anchor" href="#九-同步与异步">#</a> 九、同步与异步</h2>
<h3 id="同步"><a class="markdownIt-Anchor" href="#同步">#</a> 同步</h3>
<ul>
<li>基于 js 的单线程同时只能处理一件事情，而同步即是在主线程上排队执行的任务，只有当前任务执行完成，才会进入下一个任务。同步执行的函数会在预期得到结果，也就是可以清楚什么时候能得到返回值</li>
<li>所有同步代码只会进入调用栈，同步代码会阻塞主线程的执行，而且会优先与其他非同步代码执行</li>
</ul>
<h3 id="异步"><a class="markdownIt-Anchor" href="#异步">#</a> 异步</h3>
<ul>
<li>异步是指当前执行的代码会进入异步线程处理之后才会再由主线程处理回调</li>
<li>异步的结果不是马上能够得到，而是会在将来的某个时间点获取到</li>
<li>通常异步代码所要经过的步骤比同步代码多，由于异步代码不是直接放在调用栈中执行，而是要派发 (可能不需要) 给其他线程处理，等处理完成后的回调放在某个地方存储 (比如任务队列)，等到同步队列执行完成之后才会取回异步回调代码进行执行</li>
</ul>
<h4 id="异步-单线程与eventloop"><a class="markdownIt-Anchor" href="#异步-单线程与eventloop">#</a> 异步、单线程与 EventLoop</h4>
<p>先看一张图，有个大体架构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d5330a5a1b7f~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>js 主线程处理当前正在执行的代码，它会执行当前调用栈栈顶的执行上下文，从堆空间 (一般是存储对象) 和栈空间 (一般存储非对象值以及对象引用) 取数据，进而处理当前调用栈所用到的数据</li>
<li>所有的同步代码会按照代码顺序压入调用栈中等待主线程执行，如果代码中遇到了异步代码，则会根据异步类型抛给异步线程执行</li>
<li>异步类型，主要分为微任务与宏任务</li>
<li>任务队列其实本质就是一块内存空间，里面的任务是依据 FIFO 先进先出的规则来执行，所有异步代码执行完毕的回调都是加入到异步任务队列中等待主线程的调用</li>
<li>异步可以提高 cpu 的利用率</li>
</ul>
<h5 id="微任务"><a class="markdownIt-Anchor" href="#微任务">#</a> 微任务</h5>
<ul>
<li>微任务队列与宏任务队列的区别就在于，主线程对于其中的任务调度的区别，主进程会优先执行微任务队列中的全部任务，当微任务中的全部任务执行完毕才会进而转到宏任务执行</li>
<li>微任务可以由这些方法关键字调用产生 Promise、async、await、MutaionObserver、process.nextTick (Node.js 环境）</li>
<li>如果调用微任务方法时，方法内部包含其他线程干预处理时，会抛给指定线程执行，而主线程继续执行下面的代码，等到其他线程处理完成之后，如果有回调函数则会把回调加入到指定异步类型 (这里为微任务队列) 的队列中排队等待主线程执行</li>
<li>微任务与宏任务的主要区别在于，主线程优先执行全部微任务，待执行完成之后才会挨个执行宏任务</li>
</ul>
<h5 id="宏任务"><a class="markdownIt-Anchor" href="#宏任务">#</a> 宏任务</h5>
<ul>
<li>一般的宏任务队列存放的是 WebApis 的回调，WebApis 中包含许多线程，GUI 渲染线程 (与 js 主线程互斥不能同时执行)、事件触发线程、定时器线程、异步网络请求线程</li>
<li>宏任务存放由异步 WebApis 产生的回调函数，但优先级低于微任务</li>
</ul>
<h5 id="js单线程"><a class="markdownIt-Anchor" href="#js单线程">#</a> js 单线程</h5>
<ul>
<li>js 单线程设计之初就是为了简化代码，解决 DOM 冲突，如果 js 为多线程语言，那么有可能产生多个线程同时操作 DOM 的情况，那么将会导致 js 操作同个 DOM 引起冲突，介于多线程的锁机制来解决冲突，但又使得 js 的代码复杂度提高</li>
<li>基于 js 单线程的设计，进而引出异步执行的方式，使得 js 具有类似多线程程的效果，但不管异步还是同步，js 永远都只有一个线程在执行</li>
</ul>
<h5 id="eventloop"><a class="markdownIt-Anchor" href="#eventloop">#</a> EventLoop</h5>
<ul>
<li>事件循环机制是针对于主线程的调度方式</li>
<li>可以理解为主线程在寻找任务执行的过程就是事件循环，其寻找方式就是调用机制</li>
<li>先了解一下浏览器是如何执行 js 代码的
<ul>
<li>通常浏览器在最开始运行 js 代码的入口就是 html 中的 script 标签所涵盖的代码</li>
<li>当 GUI 渲染线程解析到 script 标签，则会把标签所涵盖的 js 代码加入到宏任务队列中</li>
<li>首先 js 引擎 (如 V8 引擎) 先取第一个宏任务，即 script 的代码块，然后主线程在调用栈中解析 js 代码</li>
<li>等所有代码解析完成之后开始运行 js 代码</li>
<li>如果遇到同步代码直接执行</li>
<li>遇到异步代码，如果是宏任务类型即异步 WebApis 处理的异步代码，那么将会通知 WebApis 在对应的线程中处理异步任务，此时 js 主线程继续执行下面的代码，在其他线程处理完毕之后如果有回调函数，则异步线程会将回调函数加入到宏任务队列尾部，</li>
<li>如果是微任务类型的异步代码，也同宏任务处理，只不过是把回调函数加入到微任务队列中，其执行的优先级高于宏任务队列</li>
<li>当同步代码全部执行完成，主线程将会一直检测任务队列，如果有异步微任务则执行完全部的微任务</li>
<li>进一步执行浏览器渲染进程绘制页面，之后就是开始下一轮的事件循环，就又回到取宏任务执行</li>
<li>这里注意，所有的微任务都是由宏任务中执行的代码产生，一开始只有宏任务队列有任务</li>
</ul>
</li>
</ul>
<p>以下展示的是事件循环大致流程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d53968ef6d36~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>以下为主线程判断逻辑</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d53df09b5cab%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<h3 id="前端异步的场景"><a class="markdownIt-Anchor" href="#前端异步的场景">#</a> 前端异步的场景</h3>
<ul>
<li>前端异步主要用于代码可能会发生等待，而且等待过程不能阻塞主线程运行的情况</li>
<li>通常 WebApis 接口都是异步调用的，由于需要其他线程的处理，就需要等待其返回结果，那么 js 主线程就没必要一直等待，这样就需要使用异步来进行处理</li>
<li>比如定时器任务 setTimeout、setInterval、ajax 请求、图片动态加载、DOM 事件触发这些都属于浏览器执行的异步任务；如 js 中的 Promise、async、await 属于 js 语言自身的异步操作这些都可以实现异步</li>
<li>当需要动态加载图片的时候就需要用到异步；当需要执行的 js 的同步代码需要长时间占用的主线程时可以使用异步方式拆分为多个步骤执行，这样可以避免浏览器页面长时间无响应或者卡顿</li>
<li>当需要执行很长一段时间才能得到结果的代码时也可以使用 html5 中的 Web worker 在浏览器渲染进程下新开一个线程用来专门执行此代码，通过 postMessage 来返回运行结果这样也不会占用 js 主线程，但是这个线程无法操作 DOM 和 BOM</li>
</ul>
<h3 id="webworker多线程"><a class="markdownIt-Anchor" href="#webworker多线程">#</a> WebWorker 多线程</h3>
<ul>
<li>基于 js 单线程的局限性，如果执行一个很耗时间的函数，那么主线程将会被长时间占用，因此导致事件循环暂停，使得浏览器无法及时渲染和响应，那么将会造成页面崩溃，用户体验下降，所以 html5 支持了 webworker</li>
<li>webwork 简单理解就是可以让特定的 js 代码在其他线程中执行，等执行结束后返回结果给主线程接收即可</li>
<li>比如在 js 中需要实现一个识别图片的算法，而且此算法需要很长的计算时间，如果让 js 主线程来执行将会导致上述发生的事情，那么正好可以使用 webwork 技术来实现。</li>
<li>创建一个 webworker 文件，其中写入算法代码，在最后调用 postMessage (result) 方法返回结果给主线程，js 主代码中通过 w=new Worker (文件路径) 来创建一个渲染进程的 webworker 子线程实例，通过 w.onmessage=function (e){console.log (e.data)} 给其添加一个事件监听器，当 webworker 中传递消息给 js 主线程时会在此回调函数中执行，通过调用 w.terminate () 终止 webworker 线程</li>
<li>webworker 线程与 js 主线程最大的区别就在于 webworker 线程无法操作 window 与 document 对象</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; test.html(主线程)
const w&#x3D; new Worker(&#39;postMessage.js&#39;)
w.onmessage&#x3D;function(e)&#123;
  console.log(e.data);
&#125;
w.postMessage(&#39;b&#39;) &#x2F;&#x2F; b is cat
w.terminate() &#x2F;&#x2F; 手动关闭子线程
----------------------------------------------
&#x2F;&#x2F; postMessage.js(worker线程)
this.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;
  switch (e.data) &#123;
    case &#39;a&#39;: this.postMessage(e.data+&#39; is tom&#39;)
      break;
    case &#39;b&#39;: this.postMessage(e.data + &#39; is cat&#39;)
      break;
    default:  this.postMessage(e.data + &quot; i don&#39;t know&quot;)
    this.close() &#x2F;&#x2F; 自身关闭
      break;
  &#125;
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="十-amd-cmd-commonjs与es6模块化"><a class="markdownIt-Anchor" href="#十-amd-cmd-commonjs与es6模块化">#</a> 十、AMD、CMD、CommonJS 与 ES6 模块化</h2>
<p>模块化的引入主要是用于解决命名冲突、代码复用、代码可读性、依赖管理等</p>
<h3 id="amd异步模块定义"><a class="markdownIt-Anchor" href="#amd异步模块定义">#</a> AMD 异步模块定义</h3>
<ul>
<li>AMD 全称 Asynchronous Module Definition 异步模块定义</li>
<li>AMD 并非原生 js 支持，是 RequireJS 模块化开发当中推广的产物，AMD 依赖于 RequireJS 函数库，打包生成对应效果的 js 代码</li>
<li>RequireJS 主要用于解决多个 js 文件之间的依赖关系、浏览器加载大量 js 代码导致无响应、异步加载模块</li>
<li>RequireJS 通过 <code>define(id?,dependencies?,factory)</code>  定义模块，id 可选，为定义模块的标识，默认为模块文件名不包括后缀，dependencies 可选，是当前模块依赖的模块路径数组，factory 为工厂方法，初始化模块的函数或者对象，如果为函数将会只执行一次，如果是对象将作为模块的输出</li>
<li>通过 <code>require(dependencies,factory)</code>  导入模块，其中 dependencies 为需要导入的模块路径数组，factory 为当模块导入之后的回调函数，此函数的参数列表为对应导入的模块</li>
<li>通过 require.config (配置对象) 配置各模块路径和引用名</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">require.config(&#123;
  baseUrl: &quot;js&#x2F;lib&quot;,
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  &#x2F;&#x2F;实际路径为js&#x2F;lib&#x2F;jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  &#125;
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="cmd通用模块定义"><a class="markdownIt-Anchor" href="#cmd通用模块定义">#</a> CMD 通用模块定义</h3>
<ul>
<li>CMD 全称 Common Module Definition 通用模块定义</li>
<li>同 AMD，CMD 也有一个函数库 SeaJS 与 RequireJS 类似的功能</li>
<li>CMD 推崇一个文件一个模块，推崇依赖就近，定义模块 <code>define(id?,deps?,factory)</code> ，id 同 AMD，deps 一般不在其中写依赖，而是在 factory 中在需要使用的时候引入模块，factory 函数接收 3 各参数，参数一 require 方法，用来内部引入模块的时候调用，参数二 exports 是一个对象，用来向外部提供模块接口，参数三 module 也是一个对象上面存储了与当前模块相关联的一些属性和方法</li>
<li>通过 <code>seajs.use(deps,func)</code>  加载模块，deps 为引入到模块路径数组，func 为加载完成后的回调函数</li>
</ul>
<p>AMD、CMD 的主要区别在于</p>
<p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require</p>
<h3 id="commonjs"><a class="markdownIt-Anchor" href="#commonjs">#</a> CommonJS</h3>
<ul>
<li>CommonJS 模块规范，通常用于 Nodejs 中的模块化</li>
<li>拥有 4 个环境变量 modul、exports、require、global</li>
<li>通过 <code>module.exports</code>  (不推荐 exports) 导出模块对象，通过 require (模块路径) 加载模块</li>
<li>当一个模块同时存在 exports 和 module.exports 时后者覆盖前者</li>
<li>规范中 <code>__dirname</code>  代表当前模块文件所在的文件夹路径， <code>__filename</code>  代表当前模块文件夹路径 + 文件名</li>
<li>CommonJS 通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载</li>
</ul>
<h3 id="es6模块化"><a class="markdownIt-Anchor" href="#es6模块化">#</a> ES6 模块化</h3>
<ul>
<li>es6 引入的 export 与 import 用于解决 js 自身不具备模块功能的缺陷</li>
<li>通过 export 或者 export default 导出模块接口，通过 import xxx from ‘路径’，导入模块</li>
<li>对于 export 导出的接口可以使用 import {接口} from ‘路径’，通过解构的方式按需导入</li>
<li>对于 export default 默认导出的，可以使用 import xxx from ‘路径’，来导入默认导出的接口，xxx 可以是自定义名称，且一个模块只能有一个默认导出，可以有多个 export</li>
<li>还可以通过别名的方式设置导出和导入的接口名，如 export {a as foo}，把 foo 作为 a 的别名导出，import foo as b from 路径，把 b 当作 foo 的别名导入</li>
<li>es6 模块是在代码编译时输出接口即编译时加载，es6 是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用</li>
</ul>
<h2 id="十一-script标签之async与defer"><a class="markdownIt-Anchor" href="#十一-script标签之async与defer">#</a> 十一、script 标签之 async 与 defer</h2>
<h3 id="使用async属性"><a class="markdownIt-Anchor" href="#使用async属性">#</a> 使用 async 属性</h3>
<ul>
<li>如果 script 标签设置了这个值，则说明引入的 js 需要异步加载和执行，注意此属性只适用于外部引入的 js</li>
<li>在有 async 的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个 async 优先执行，则先加载好的 js 文件，所以使用此方式加载的 js 文件最好不要包含其他依赖</li>
</ul>
<h3 id="使用defer属性"><a class="markdownIt-Anchor" href="#使用defer属性">#</a> 使用 defer 属性</h3>
<ul>
<li>如果使用此属性，也将会使 js 异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用</li>
<li>html4.0 中定义了 defer，html5.0 中定义了 async</li>
</ul>
<h3 id="不同情况"><a class="markdownIt-Anchor" href="#不同情况">#</a> 不同情况</h3>
<ul>
<li>如果只有 async，那么脚本在下载完成后异步执行。</li>
<li>如果只有 defer，那么脚本会在页面解析完毕之后执行。</li>
<li>如果都没有，那么脚本会在页面中马上解执行，停止文档解析阻塞页面加载</li>
<li>如果都有那么同 async，当然此情况一般用于 html 的版本兼容下，如果没有 async 则 defer 生效</li>
<li>不过还是推荐直接把 script 标签放在 body 底部</li>
</ul>
<h2 id="十二-改变数组本身的api"><a class="markdownIt-Anchor" href="#十二-改变数组本身的api">#</a> 十二、改变数组本身的 api</h2>
<ol>
<li><code>pop()</code>  尾部弹出一个元素</li>
<li><code>push()</code>  尾部插入一个元素</li>
<li><code>shift()</code>  头部弹出一个元素</li>
<li><code>unshift()</code>  头部插入一个元素</li>
<li><code>sort([func])</code>  对数组进行排序，func 有 2 各参数，其返回值小于 0，那么参数 1 被排列到参数 2 之前，反之参数 2 排在参数 1 之前</li>
<li><code>reverse()</code>  原位反转数组中的元素</li>
<li><code>splice(pos,deleteCount,...item)</code>  返回修改后的数组，从 pos 开始删除 deleteCount 个元素，并在当前位置插入 items</li>
<li><code>copyWithin(pos[, start[, end]])</code>  复制从 start 到 end (不包括 end) 的元素，到 pos 开始的索引，返回改变后的数组，浅拷贝</li>
<li><code>arr.fill(value[, start[, end]])</code>  从 start 到 end 默认到数组最后一个位置，不包括 end，填充 val，返回填充后的数组</li>
</ol>
<p>其他数组 api 不改变原数组</p>
<h2 id="十三-window之location-navigator"><a class="markdownIt-Anchor" href="#十三-window之location-navigator">#</a> 十三、window 之 location、navigator</h2>
<h3 id="location对象"><a class="markdownIt-Anchor" href="#location对象">#</a> location 对象</h3>
<ul>
<li>location 为全局对象 window 的一个属性，且 <code>window.location===document.location</code> ，其中的属性都是可读写的，但是只有修改<strong> href</strong> 和<strong> hash</strong> 才有意义，href 会重新定位到一个 URL，hash 会跳到当前页面中的 anchor 名字的标记 (如果有)，而且页面不会被重新加载</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这行代码将会使当前页面重定向到http:&#x2F;&#x2F;www.baidu.com
window.location.href &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;
----------------------------------------------
&#x2F;&#x2F; 如果使用hash并且配合input输入框，那么当页面刷新之后，鼠标将会自动聚焦到对应id的input输入框，
&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;target&quot;&gt;
&lt;script&gt;
  window.location.hash &#x3D; &#39;#target&#39;
&lt;&#x2F;script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先看下其拥有的属性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d5465e6deae5%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<p>这里补充一个<strong> origin</strong> 属性， <code>返回URL协议+服务器名称+端口号 (location.origin == location.protocol + '//' + location.host)</code></p>
<ul>
<li>可以通过上述属性来获取 URL 中的指定部分，或者修改 href 于 hash 达到重新定位与跳转</li>
<li>添加 hash 改变监听器，来控制 hash 改变时执行的代码</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">window.addEventListener(&quot;hashchange&quot;, funcRef);
&#x2F;&#x2F; 或者
window.onhashchange &#x3D; funcRef;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>location 方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d54a9be043de%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li><code>assign(url)</code> , 通过调用 <code>window.location.assign</code>  方法来打开指定 url 的新页面 <code>window.location.assign('http://www.baidu.com')</code>  在当前页面打开百度，可回退</li>
<li><code>replace(url)</code> , 在当前页面打开指定 url，不可回退</li>
<li><code>reload([Boolean])</code> , 调用此方法将会重新加载当前页面，如果参数为 false 或者不填，则会以最优的方式重新加载页面，可能从缓存中取资源，如果参数为 true 则会从服务器重新请求加载资源</li>
</ul>
<h3 id="navigator对象"><a class="markdownIt-Anchor" href="#navigator对象">#</a> navigator 对象</h3>
<ul>
<li><code>window.navigator</code>  对象包含<strong>有关浏览器的信息</strong>，可以用它来查询一些关于运行当前脚本的应用程序的相关信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">document.write(&quot;浏览器的代码名:&quot; + navigator.appCodeName + &quot;&lt;br&gt;&quot;);
document.write(&quot;浏览器的名称:&quot; + navigator.appName + &quot;&lt;br&gt;&quot;);
document.write(&quot;当前浏览器的语言:&quot; + navigator.browserLanguage + &quot;&lt;br&gt;&quot;);
document.write(&quot;浏览器的平台和版本信息:&quot; + navigator.appVersion + &quot;&lt;br&gt;&quot;);
document.write(&quot;浏览器中是否启用 cookie :&quot; + navigator.cookieEnabled + &quot;&lt;br&gt;&quot;);
document.write(&quot;运行浏览器的操作系统平台 :&quot; + navigator.platform + &quot;&lt;br&gt;&quot;);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>navigator.appCodeName</code>  只读，任何浏览器中，总是返回 ‘Gecko’。该属性仅仅是为了保持兼容性。</li>
<li><code>navigator.appName</code>  只读，返回浏览器的官方名称。不要指望该属性返回正确的值。</li>
<li><code>navigator.appVersion</code>  只读，返回一个字符串，表示浏览器的版本。不要指望该属性返回正确的值。</li>
<li><code>navigator.platform</code>  只读，返回一个字符串，表示浏览器的所在系统平台。</li>
<li><code>navigator.product</code>  只读，返回当前浏览器的产品名称（如，“Gecko”）。</li>
<li><code>navigator.userAgent</code>  只读，返回当前浏览器的用户代理字符串（user agent string）</li>
</ul>
<p>如下在不同浏览器打印的信息</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
chrome:
    Mozilla&#x2F;5.0
    (Macintosh; Intel Mac OS X 10_12_6)
    AppleWebKit&#x2F;537.36 (KHTML, like Gecko)
    Chrome&#x2F;61.0.3163.91 Safari&#x2F;537.36
safari:
    Mozilla&#x2F;5.0
    (Macintosh; Intel Mac OS X 10_12_6)
    AppleWebKit&#x2F;604.1.38 (KHTML, like Gecko) Version&#x2F;11.0
    Safari&#x2F;604.1.38
ios11刘海X:
    Mozilla&#x2F;5.0
    (iPhone; CPU iPhone OS 11_0 like Mac OS X)
    AppleWebKit&#x2F;604.1.38 (KHTML, like Gecko)
    Version&#x2F;11.0 Mobile&#x2F;15A372 Safari&#x2F;604.1
ipad：
    Mozilla&#x2F;5.0
    (iPad; CPU OS 9_1 like Mac OS X)
    AppleWebKit&#x2F;601.1.46 (KHTML, like Gecko)
    Version&#x2F;9.0 Mobile&#x2F;13B143 Safari&#x2F;601.1
galxy sansum:
    Mozilla&#x2F;5.0
    (Linux; Android 5.0; SM-G900P Build&#x2F;LRX21T)
    AppleWebKit&#x2F;537.36 (KHTML, like Gecko)
    Chrome&#x2F;61.0.3163.91 Mobile Safari&#x2F;537.36
安装uc浏览器：
    Mozilla&#x2F;5.0
    (Linux; U; Android 6.0.1; zh-CN; Mi Note 2 Build&#x2F;MXB48T)
    AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Version&#x2F;4.0
    Chrome&#x2F;40.0.2214.89 UCBrowser&#x2F;11.4.9.941 Mobile Safari&#x2F;537.36
winphone:
    Mozilla&#x2F;5.0
    (Linux; Android 5.1.1; Nexus 6 Build&#x2F;LYZ28E)
    AppleWebKit&#x2F;537.36 (KHTML, like Gecko) 
    Chrome&#x2F;61.0.3163.91 Mobile Safari&#x2F;537.36
hybrid方法的可能：
    Mozilla&#x2F;5.0
    (iPhone; CPU iPhone OS 11_0 like Mac OS X)
    AppleWebKit&#x2F;604.1.38 (KHTML, like Gecko)
    Mobile&#x2F;15A372 weibo&#x2F;80011134
*&#x2F;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="十四-ajax与fetch"><a class="markdownIt-Anchor" href="#十四-ajax与fetch">#</a> 十四、ajax 与 fetch</h2>
<h3 id="ajax"><a class="markdownIt-Anchor" href="#ajax">#</a> ajax</h3>
<ul>
<li>ajax 全称 Asynchronous JavaScript And XML 也就是异步 js 与 xml，它可以让页面在不刷新的情况下发起请求获取数据</li>
<li>使用 <code>window.XMLHttpRequest</code>  构造器实例化一个网络请求对象 <code>const XHR = new XMLHttpRequest()</code></li>
<li><code>XHR.open(method, url, [ async, [ user, [ password]]])</code>  此方法用来发送一个请求，method 为请求方法，url 为请求地址，async 为 boolean 值默认为 true 即使用异步请求，user 和 password 在请求需要用户和密码的时候使用</li>
<li><code>XHR.send(body)</code>  参数为发生请求主体内容，其格式可以为 FormData、ArrayBuffer、Document、序列化字符串，在收到响应后，响应的数据会自动填充 XHR 对象的属性</li>
<li>当需要设置请求头时可以调用 <code>XHR.setRequestHeader(header,value)</code>  设置请求头的类型与值，当以 post 方式发起请求就用设置 <code>XHR.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')</code>  此请求头，值可更改</li>
<li>通过监听实例的 onreadystatechange 属性方法，当 readyState 的值改变的时候会触发 onreadystatechange 对应的回调函数 <code>XHR.onreadystatechange = function () &#123; &#125;</code></li>
<li>请求状态 readyState 有 5 个值，对应 5 个请求状态，只读
<ul>
<li>0 表示 请求还未初始化，尚未调用 open () 方法。</li>
<li>1 表示 已建立服务器链接，open () 方法已经被调用。</li>
<li>2 表示 请求已接受，send () 方法已经被调用，并且头部和状态已经可获得。</li>
<li>3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。</li>
<li>4 表示 完成，下载操作已完成。</li>
</ul>
</li>
<li>还有 status 属性，它是这次请求中的响应数字状态码，即为我们平时看到的 1xx、2xx、3xx、4xx、5xx 表示此次请求的状态结果，在还未发起请求和出错时都为 0，只读</li>
<li><code>XHR.responseText</code>  属性为此次响应的数据，为字符串，可能是 JSON 格式需要 JSON.parse 解析</li>
<li><code>XHR.responseXML</code>  属性为 xml 形式的数据，可以通过 <code>XHR.responseType = 'document'</code>  和 <code>XHR.overrideMimeType('text/xml')</code>  来解析为 XML</li>
<li><code>XHR.withCredentials</code>  属性设置为 boolean 值，通过此属性来设置是否使用 cookies、authorization 等凭证字段</li>
<li><code>XHR.timeout</code>  通过此属性来设置请求超时时间</li>
<li><code>XHR.ontimeout</code>  通过此属性来设置请求超时的回调函数，函数的参数为事件对象</li>
<li><code>XHR.abort()</code>  此方法用来终止网络请求</li>
<li><code>XHR.getAllResponseHeaders()</code>  此方法用来获取所有的响应头</li>
<li><code>XHR.getResponseHeader(name)</code>  此方法用来获取指定的响应头</li>
<li>还有 6 个关于进度的事件
<ul>
<li>loadstart 在收到响应的第一个字节触发</li>
<li>progress 在接收期间不断触发</li>
<li>error 发生错误</li>
<li>abort 调用 abort 方法而终止</li>
<li>load 接收到完整数据，可代替 readystatechange 与 readyState 判断</li>
<li>loadend 在通信完成或 abort error load 事件后触发</li>
</ul>
</li>
<li>通过 <code>XHR.addEventListener(eventname,callback)</code>  方法添加对应的事件监听，其回调函数接收一个事件对象参数</li>
<li>progress 事件对象有 3 个属性用于查看当前进度相关信息，lengthComputable 为 boolean 值，表示进度是否可用，position 表示已经接收的字节数，totalSize 表示总需要传输的内容长度即 Content-Length 字节数，通常在分片传输内容的时候用到</li>
</ul>
<p>简单的发起一次请求</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 最简单的发起一个请求
const XHR &#x3D; new XMLHttpRequest()
XHR.open(&#39;get&#39;,&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;test?key&#x3D;value&#39;)
XHR.send()
XHR.addEventListener(&#39;load&#39;,(e)&#x3D;&gt;&#123;
  &#x2F;&#x2F; 服务端返回的是查询参数
  console.log(XHR.response) &#x2F;&#x2F; &#123;&quot;key&quot;:&quot;value&quot;&#125;
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基于 XMLHttpRequest 封装一个请求方法</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 发送的数据
const data &#x3D; &#123;
  name: &#39;tom&#39;
&#125;
&#x2F;&#x2F; 请求配置
const config &#x3D; &#123;
  type: &quot;post&quot;,
  url: &quot;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;test&quot;,
  data: data,
  dataType: &#39;application&#x2F;json&#39;,
  success: function (res) &#123;
    console.log(res);
  &#125;,
  error: function (e) &#123;
    console.log(e);
  &#125;
&#125;
&#x2F;&#x2F; 请求构造器
function Ajax(conf) &#123;
  this.type &#x3D; conf.type || &#39;get&#39;
  this.url &#x3D; conf.url || &#39;&#39;
  this.data &#x3D; conf.data || &#123;&#125;
  this.dataType &#x3D; conf.dataType || &#39;&#39;
  this.success &#x3D; conf.success || null
  this.error &#x3D; conf.error || null
&#125;
&#x2F;&#x2F; send方法
Ajax.prototype.send &#x3D; function () &#123;
  if (this.url &#x3D;&#x3D;&#x3D; &#39;&#39;) return
  const XHR &#x3D; new XMLHttpRequest()
  XHR.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;
    if (XHR.status &gt;&#x3D; 200 &amp;&amp; XHR.status &lt; 300 || XHR.status &#x3D;&#x3D; 304) &#123;
      typeof this.success &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; this.success(XHR.response)
    &#125;
  &#125;)
  XHR.addEventListener(&#39;error&#39;, (e) &#x3D;&gt; &#123;
    typeof this.error &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; this.error(e)
  &#125;)
  if (this.type.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123;
    XHR.open(&#39;get&#39;, this.url)
    XHR.send(null)
  &#125; else &#123;
    XHR.open(this.type, this.url)
    XHR.setRequestHeader(&#39;Content-Type&#39;, this.dataType || &#39;application&#x2F;x-www-form-urlencoded&#39;)
    let data &#x3D; this.data
    if (this.dataType &#x3D;&#x3D;&#x3D; &#39;application&#x2F;json&#39;) &#123;
      data &#x3D; JSON.stringify(this.data)
    &#125;
    XHR.send(data)
  &#125;
&#125;
&#x2F;&#x2F; 发送请求
const ajax &#x3D; new Ajax(config).send()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于网络请求模块封装较繁琐，这里就简单封装了一下，仅供参考（。＾▽＾）</p>
<h3 id="fetch"><a class="markdownIt-Anchor" href="#fetch">#</a> fetch</h3>
<ul>
<li>fetch API 提供了 js 接口，用于替代 XMLHttpRequest 方式的网络请求，fetch () 全局方法使用起来比 XHR 更加方便</li>
<li>fetch 方法接受 2 个参数，参数 1 为请求 url 或 Request 对象，参数 2 为可选配置对象</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; fetch方法返回一个Promise对象，可用then方法接收结果，用catch方法捕获异常，同Promise使用
&#x2F;&#x2F; 配置对象具体配置
const config &#x3D; &#123;
  method: &#39;GET&#39;,      &#x2F;&#x2F; 请求方法
  headers: &#123;          &#x2F;&#x2F; 头信息
    &#39;user-agent&#39;: &#39;Mozilla&#x2F;4.0 MDN Example&#39;,
    &#39;content-type&#39;: &#39;application&#x2F;json&#39;
  &#125;,
  body: JSON.stringify(&#123;  &#x2F;&#x2F; 请求的 body 信息，Blob, FormData 等
    data: 1
  &#125;),
  mode: &#39;cors&#39;,             &#x2F;&#x2F; 请求的模式，cors、 no-cors 或 same-origin
  credentials: &#39;include&#39;,   &#x2F;&#x2F; omit、same-origin 或 include。为了在当前域名内自动发送 cookie, 必须提供这个选项
  cache: &#39;no-cache&#39;,        &#x2F;&#x2F; default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached
  redirect: &#39;follow&#39;,       &#x2F;&#x2F; 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向).
  referrer: &#39;no-referrer&#39;,  &#x2F;&#x2F; no-referrer、client或一个 URL。默认是 client。
  referrerPolicy: &#39;no-referrer&#39;, &#x2F;&#x2F; 指定 referer HTTP头
  integrity: &#39;sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE&#x3D;&#39;, &#x2F;&#x2F; 包括请求的  subresource integrity 值
&#125;
&#x2F;&#x2F; 发起请求
fetch(&#39;http:&#x2F;&#x2F;biadu.com&#39; [, config])
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>then 的回调函数接受一个 Response 对象参数，其对象拥有 9 个属性，8 个方法</p>
</li>
<li>
<p>9 个属性</p>
<ul>
<li>type 只读 包含 Response 的类型 (例如，basic, cors)</li>
<li>url 只读 包含 Response 的 URL</li>
<li>useFinalURL 包含了一个布尔值来标示这是否是该 Response 的最终 URL</li>
<li>status 只读 包含 Response 的状态码</li>
<li>ok 只读 包含了一个布尔值来标示该 Response 成功 (状态码 200-299)</li>
<li>redirected 只读 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个</li>
<li>statusText 只读 包含了与该 Response 状态码一致的状态信息</li>
<li>headers 只读 包含此 Response 所关联的 Headers 对象</li>
<li>bodyUsed Body 只读 包含了一个布尔值来标示该 Response 是否读取过 Body</li>
</ul>
</li>
<li>
<p>8 个方法</p>
<ul>
<li>clone 创建一个 Response 对象的克隆</li>
<li>error 返回一个绑定了网络错误的新的 Response 对象</li>
<li>redirect (url, status) 用另一个 URL 创建一个新的 response</li>
<li>arrayBuffer 接受一个 Response 流，并等待其读取完成。并 resolve 一个 ArrayBuffer 对象</li>
<li>blob blob () 方法使用一个 Response 流，并将其读取完成</li>
<li>formData 将 Response 对象中的所承载的数据流读取并封装成为一个对象</li>
<li>json 使用一个 Response 流，并将其读取完成。解析结果是将文本体解析为 JSON</li>
<li>text 提供了一个可供读取的 &quot;返回流&quot;, 它返回一个包含 USVString 对象，编码为 UTF-8</li>
</ul>
</li>
</ul>
<h2 id="十五-websocket"><a class="markdownIt-Anchor" href="#十五-websocket">#</a> 十五、WebSocket</h2>
<ul>
<li>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，即连接双方可以同时实时收发数据，它可以在用户的浏览器和服务器之间打开双工、双向通讯会话。</li>
<li>WebSocket API 提供全局方法 <code>WebSocket(url[, protocols])</code>  创建实例，参数 1 对方绝对 url 其 url 以 <code>ws://</code>  或者 <code>wss://(加密)</code>  开头，参数 2 protocols 是单协议或者包含协议的字符串数组</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 必须传入绝对URL，可以是任何网站
const s &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;www.baidu.com&#39;) 
s.readyState    &#x2F;&#x2F; 0 建立连接 1 已经建立 2 正在关闭 3 连接已关闭或者没有链接成功
s.send(&#39;hello&#39;) &#x2F;&#x2F; 发送的数据必须是纯文本
s.onopen &#x3D; function () &#123;&#125;
s.onerror &#x3D; function () &#123;&#125;
s.onmessage &#x3D; function (event) &#123;
  &#x2F;&#x2F; 当接收到消息时
  console.log(event.data) &#x2F;&#x2F; 数据是纯字符
&#125;
s.close()   &#x2F;&#x2F; 关闭连接
s.onclose &#x3D; function (event) &#123;
  &#x2F;*
    * event.wasClean 是否明确的关闭 
    * event.code 服务器返回的数值状态码
    * event.reason 字符串，服务器返回的消息
    *&#x2F;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>10 个属性
<ul>
<li>binaryType 返回 websocket 连接所传输二进制数据的类型（blob, arraybuffer）</li>
<li>bufferedAmount 只读 返回已经被 send () 方法放入队列中但还没有被发送到网络中的数据的字节数。一旦队列中的所有数据被发送至网络，则该属性值将被重置为 0。但是，若在发送过程中连接被关闭，则属性值不会重置为 0。</li>
<li>extensions 只读 返回服务器选择的扩展名。这当前只是空字符串或连接协商的扩展列表</li>
<li>onclose 用于指定连接失败后的回调函数</li>
<li>onmessage 用于指定当从服务器接受到信息时的回调函数</li>
<li>onopen 用于指定连接成功后的回调函数</li>
<li>protocol 只读 服务器选择的下属协议</li>
<li>readyState 只读 当前的链接状态，共 4 个
<ul>
<li>0 建立连接</li>
<li>1 已经连接</li>
<li>2 正在关闭</li>
<li>3 连接已经关闭或者没有连接成功</li>
</ul>
</li>
<li>url 只读 WebSocket 的绝对路径</li>
</ul>
</li>
<li>2 个方法
<ul>
<li>close (code, reason) 数字状态码 可选 默认 1005 和一个可选的类可读的字符串，它解释了连接关闭的原因。</li>
<li>send (data) 向服务器发送数据（ArrayBuffer，Blob 等）</li>
</ul>
</li>
</ul>
<h2 id="十六-短轮询-长轮询与websocket"><a class="markdownIt-Anchor" href="#十六-短轮询-长轮询与websocket">#</a> 十六、短轮询、长轮询与 WebSocket</h2>
<h3 id="短轮询"><a class="markdownIt-Anchor" href="#短轮询">#</a> 短轮询</h3>
<ul>
<li>http 短轮询是 server 收到请求不管是否有数据到达都直接响应 http 请求，服务端响应完成，就会关闭这个 TCP 连接；如果浏览器收到的数据为空，则隔一段时间，浏览器又会发送相同的 http 请求到 server 以获取数据响应</li>
<li>缺点：消息交互的实时性较低（server 端到浏览器端的数据反馈效率低）</li>
</ul>
<p>简单演示</p>
<pre class="line-numbers language-none"><code class="language-none">const xhr &#x3D; new XMLHttpRequest()
&#x2F;&#x2F; 每秒发送一次短轮询
const id &#x3D; setInterval(() &#x3D;&gt; &#123;
  xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;test?key&#x3D;value&#39;)
  xhr.addEventListener(&#39;load&#39;, (e) &#x3D;&gt; &#123;
    if (xhr.status &#x3D;&#x3D; 200) &#123;
      &#x2F;&#x2F; 处理数据
      console.log(xhr.response)
      &#x2F;&#x2F; 如果不需要可以关闭
      clearInterval(id)
    &#125;
  &#125;)
  xhr.send()
&#125;, 1000)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="长轮询"><a class="markdownIt-Anchor" href="#长轮询">#</a> 长轮询</h3>
<ul>
<li>http 长轮询是 server 收到请求后如果有数据，立刻响应请求；如果没有数据就会停留一段时间，这段时间内，如果 server 请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应 http 请求；若浏览器收到的数据为空，会再次发送同样的 http 请求到 server</li>
<li>缺点：server 没有数据到达时，http 连接会停留一段时间，这会造成服务器资源浪费</li>
</ul>
<p>简单演示</p>
<pre class="line-numbers language-none"><code class="language-none">function ajax() &#123;
  const xhr &#x3D; new XMLHttpRequest();
  xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;test?key&#x3D;value&#39;);
  xhr.addEventListener(&#39;load&#39;, (e) &#x3D;&gt; &#123;
    if (xhr.status &#x3D;&#x3D; 200) &#123;
      &#x2F;&#x2F; 处理数据
      console.log(xhr.response)
      &#x2F;&#x2F; 如果不需要可以关闭
      if (xhr.response !&#x3D; &#39;&#39;) return
      ajax()
    &#125;
  &#125;)
  xhr.send();
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="相同点"><a class="markdownIt-Anchor" href="#相同点">#</a> 相同点</h3>
<ul>
<li>当 server 的数据不可达时，基于 http 长轮询和短轮询的 http 请求，都会停留一段时间</li>
<li>都是用于实时从服务器获取数据更新</li>
</ul>
<h3 id="不同点"><a class="markdownIt-Anchor" href="#不同点">#</a> 不同点</h3>
<ul>
<li>http 长轮询是在服务器端的停留，而 http 短轮询是在浏览器端的停留</li>
<li>短轮询隔一段时间向服务器发起请求，不管服务器数据有没有变化都直接返回结果，长轮询则在服务器数据有发生变化的时候才返回结果，如果在一定时间没有变化那么将会超时自动关闭连接</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d557898dae06~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<h3 id="web-socket"><a class="markdownIt-Anchor" href="#web-socket">#</a> Web Socket</h3>
<ul>
<li>为了解决 http 无状态，被动性，以及轮询问题，html5 新推出了 websocket 协议，浏览器和服务器只需完成一次握手，两者即可建立持久性连接，并进行双向通信</li>
<li>基于 http 进行握手，发生加密数据，保持连接不断开</li>
<li>优点：
<ul>
<li>较少的控制开销，在进行客户端与服务器的数据交换时，用于协议控制的数据包头较小</li>
<li>更强的实时性，全双工通信，不必局限于一方发起的请求，服务器与客户端可以随时发送数据，延迟更少</li>
<li>有状态的连接，websocket 在通信之前需要双方建立连接，才能进行通信，而 http 协议在每次请求都要携带状态信息</li>
<li>基于二进制数据传输，websocket 定义了二进制帧，可以处理二进制内容，相比于文本传输，提高了效率</li>
<li>支持自定义子协议，可以自行扩展协议，如部分浏览器支持压缩等</li>
<li>更好的压缩效果，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
</li>
</ul>
<h2 id="十七-长连接与短连接"><a class="markdownIt-Anchor" href="#十七-长连接与短连接">#</a> 十七、长连接与短连接</h2>
<h3 id="短连接"><a class="markdownIt-Anchor" href="#短连接">#</a> 短连接</h3>
<ul>
<li>HTTP/1.0 中默认使用短连接，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接</li>
<li>当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话</li>
<li>短连接的操作步骤是：建立连接 —— 数据传输 —— 关闭连接… 建立连接 —— 数据传输 —— 关闭连接</li>
<li>像 WEB 网站的 http 服务一般都用短连接，并发量大，但每个用户无需频繁操作情况下需用短连接</li>
</ul>
<h3 id="长连接"><a class="markdownIt-Anchor" href="#长连接">#</a> 长连接</h3>
<ul>
<li>从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码 <code>Connection:keep-alive</code></li>
<li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接</li>
<li>keep-alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接</li>
<li>长连接的操作步骤是：建立连接 —— 数据传输…（保持连接）… 数据传输 —— 关闭连接</li>
<li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
<h3 id="长短轮询和长短连接区别"><a class="markdownIt-Anchor" href="#长短轮询和长短连接区别">#</a> 长短轮询和长短连接区别</h3>
<ul>
<li>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接</li>
<li>长短连接通过双方请求响应头是否设置 <code>Connection:keep-alive</code>  来决定使用，而是否轮询，是根据服务端的处理方式来决定的，与客户端没有关系</li>
<li>实现方式不同，长短连接通过协议来实现，而长短轮询通过服务器编程手动实现</li>
</ul>
<h2 id="十八-存储"><a class="markdownIt-Anchor" href="#十八-存储">#</a> 十八、存储</h2>
<h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie">#</a> Cookie</h3>
<ul>
<li key：value="">cookie 是由服务器发送给客户端用于存储少量信息，以键值对形式存储</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d55c683250a9%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>客户端请求服务器时，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。而客户端浏览器会把 Cookie 保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器通过检查该 Cookie 来获取用户状态</li>
<li>cookie 是不可跨域，但是只在域名不同的情况下不支持跨域，忽略协议与端口， <code>https://localhost:80/</code>  和 <code>http://localhost:8080/</code>  的 Cookie 是共享的，可以通过 domain 设置域，path 设置域下的共享路径</li>
<li>cookie 属性
<ul>
<li>name 表示设置的 cookie 名也就是 key，不能重复，不可更改</li>
<li>value 表示设置 cookie 的值</li>
<li>domain 表示 cookie 绑定的域名，默认绑定当前域，多级域名不可交换 cookie，如果设置以点开头的域名，则所有子域名可以访问，如设置 <code>.baidu.com</code> ，则 <code>a.baidu.com</code>  可访问其上级域名的 cookie</li>
<li>path 表示 cookie 所能使用的路径，默认’/' 路径，只要满足当前匹配路径以及子路径都可以共享 cookie</li>
<li>maxAge 表示 cookie 失效时间，单位秒，正数为失效时间，负数表示当前 cookie 在浏览器关闭时失效，0 表示删除 cookie</li>
<li>secure 表示 cookie 是否使用安全协议传输如 HTTPS、SSL，默认不使用，只在 HTTPS 等安全协议下有效，这个属性并不能对客户端的 cookie 进行加密，不能保证绝对的安全性</li>
<li>version 当前 cookie 使用的版本号，0 表示遵循 Netscape 的 Cookie 规范 (多数)，1 表示遵循 W3C 的 RFC2109 规范 (较严格)，默认为 0</li>
<li>same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</li>
<li>HttpOnly 如果这个属性设置为 true，就不能通过 js 脚本来获取 cookie 的值，用来限制非 HTTP 协议程序接口对客户端 Cookie 进行访问，可以有效防止 XSS 攻击 (跨站脚本攻击，代码注入攻击)</li>
</ul>
</li>
<li>前端通过 document.cookie 对 cookie 进行读写操作</li>
<li>创建 cookie 就是后端的事情了</li>
</ul>
<h3 id="session"><a class="markdownIt-Anchor" href="#session">#</a> Session</h3>
<ul>
<li>session 表示服务器与客户端的一次会话过程，session 对象存储特定用户的属性及配置信息</li>
<li>当用户在应用程序的 Web 页之间跳转时，存储在 session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 session 超时失效时会话结束</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d5619add7922~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 session ，请求返回时将此 session 的唯一标识信息 sessionID 返回给浏览器，浏览器接收到服务器返回的 sessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 sessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 sessionID，再根据 sessionID 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作</li>
<li>session 的运行依赖 session id，而 session id 是存在 Cookie 中的</li>
</ul>
<h3 id="cookie与session的区别"><a class="markdownIt-Anchor" href="#cookie与session的区别">#</a> cookie 与 session 的区别</h3>
<ul>
<li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上</li>
<li>cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。用户验证这种场合一般会用 session</li>
<li>session 保存在服务器，客户端不知道其中的信息；反之，cookie 保存在客户端，服务器能够知道其中的信息</li>
<li>session 会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie</li>
<li>session 中保存的是对象，cookie 中保存的是字符串</li>
<li>session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到，而 cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的</li>
<li>session: 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li>
<li>cookie: 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 session 的一种方式</li>
</ul>
<h3 id="本地存储localstorage与sessionstorage"><a class="markdownIt-Anchor" href="#本地存储localstorage与sessionstorage">#</a> 本地存储 localStorage 与 sessionStorage</h3>
<h4 id="localstorage"><a class="markdownIt-Anchor" href="#localstorage">#</a> localStorage</h4>
<ul>
<li>localStorage 浏览器 api，用于存储本地数据，可持久化，永不过期，除非主动删除</li>
</ul>
<p>基本使用</p>
<pre class="line-numbers language-none"><code class="language-none">localStorage.setItem(&quot;b&quot;, &quot;isaac&quot;);  &#x2F;&#x2F;设置b为&quot;isaac&quot;
localStorage.getItem(&quot;b&quot;);           &#x2F;&#x2F;获取b的值,为&quot;isaac&quot;
localStorage.key(0);                 &#x2F;&#x2F;获取第0个数据项的键名，此处即为“b”
localStorage.removeItem(&quot;b&quot;);        &#x2F;&#x2F;清除c的值
localStorage.clear();                &#x2F;&#x2F;清除当前域名下的所有localStorage数据
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取 / 修改到同一份 localStorage 数据，一般用于跨页面共享数据</li>
<li>可通过 <code>window.addEventListener(&quot;storage&quot;, function(e)&#123;&#125;</code>  设置 localStorage 事件监听，当存储区域的内容发生改变时，将会调用回调</li>
</ul>
<h4 id="sessionstorage"><a class="markdownIt-Anchor" href="#sessionstorage">#</a> sessionStorage</h4>
<ul>
<li>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">sessionStorage.setItem(name, num);    &#x2F;&#x2F;存储数据
sessionStorage.setItem(&#39;value2&#39;, 119);
sessionStorage.valueOf();             &#x2F;&#x2F;获取全部数据
sessionStorage.getItem(name);         &#x2F;&#x2F;获取指定键名数据
sessionStorage.sessionData;           &#x2F;&#x2F;sessionStorage是js对象，也可以使用key的方式来获取值
sessionStorage.removeItem(name);      &#x2F;&#x2F;删除指定键名数据
sessionStorage.clear();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>使用方式与 localStorage 类似</li>
<li>仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li>
<li>主要用于存储当前页面独有的数据，不与浏览器其他页面共享</li>
</ul>
<h4 id="区别"><a class="markdownIt-Anchor" href="#区别">#</a> 区别</h4>
<ul>
<li>数据存储方面
<ul>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下</li>
<li>sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。</li>
</ul>
</li>
<li>存储数据大小
<ul>
<li>存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li>
</ul>
</li>
<li>数据存储有效期
<ul>
<li>sessionStorage：仅在当前浏览器窗口关闭之前有效； localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</li>
<li>cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭</li>
</ul>
</li>
<li>作用域不同
<ul>
<li>sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li>localStorage 在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</li>
<li>cookie: 也是在所有同源窗口中都是共享的。也就是说只要浏览器不关闭，数据仍然存在</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d566c4dee532%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<h2 id="十九-跨域"><a class="markdownIt-Anchor" href="#十九-跨域">#</a> 十九、跨域</h2>
<h3 id="jsonp"><a class="markdownIt-Anchor" href="#jsonp">#</a> jsonp</h3>
<ul>
<li>jsonp 是一种跨域通信手段，通过 script 标签的 src 属性实现跨域，由于浏览器同源策略，并不会截断 script 的跨域响应</li>
<li>通过将前端方法名作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信</li>
<li>由于使用 script 标签的 src 属性，因此只支持 get 方法</li>
</ul>
<p>来实现一下吧</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 前端准备
&#x2F;&#x2F; 定义回调函数
function fn(arg) &#123;
  &#x2F;&#x2F; arg为服务端传来的数据
  console.log(&#96;客户端获取的数据：$&#123;arg&#125;&#96;)
&#125;
&#x2F;&#x2F; 创建script标签
const s &#x3D; document.createElement(&#39;script&#39;)
&#x2F;&#x2F; 给script标签的src属性赋值，值为请求url，查询参数callback，需与后端对应
&#x2F;&#x2F; fn为前端回调函数名
s.src &#x3D; &#96;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;test?callback&#x3D;fn&#96;
&#x2F;&#x2F; 向html添加此标签，添加完成之后浏览器自动请求script的src对应的网址
document.getElementsByTagName(&#39;head&#39;)[0].appendChild(s);
&#x2F;&#x2F; 等待浏览器收到响应之后，将会自动执行响应内容的代码
----------------------------------------------
&#x2F;&#x2F; 后端准备
&#x2F;&#x2F; nestjs(ts)处理
@Controller(&#39;test&#39;) &#x2F;&#x2F;api
export class TestController &#123;
  @Get() &#x2F;&#x2F;get方式请求
  &#x2F;&#x2F;取url中的查询参数，即?之后的键值对，键与值对应query对象参数的键与值
  callback(@Query() query) &#123;  
    &#x2F;&#x2F; 返回的数据
    const data &#x3D; &#39;我是服务端返回的数据&#39;;
    &#x2F;&#x2F; 取查询参数，这里的callback要与前端?之后的键名一致，fn即fn函数名
    const fn &#x3D; query.callback;
    &#x2F;&#x2F; 返回结果，格式：函数名(服务器的数据)，注意这里需要序列化成字符串，如果参数本身是字符串那么要加引号，前端并不知道data是字符串
    return &#96;$&#123;fn&#125;(&#39;$&#123;data&#125;&#39;)&#96;;
  &#125;
&#125;

&#x2F;&#x2F; express(js)处理，同上
router.get(&#39;&#x2F;test&#39;, async (req, res) &#x3D;&gt; &#123;
  const data &#x3D; &#39;我是服务器返回的数据&#39;
  &#x2F;&#x2F; req.query为查询参数列表
  const fn &#x3D; req.query.callback
  &#x2F;&#x2F; 返回数据
  res.send(&#96;$&#123;fn&#125;(&#39;$&#123;data&#125;&#39;)&#96;)
&#125;)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>响应内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d571d31cb770%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<h3 id="cors"><a class="markdownIt-Anchor" href="#cors">#</a> CORS</h3>
<ul>
<li>跨域资源共享 cors，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源</li>
<li>需要服务端与客户端同时支持 cors 跨域方式才能进行跨域请求，服务端通过设置 <code>Access-Control-Allow-Origin:*</code>  即可开启 cors 允许跨域请求，使用通配符 * 表示允许所有不同域的源访问资源，也可单独设置指定允许的源域名</li>
<li>使用 cors 跨域时，将会在发起请求时出现 2 种情况：</li>
<li>简单请求，需满足以下条件
<ul>
<li>使用 get、head、post 方式发起的请求</li>
<li>Content-Type 的值仅限于下列三者之一：
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
</li>
<li>不满足这些条件即为预检请求</li>
</ul>
</li>
<li>预检请求
<ul>
<li>需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求</li>
<li>预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响</li>
<li>当满足以下条件之一，将会发送预检请求
<ul>
<li>使用了下面任一 HTTP 方法：</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (需要注意额外的限制)</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li>Content-Type 的值不属于下列之一:
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li>满足以上条件之一将会发起预检请求，总共会发起 2 次请求，第一次为 OPTIONS 方式的请求，用来确定服务器是否支持跨域，如果支持，再发起第二次实际请求，否则不发送第二次请求</li>
</ul>
</li>
</ul>
<h3 id="postmessage"><a class="markdownIt-Anchor" href="#postmessage">#</a> postMessage</h3>
<ul>
<li>postMessage 可用于不同页面之间的跨域传递数据</li>
<li><code>postMessage(data,origin[, source])</code>  data 为发送的数据只能发送字符串信息，origin 发送目标源，指定哪些窗口能接收到消息事件，如果 origin 设置为 * 则表示无限制，source 为发送消息窗口的 window 对象引用，</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&lt;!-- test.html --&gt;
&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5501&#x2F;postMessage.html&quot;
name&#x3D;&quot;postIframe&quot; onload&#x3D;&quot;messageLoad()&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;script&gt;
&#x2F;&#x2F; 定义加载之后执行的函数，给postMessage.html发送数据
function messageLoad() &#123;
  const url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#x2F;postMessage.html&#39;
  window.postIframe.postMessage(&#39;给postMessage的数据&#39;, url)
&#125;
&#x2F;&#x2F; 用于监听postMessage.html的回馈，执行回调
window.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;
  console.log(event.data);
&#125;)
&lt;&#x2F;script&gt;
----------------------------------------------
&lt;!-- postMessage.html --&gt;
&lt;script&gt;
  &#x2F;&#x2F; 监听test.html发来的数据，延迟1秒返回数据
  window.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;
    setTimeout(() &#x3D;&gt; &#123;
      event.source.postMessage(&#39;给test的数据&#39;, event.origin)
    &#125;,1000)
  &#125;)
&lt;&#x2F;script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>event 对象的几个重要属性
<ul>
<li>data 指的是从其他窗口发送过来的消息对象</li>
<li>type 指的是发送消息的类型</li>
<li>source 指的是发送消息的窗口对象</li>
<li>origin 指的是发送消息的窗口的源</li>
</ul>
</li>
</ul>
<h3 id="windowname"><a class="markdownIt-Anchor" href="#windowname">#</a> <a target="_blank" rel="noopener" href="http://window.name">window.name</a></h3>
<ul>
<li>由于 <code>window.name</code>  属于全局属性，在 html 中的 iframe 加载新页面 (可以是跨域)，通过 iframe 设置的 src 指向的源中更改 name 的值，同时主页面中的 name 也随之更改，但是需要给 iframe 中的 window 设置为 <code>about:blank</code>  或者同源页面即可</li>
<li>iframe 使用之后应该删除，name 的值只能为 string 类型，且数据量最大支持 2MB</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&lt;!-- test.html --&gt;
&#x2F;&#x2F; 封装应该用于获取数据的函数
function foo(url, func) &#123;
  let isFirst &#x3D; true
  const ifr &#x3D; document.createElement(&#39;iframe&#39;)
  loadFunc &#x3D; () &#x3D;&gt; &#123;
    if (isFirst) &#123;
      &#x2F;&#x2F; 设置为同源
      ifr.contentWindow.location &#x3D; &#39;about:blank&#39;
      isFirst &#x3D; false
    &#125; else &#123;
      func(ifr.contentWindow.name)
      ifr.contentWindow.close()
      document.body.removeChild(ifr)
    &#125;
  &#125;
  ifr.src &#x3D; url
  ifr.style.display &#x3D; &#39;none&#39;
  document.body.appendChild(ifr)
  &#x2F;&#x2F; 加载之后的回调
  ifr.onload &#x3D; loadFunc
&#125;
foo(&#96;http:&#x2F;&#x2F;127.0.0.1:5501&#x2F;name.html&#96;, (data) &#x3D;&gt; &#123;
  console.log(data) &#x2F;&#x2F;
&#125;)
----------------------------------------------
&lt;!-- name.html --&gt;
const obj &#x3D; &#123; name: &quot;iframe&quot; &#125;
&#x2F;&#x2F; 修改name的值，必须为string类型
window.name &#x3D; JSON.stringify(obj);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="documentdomain"><a class="markdownIt-Anchor" href="#documentdomain">#</a> document.domain</h3>
<ul>
<li><code>document.domain</code>  的值对应当前页面的域名</li>
<li>通过对 domain 设置当前域名来实现跨域，不过仅限于域名不同，但是又要属于同一个基础域名下，如 <code>http://a.baidu.com</code>  与 <code>http://b.baidu.com</code>  这 2 个子域名之间才能使用 domain 跨域，一般用于子域名之间的跨域访问</li>
<li>domain 只能赋值为当前域名或者其基础域名，即上级域名</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&lt;!-- test.html --&gt;
&lt;script&gt;
document.domain &#x3D; &#39;baidu.com&#39;;
const ifr &#x3D; document.createElement(&#39;iframe&#39;);
ifr.src &#x3D; &#39;a.baidu.com&#x2F;test.html&#39;;
ifr.style.display &#x3D; &#39;none&#39;;
document.body.appendChild(ifr);
ifr.onload &#x3D; function()&#123;
  var doc &#x3D; ifr.contentDocument || ifr.contentWindow.document;
  &#x2F;&#x2F; 此处即可操作domain.html的document
  ifr.onload &#x3D; null;
&#125;;
&lt;&#x2F;script&gt;
----------------------------------------------
&lt;!-- domain.html --&gt;
&lt;script&gt;
  &#x2F;&#x2F; domain.html下设置为与test.html中的domain一致
  document.domain &#x3D; &#39;baidu.com&#39;;
&lt;&#x2F;script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>主要就是通过设置为同源域名 (只能为其基础域名)，通过 iframe 操作另一个页面的内容</li>
</ul>
<h3 id="nginx反向代理"><a class="markdownIt-Anchor" href="#nginx反向代理">#</a> nginx 反向代理</h3>
<ul>
<li>nginx 反向代理，代理从客户端来的请求，转发到其代理源</li>
<li>通过配置 nginx 的配置文件实现代理到不同源</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nginx.conf配置
server &#123;
  listen 80;  &#x2F;&#x2F; 监听端口
  server_name  www.baidu.com; &#x2F;&#x2F; 匹配来源
  location &#x2F; &#123;  &#x2F;&#x2F;匹配路径
    &#x2F;&#x2F; 反向代理到http:&#x2F;&#x2F;127.0.0.1:3000
    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000;
    &#x2F;&#x2F; 默认入口文件
    index  index.html index.htm index.jsp;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>nginx 反向代理还能实现负载均衡</li>
</ul>
<h2 id="二十-settimeout与setinterval"><a class="markdownIt-Anchor" href="#二十-settimeout与setinterval">#</a> 二十、setTimeout 与 setInterval</h2>
<h3 id="settimeout"><a class="markdownIt-Anchor" href="#settimeout">#</a> setTimeout</h3>
<ul>
<li>setTimeout 属于 webApi 的一部分，可以实现延时调用，属于异步宏任务，一次性使用</li>
<li><code>setTimeout(func|code, [delay], [arg1], [arg2], ...)</code>  参数 1 为想要执行的函数或代码字符串，参数 2 为延迟执行时间，单位毫秒默认 0，参数 3 及之后的参数为参数 1 为函数时传入的参数，调用之后会返回一个定时器 id</li>
<li>此方法只执行一次，可以使用 <code>clearTimeout(id)</code>  清除定时器来取消回调</li>
<li>看一下 setTimeout 的延迟执行机制</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d57a515531c0~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>以上使用嵌套 setTimeout 来实现循环调用，可以从中看出 setTimeout 计时是从上一个 setTimeout 回调执行之后开始的，看看代码效果</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/21/1719d57d50d46306~tplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>上图计算的是 2 次调用回调之间的间隔，不包括回调执行时间，可以看出在开启定时器之后到执行回调的时间确实是参数 2 所设置的值，延迟时间与回调函数执行时间无关；</li>
<li>简单来讲 setTimeout 的延迟时间不包括自身回调所占用的时间</li>
</ul>
<p>也就是说 setTimeout 是在上一次回调执行之后才开启的定时</p>
<h3 id="setinterval"><a class="markdownIt-Anchor" href="#setinterval">#</a> setInterval</h3>
<ul>
<li>setInterval 同样也是 webApi 的一部分，主要用来定时循环执行代码</li>
<li>不同于 setTimeout，此定时器的延迟执行机制有所不同</li>
<li><code>setInterval(func|code, [delay], [arg1], [arg2], ...)</code> ，参数列表同 setTimeout，参数 2 为每次循环时间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d5823cbd8652%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>从上图可以先得出结论，setInterval 的延迟执行时间包含自身回调执行所占用的时间，看看代码效果</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d586296026d8%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>上图计算的是 2 次调用回调之间的间隔，不包括回调执行时间，可以看出 setInterval 在 2 次执行之间的延迟受到了回调的影响，再验证一下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d58a248e5cd3%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>此次我把回调执行时间也算在计时之内，现在看来 setInterval 的定时时间确实包含了自身回调所占用的时间</li>
</ul>
<p>由于这 2 个 api 都属于异步宏任务，在执行的时候都会进入任务队列，如果队列前的任务执行时间较长，那么也会影响到定时器的执行时机</p>
<p>在浏览器中 alert、confirm、prompt 都会阻塞 js 主线程执行，直到弹窗消失，但是定时器还会继续执行；定时器并不能达到 0 延迟，最小延迟限制在 4ms</p>
<h2 id="二十一-requestanimationframe"><a class="markdownIt-Anchor" href="#二十一-requestanimationframe">#</a> 二十一、requestAnimationFrame</h2>
<ul>
<li>在 requestAnimationFrame 还未出来之前，大多数使用定时器完成 js 动画，但是由于定时器不准确，而且每次更新动画的时候不能保证与浏览器渲染同步，这样将会导致画面的不流畅</li>
<li>由于目前主流屏幕的固定刷新频率一般为 60HZ 即一秒 60 帧，每次刷新间隔为 1000/60ms，为了使浏览器得到最好的渲染效果，浏览器每次渲染应该与屏幕刷新率保持一致，那么对于 js 动画而言，最好的更新时机应该与浏览器尽量保持一致</li>
<li>当每次浏览器将要重绘之前，把要执行更新的动画更新完成，那么当浏览器渲染的时候将会保持最新的动画，这就是 requestAnimationFrame 所做的事情</li>
<li><code>requestAnimationFrame(callback)</code>  的参数就是每次渲染前需要执行的动画更新函数，当浏览器将要重绘画面时就会执行这个回调函数，这个回调函数接受一个参数，即从当前页面加载之后到现在所经过的毫秒数</li>
<li>此 api 将会与浏览器渲染同步，即浏览器渲染几次这个 api 将会执行几次，那么就达到了不掉帧的效果，画面效果就更加流程</li>
<li>requestAnimationFrame 执行时机在事件循环机制中处于微任务队列之后，浏览器渲染之前，浏览器渲染之后就会进入下一次的事件循环 (宏任务开始，浏览器渲染结束)</li>
<li>如果使用定时器进行 js 动画操作，那么首先将会导致动画更新与浏览器每次重绘时机不匹配，造成卡顿，其次过于频繁的更新动画还会导致不必要的性能开销，且并非能够达到更好的效果</li>
<li>简单说使用 requestAnimationFrame 更新的动画与浏览器保持同步，不会掉帧，除非浏览器掉帧或者，js 主线程阻塞导致浏览器无法正常渲染，使用定时器更新动画，如果频率高了会影响性能，且达不到更好的效果，如果频率低了将会有不连贯的感觉</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d58f7ddf9656%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>从上图可以看出确实是每帧执行一次，不过要注意，调用一次 requestAnimationFrame 只会执行一次，如果需要持续执行需要在回调函数内继续调用</li>
</ul>
<h2 id="二十二-事件"><a class="markdownIt-Anchor" href="#二十二-事件">#</a> 二十二、事件</h2>
<h3 id="dom0事件"><a class="markdownIt-Anchor" href="#dom0事件">#</a> DOM0 事件</h3>
<ul>
<li>DOM0 事件并非 w3c 标准，在 DOM 标准形成之前的事件模型就是我们所说的 0 级 DOM</li>
<li>添加 DOM0 事件，都是把一个函数赋值给文档元素，在事件监听函数被调用时，将会做为产生事件的元素方法调用，所以 this 指向目标元素，简单说就是直接把回调函数作为文档元素的一个方法调用</li>
<li>删除 DOM0 事件只需把事件赋值为 null 即可</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">document.getElementById(&quot;btn&quot;).onclick &#x3D; function () &#123;&#125;
----------------------------------------------
&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;alert(&#39;hi!&#39;);&quot;&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果回调方法返回一个 false 则会阻止浏览器事件的默认行为</li>
<li>DOM0 事件在事件捕获阶段，无法接收事件，即没无法触发事件捕获，但是能够正常触发冒泡</li>
<li>由于 DOM0 事件的回调属于文档元素的方法，导致无法添加多个同名事件，不过看来兼容性最好</li>
</ul>
<h3 id="dom2事件"><a class="markdownIt-Anchor" href="#dom2事件">#</a> DOM2 事件</h3>
<ul>
<li>由于 w3c 推出的 1 级 DOM 标准中并没有定义事件相关的内容，所以没有所谓的 1 级 DOM 事件模型</li>
<li>在 2 级 DOM 中除了定义了一些 DOM 相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的 2 级 DOM 事件模型</li>
<li>2 级 DOM 定义了事件传播，在事件传播过程中将会经历 3 个阶段：
<ol>
<li>capturing 阶段，即事件捕获阶段，在某个 DOM 上触发事件时，事件会先从 Document 对象 沿着 dom 数向下传递直到触发节点，此过程就是事件捕获阶段，在此过程中可以捕获传播的事件</li>
<li>目标元素的事件处理阶段，此阶段事件到达触发目标，调用回调处理事件</li>
<li>bubbling 阶段，即事件冒泡阶段，在目标元素处理完成之后，此事件还会向上冒泡，回传到 Document，此阶段与捕获阶段相反</li>
</ol>
</li>
<li>以上就是事件在触发之后的传播过程，可以配合下图理解</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/1719d595e0ad539a%7Etplv-t2oaga2asx-watermark.awebp" alt=""></p>
<ul>
<li>DOM2 注册事件，可以通过 <code>addEventListener(eventName,callback,isCapturing)</code>  方法为元素设置事件监听器，参数 1 为注册事件名不带 on 开头的 string 类型，参数 2 为触发事件的回调函数，接受一个事件对象参数，参数 3 为是否在捕获阶段触发，默认为 false</li>
<li>通过 <code>removeEventListener(eventName,callback,isCapturing)</code>  方法移除指定事件名、回调、是否捕获的事件，匿名回调无法删除</li>
<li>可给一个元素添加多个相同的事件，通过不同的回调实现不同效果</li>
<li>DOM2 中的回调函数中的 this 指向，由浏览器决定，w3c 标准中并未规定其指向，一般情况 this 指向 window</li>
<li>回调函数 event 对象参数</li>
<li>属性
<ul>
<li>type 发生事件的类型</li>
<li>target 发生事件的阶段，为触发事件的对象，可以与 currentTarget 不同</li>
<li>currentTarget 正在处理事件的节点，即注册此回调函数的元素</li>
<li>clientX，clientY 鼠标相对浏览器的 x 坐标与 y 坐标</li>
<li>screenX，screenY 鼠标相对于显示器左上角 x，y 坐标</li>
</ul>
</li>
<li>方法
<ul>
<li>stopPropagation () 阻止当前事件的进一步传播</li>
<li>preventDefault () 阻止浏览器执行与世界相关的默认动作，与 DOM0 返回 false 相同</li>
</ul>
</li>
<li>触发时机
<ul>
<li>document 往 target 节点传播，捕获前进，遇到注册的捕获事件立即触发执行</li>
<li>到达 target 节点，触发事件（对于 target 节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）</li>
<li>target 节点 往 document 方向传播，冒泡前进，遇到注册的冒泡事件立即触发</li>
</ul>
</li>
</ul>
<h3 id="事件代理"><a class="markdownIt-Anchor" href="#事件代理">#</a> 事件代理</h3>
<ul>
<li>事件代理又或是事件委托，通过事件冒泡机制，使用单一父节点来操作多个子节点的响应，简单讲就是把所有子节点的事件去除，只给父节点注册事件，那么就可以通过事件冒泡机制来处理子节点的响应</li>
<li>基于事件委托可以减少事件注册，节省内存，简化 dom 节点于事件的更新</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&lt;ul id&#x3D;&quot;f&quot;&gt;
  &lt;li&gt;a&lt;&#x2F;li&gt;
  &lt;li&gt;b&lt;&#x2F;li&gt;
  &lt;li&gt;c&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;script&gt;
  const ul &#x3D; document.querySelector(&#39;#f&#39;)
  &#x2F;&#x2F; 点击li时触发事件委托
  ul.addEventListener(&#39;click&#39;,function foo(event)&#123;
    &#x2F;&#x2F; 处理元素为父元素
    console.dir(event.currentTarget)  &#x2F;&#x2F; ul#f
    &#x2F;&#x2F; 触发元素为子元素，event.target为具体触发对象
    console.dir(event.target)         &#x2F;&#x2F; li
  &#125;)
&#x2F;&#x2F;--------------------------------------------
  &#x2F;&#x2F; 通过点击添加子元素
  ul.addEventListener(&#39;click&#39;,function foo(event)&#123;
    const child &#x3D; document.createElement(&#39;li&#39;)
    child.innerText &#x3D; &#39;我是新增的子元素&#39;
    event.currentTarget.appendChild(child)
  &#125;)
&#x2F;&#x2F;--------------------------------------------
  &#x2F;&#x2F; 通过点击删除子元素
  ul.addEventListener(&#39;click&#39;,function foo(event)&#123;
    event.currentTarget.removeChild(event.target)
  &#125;)
&lt;&#x2F;script&gt;
----------------------------------------------
&lt;!-- 如果点击span 想知道是哪个li下面的元素 --&gt;
&lt;ul id&#x3D;&quot;f&quot;&gt;
  &lt;li&gt;a&lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;span&gt;b&lt;&#x2F;span&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;span&gt;c&lt;&#x2F;span&gt;
  &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;script&gt;
  const ul &#x3D; document.querySelector(&#39;#f&#39;)
  ul.addEventListener(&#39;click&#39;, function foo(event) &#123;
    let target &#x3D; event.target
    &#x2F;&#x2F; 一级级向上寻找直到找到满足条件的元素
    while (target.nodeName.toLowerCase() !&#x3D;&#x3D; &#39;li&#39;) &#123;
      target.target.parentNode
    &#125;
    console.dir(target) &#x2F;&#x2F; li
    console.dir(target.parentNode &#x3D;&#x3D;&#x3D; event.currentTarget) &#x2F;&#x2F;true
  &#125;)
&lt;&#x2F;script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>以上就是几个简单的事件代理的例子，事件代理能够在我们平时开发中减少很多不必要的代码，优化事件系统，但是在使用的过程也要注意相应的问题</li>
<li>事件代理基于冒泡机制，如果代理层级过多，且在冒泡阶段如果被某层阻止冒泡那么父级将不会收到事件</li>
<li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理，所以建议就近委托</li>
<li>如果事件代理了许多情况那么要做好完善逻辑分析，避免一些误判的情况</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2>
<p>以上总结可能没有什么顺序，但是每章节都是针对性的讲解，零散的知识点较多，希望看完这篇文章能扩展你的知识面，也许某方面讲的不是很详细，如果感兴趣可以找些针对性的文章进行深入了解。</p>
<p>部分内容并非原创，还是要感谢前辈的总结，如果本文影响到您的利益，那么还请事先告知，在写本文时的初衷就是想给更多学习前端的小伙伴拓展知识，夯实基础，共同进步，也为了以后方便复习使用</p>
<p>总结不易，如需转载请注明出处，感谢！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Harry Qu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://harryqu1229.github.io/2022/01/13/js%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93/">https://harryqu1229.github.io/2022/01/13/js%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/frontend/">frontend</a><a class="post-meta__tags" href="/tags/interview/">interview</a><a class="post-meta__tags" href="/tags/javascript/">javascript</a><a class="post-meta__tags" href="/tags/summary/">summary</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-621848f44e1c3724" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/CSS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-YK%E8%8F%8C/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/house.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">css Interview Questions</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/14/%E8%AF%AD%E6%B3%95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Mysql commands</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/12/08/js%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="Javascript Interview Summary"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/cat.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Javascript Interview Summary</div></div></a></div><div><a href="/2022/02/25/JS%E9%9D%A2%E8%AF%95%E9%A2%98--YK%E8%8F%8C/" title="some JS Frontend Interview Quesitions"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-25</div><div class="title">some JS Frontend Interview Quesitions</div></div></a></div><div><a href="/2022/01/12/css%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="css Interview Summary"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/cat.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">css Interview Summary</div></div></a></div><div><a href="/2022/01/12/html%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="HTML Interview Summary"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/code.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">HTML Interview Summary</div></div></a></div><div><a href="/2022/02/21/js,css%E7%AD%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="css and JS Frontend Interview Quesitions"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/hello-world.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">css and JS Frontend Interview Quesitions</div></div></a></div><div><a href="/2022/01/01/20%E9%81%93%E5%A4%A7%E5%8E%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="20 Frontend Interview Quesitions"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/car.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-01</div><div class="title">20 Frontend Interview Quesitions</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Disqus</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Harry Qu</div><div class="author-info__description">Software Engineering Student</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">158</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">57</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HarryQu1229"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.linkedin.com/in/harry-qu-a0a38220a" target="_blank" title="LinkedIn"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://github.com/HarryQu1229" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Harryqu666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="weixin://dl/chat?harry666ya" target="_blank" title="Wechat"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">be healthy, stay safe</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E4%B8%87%E5%AD%97js%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB%E5%B8%A6%E4%BD%A0%E9%A2%86%E7%95%A5%E5%89%8D%E7%AB%AF%E9%AD%85%E5%8A%9B"><span class="toc-number">1.</span> <span class="toc-text"> 2.6 万字 JS 干货分享，带你领略前端魅力！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 个人技术文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text"> 目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text"> 一、变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text"> &#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 对于 &#x3D;&#x3D; 的判断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%83%85%E5%86%B5"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text"> 比较情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%9A%84%E5%88%A4%E6%96%AD-2"><span class="toc-number">1.3.1.2.</span> <span class="toc-text"> 对于 &#x3D;&#x3D;&#x3D; 的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E5%A4%A7%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8Eobject%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.3.</span> <span class="toc-text"> 7 大原始类型与 Object 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.1.4.</span> <span class="toc-text"> 类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text"> 原始类型判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%BB%A5%E5%8F%8Anull"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text"> 非原始类型判断 (以及 null)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.</span> <span class="toc-text"> 二、深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.5.</span> <span class="toc-text"> 三、原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AE%9E%E7%8E%B0class%E4%B8%8Eextends"><span class="toc-number">1.6.</span> <span class="toc-text"> 四、实现 class 与 extends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0class"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 实现 class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0extends"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 实现 extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.</span> <span class="toc-text"> 五、继承与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.2.</span> <span class="toc-text"> 原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.3.</span> <span class="toc-text"> 原型之间的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.4.</span> <span class="toc-text"> 静态属性继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.5.</span> <span class="toc-text"> 实例属性继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.6.</span> <span class="toc-text"> 继承的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="toc-number">1.8.</span> <span class="toc-text"> 六、作用域、执行上下文与闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 作用域与作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.8.1.1.</span> <span class="toc-text"> 作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.8.1.2.</span> <span class="toc-text"> 作用域链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-this"><span class="toc-number">1.9.</span> <span class="toc-text"> 七、this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.9.1.</span> <span class="toc-text"> 普通函数中的 this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">1.9.1.1.</span> <span class="toc-text"> 直接调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E8%80%85%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8C%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.1.2.</span> <span class="toc-text"> 基于调用者以及不同调用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.9.2.</span> <span class="toc-text"> 箭头函数中的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91"><span class="toc-number">1.9.3.</span> <span class="toc-text"> 如何改变函数的 this 指向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-apply-call-bind%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.</span> <span class="toc-text"> 八、apply、call、bind 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0apply"><span class="toc-number">1.10.1.</span> <span class="toc-text"> 手动实现 apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0call"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 手动实现 call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0bind"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 手动实现 bind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.11.</span> <span class="toc-text"> 九、同步与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">1.11.1.</span> <span class="toc-text"> 同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.11.2.</span> <span class="toc-text"> 异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8Eeventloop"><span class="toc-number">1.11.2.1.</span> <span class="toc-text"> 异步、单线程与 EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.11.2.1.1.</span> <span class="toc-text"> 微任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.11.2.1.2.</span> <span class="toc-text"> 宏任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#js%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.2.1.3.</span> <span class="toc-text"> js 单线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eventloop"><span class="toc-number">1.11.2.1.4.</span> <span class="toc-text"> EventLoop</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.3.</span> <span class="toc-text"> 前端异步的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webworker%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.4.</span> <span class="toc-text"> WebWorker 多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-amd-cmd-commonjs%E4%B8%8Ees6%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.12.</span> <span class="toc-text"> 十、AMD、CMD、CommonJS 与 ES6 模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#amd%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89"><span class="toc-number">1.12.1.</span> <span class="toc-text"> AMD 异步模块定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmd%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89"><span class="toc-number">1.12.2.</span> <span class="toc-text"> CMD 通用模块定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commonjs"><span class="toc-number">1.12.3.</span> <span class="toc-text"> CommonJS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.12.4.</span> <span class="toc-text"> ES6 模块化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-script%E6%A0%87%E7%AD%BE%E4%B9%8Basync%E4%B8%8Edefer"><span class="toc-number">1.13.</span> <span class="toc-text"> 十一、script 标签之 async 与 defer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8async%E5%B1%9E%E6%80%A7"><span class="toc-number">1.13.1.</span> <span class="toc-text"> 使用 async 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8defer%E5%B1%9E%E6%80%A7"><span class="toc-number">1.13.2.</span> <span class="toc-text"> 使用 defer 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%83%85%E5%86%B5"><span class="toc-number">1.13.3.</span> <span class="toc-text"> 不同情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%9C%AC%E8%BA%AB%E7%9A%84api"><span class="toc-number">1.14.</span> <span class="toc-text"> 十二、改变数组本身的 api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-window%E4%B9%8Blocation-navigator"><span class="toc-number">1.15.</span> <span class="toc-text"> 十三、window 之 location、navigator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#location%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.15.1.</span> <span class="toc-text"> location 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigator%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.15.2.</span> <span class="toc-text"> navigator 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-ajax%E4%B8%8Efetch"><span class="toc-number">1.16.</span> <span class="toc-text"> 十四、ajax 与 fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax"><span class="toc-number">1.16.1.</span> <span class="toc-text"> ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch"><span class="toc-number">1.16.2.</span> <span class="toc-text"> fetch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-websocket"><span class="toc-number">1.17.</span> <span class="toc-text"> 十五、WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-%E7%9F%AD%E8%BD%AE%E8%AF%A2-%E9%95%BF%E8%BD%AE%E8%AF%A2%E4%B8%8Ewebsocket"><span class="toc-number">1.18.</span> <span class="toc-text"> 十六、短轮询、长轮询与 WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.18.1.</span> <span class="toc-text"> 短轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.18.2.</span> <span class="toc-text"> 长轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">1.18.3.</span> <span class="toc-text"> 相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">1.18.4.</span> <span class="toc-text"> 不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-socket"><span class="toc-number">1.18.5.</span> <span class="toc-text"> Web Socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.19.</span> <span class="toc-text"> 十七、长连接与短连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.19.1.</span> <span class="toc-text"> 短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.19.2.</span> <span class="toc-text"> 长连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E7%9F%AD%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.3.</span> <span class="toc-text"> 长短轮询和长短连接区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E5%AD%98%E5%82%A8"><span class="toc-number">1.20.</span> <span class="toc-text"> 十八、存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">1.20.1.</span> <span class="toc-text"> Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session"><span class="toc-number">1.20.2.</span> <span class="toc-text"> Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.3.</span> <span class="toc-text"> cookie 与 session 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8localstorage%E4%B8%8Esessionstorage"><span class="toc-number">1.20.4.</span> <span class="toc-text"> 本地存储 localStorage 与 sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#localstorage"><span class="toc-number">1.20.4.1.</span> <span class="toc-text"> localStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sessionstorage"><span class="toc-number">1.20.4.2.</span> <span class="toc-text"> sessionStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.4.3.</span> <span class="toc-text"> 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.21.</span> <span class="toc-text"> 十九、跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp"><span class="toc-number">1.21.1.</span> <span class="toc-text"> jsonp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cors"><span class="toc-number">1.21.2.</span> <span class="toc-text"> CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postmessage"><span class="toc-number">1.21.3.</span> <span class="toc-text"> postMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windowname"><span class="toc-number">1.21.4.</span> <span class="toc-text"> window.name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#documentdomain"><span class="toc-number">1.21.5.</span> <span class="toc-text"> document.domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.21.6.</span> <span class="toc-text"> nginx 反向代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-settimeout%E4%B8%8Esetinterval"><span class="toc-number">1.22.</span> <span class="toc-text"> 二十、setTimeout 与 setInterval</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#settimeout"><span class="toc-number">1.22.1.</span> <span class="toc-text"> setTimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setinterval"><span class="toc-number">1.22.2.</span> <span class="toc-text"> setInterval</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80-requestanimationframe"><span class="toc-number">1.23.</span> <span class="toc-text"> 二十一、requestAnimationFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.24.</span> <span class="toc-text"> 二十二、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dom0%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.24.1.</span> <span class="toc-text"> DOM0 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dom2%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.24.2.</span> <span class="toc-text"> DOM2 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">1.24.3.</span> <span class="toc-text"> 事件代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.25.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-map"><div class="card-content"><div class="item-headline"><i class="fa fa-globe-asia" aria-hidden="true"></i><span>Visitor Map</span></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=4LA950xi3DtQgUHPlkO0mo-n_QgrcOu-1BIiVpExg7k"></script></div></div><div class="card-widget card-pixiv"><div class="card-content"><div class="item-headline"><i class="fa fa-image" aria-hidden="true"></i><span>Pixiv Top50</span><iframe src="https://cloud.mokeyjay.com/pixiv" frameborder="0" style="width:99%;height:380px;margin:0;"></iframe></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/Maven/" title="My Maven notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/hello-world.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My Maven notes"/></a><div class="content"><a class="title" href="/2022/07/28/Maven/" title="My Maven notes">My Maven notes</a><time datetime="2022-07-27T12:00:00.000Z" title="Created 2022-07-28 00:00:00">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/nodejs/" title="Nodejs notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/town.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nodejs notes"/></a><div class="content"><a class="title" href="/2022/07/25/nodejs/" title="Nodejs notes">Nodejs notes</a><time datetime="2022-07-24T12:00:00.000Z" title="Created 2022-07-25 00:00:00">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" title="My ultimate data structure and algorithm guide"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/statue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My ultimate data structure and algorithm guide"/></a><div class="content"><a class="title" href="/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" title="My ultimate data structure and algorithm guide">My ultimate data structure and algorithm guide</a><time datetime="2022-06-11T12:00:00.000Z" title="Created 2022-06-12 00:00:00">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Design Patterns"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Design Patterns"/></a><div class="content"><a class="title" href="/2022/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Design Patterns">Design Patterns</a><time datetime="2022-06-11T12:00:00.000Z" title="Created 2022-06-12 00:00:00">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" title="Design Patterns - Factory Method"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Design Patterns - Factory Method"/></a><div class="content"><a class="title" href="/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" title="Design Patterns - Factory Method">Design Patterns - Factory Method</a><time datetime="2022-06-10T12:00:00.000Z" title="Created 2022-06-11 00:00:00">2022-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Harry Qu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://harryqu1229.github.io/2022/01/13/js%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93/'
    this.page.identifier = '2022/01/13/js万字总结/'
    this.page.title = 'Javascript 26k words Summary'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://harry-study-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '5df1e915e0fa867b50de',
      clientSecret: 'ce1cb793fe49078ee9d0102d3326d0d50ff6937b',
      repo: 'blog-comments-storage',
      owner: 'HarryQu1229',
      admin: ['HarryQu1229'],
      id: '9a392728d9a7e01791fae4f7d017fa42',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Disqus' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[image]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[link]') // replace url
    content = content.replace(/<code>.*?<\/code>/gi, '[code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=harry-study-blog&related=thread&limit=6&api_key=B5XFmdGuVaYDW7OIBakffpXoKorvphwRiwONIol4puEtr8YiwYAMAk2K7QcExNLY')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        saveToLocal.set('disqus-newest-comments', JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "Unable to get the data, please make sure the settings are correct."
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += 'No Comment'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('disqus-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="2809513713" data-server="netease" data-type="playlist" data-autoplay="false" data-fixed="true" data-order="random" data-theme="#e9ccd3"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'HarryStudyBlog/community',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (true) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":450},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>