<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>My ultimate data structure and algorithm guide | Harry Blog</title><meta name="keywords" content="algorithm,data structure,fundamental"><meta name="author" content="Harry Qu"><meta name="copyright" content="Harry Qu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="# 前言 此笔记是按照 b 站左程云左神讲的课做的笔记 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV13g41157hK?spm_id_from&#x3D;333.999.0.0&amp;vd_source&#x3D;7bb61b79eb5fd85a23a01aa0e93efca0 从初级班班内容到高级班，此笔记应该是对该视频最全的笔记，内涵题目代码讲解以及一些个人思想 (废话)  模板部分主要">
<meta property="og:type" content="article">
<meta property="og:title" content="My ultimate data structure and algorithm guide">
<meta property="og:url" content="https://harryqu1229.github.io/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Harry Blog">
<meta property="og:description" content="# 前言 此笔记是按照 b 站左程云左神讲的课做的笔记 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV13g41157hK?spm_id_from&#x3D;333.999.0.0&amp;vd_source&#x3D;7bb61b79eb5fd85a23a01aa0e93efca0 从初级班班内容到高级班，此笔记应该是对该视频最全的笔记，内涵题目代码讲解以及一些个人思想 (废话)  模板部分主要">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://harryqu1229.github.io/img/default-covers/statue.jpg">
<meta property="article:published_time" content="2022-06-11T12:00:00.000Z">
<meta property="article:modified_time" content="2022-06-12T01:38:56.316Z">
<meta property="article:author" content="Harry Qu">
<meta property="article:tag" content="fundamental">
<meta property="article:tag" content="summary">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://harryqu1229.github.io/img/default-covers/statue.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://harryqu1229.github.io/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":100,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#C78550","bgDark":"#c08eaf","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'My ultimate data structure and algorithm guide',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-12 13:38:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">158</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">57</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-graduation-cap"></i><span> Journey</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Hobbies</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default-covers/statue.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Harry Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-graduation-cap"></i><span> Journey</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Hobbies</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Movies/"><i class="fa-fw fas fa-video"></i><span> Movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">My ultimate data structure and algorithm guide</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-06-11T12:00:00.000Z" title="Created 2022-06-12 00:00:00">2022-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-12T01:38:56.316Z" title="Updated 2022-06-12 13:38:56">2022-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Summary/">Summary</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Summary/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">84.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>285min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="My ultimate data structure and algorithm guide"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2>
<p>此笔记是按照 b 站左程云左神讲的课做的笔记</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?spm_id_from=333.999.0.0&amp;vd_source=7bb61b79eb5fd85a23a01aa0e93efca0">https://www.bilibili.com/video/BV13g41157hK?spm_id_from=333.999.0.0&amp;vd_source=7bb61b79eb5fd85a23a01aa0e93efca0</a></p>
<p>从初级班班内容到高级班，此笔记应该是对该视频最全的笔记，内涵题目代码讲解以及一些个人思想 (废话)</p>
<ul>
<li><strong>模板</strong>部分主要是为了参加比赛的同学方便截取</li>
<li><strong>个人看法</strong>部分是一些我自己做的题</li>
<li><strong>算法课</strong>以及<strong>刷题以及技巧</strong>为视频的初级中级以及高级版的内容 (按照顺序)</li>
</ul>
<p>之后还会按照<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a>出一篇个人刷题的记录以及刷题思想，敬请期待！</p>
<p>写笔记不易，求个点赞！</p>
<h2 id="模板"><a class="markdownIt-Anchor" href="#模板">#</a> 模板</h2>
<h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h3>
<p>据不完全总结，二叉树的题大致可以分为两种，一种是通过前序、中序、后序、层序遍历来解决问题。</p>
<p>另一种为递归问题，需要从每个节点来获取信息，然后提取出题目中要求的信息</p>
<h4 id="遍历模版"><a class="markdownIt-Anchor" href="#遍历模版">#</a> 遍历模版</h4>
<h5 id="二叉树非递归遍历"><a class="markdownIt-Anchor" href="#二叉树非递归遍历">#</a> 二叉树非递归遍历</h5>
<h6 id="中序"><a class="markdownIt-Anchor" href="#中序">#</a> 中序</h6>
<ol>
<li>先找到最左节点，并逐步压栈</li>
<li>当最左为空时，弹出栈顶（此时为最左节点），并输出</li>
<li>找最左节点有没有右孩子，有则压栈（循环 1，2），没有进行下一步</li>
<li>没有右孩子时，当前节点为 null，弹出栈顶（此时栈顶为最左节点的父亲节点）</li>
<li>输出 最左节点的父亲节点 的值</li>
<li>找 5 中的节点有没有右孩子 重复（1，2）</li>
<li>当栈为空 且 当前遍历的节点为 null 时 ，遍历结束</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token operator">=</span>root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            root<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token operator">=</span>root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="前序"><a class="markdownIt-Anchor" href="#前序">#</a> 前序</h6>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>                  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="后序"><a class="markdownIt-Anchor" href="#后序">#</a> 后序</h6>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> temp <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>        
        temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>    
        
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>temp<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="层次遍历非递归"><a class="markdownIt-Anchor" href="#层次遍历非递归">#</a> 层次遍历非递归</h5>
<p>很多求层相关的问题都可以使用此模版解题</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token function">checkFun02</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> resList<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkFun02</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
       <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> que <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
           <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> itemList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">int</span> len <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

           <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
               <span class="token class-name">TreeNode</span> tmpNode <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               itemList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

               <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>tmpNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
               len<span class="token operator">--</span><span class="token punctuation">;</span>
           <span class="token punctuation">&#125;</span>
           resList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>itemList<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项</h4>
<p><strong>求二叉树对称的时候就是把两个树的节点同时加入队列进行比较</strong></p>
<p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点</strong></p>
<p><strong>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</strong></p>
<p>大多数二叉搜索树的题目，其实都离不开中序遍历，因为这样就是有序的</p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">代码随想录</a></p>
<h4 id="递归模版"><a class="markdownIt-Anchor" href="#递归模版">#</a> 递归模版</h4>
<p>可以解决面试中绝大多数的二叉树问题尤其是树型 dp 问题<br>
本质是利用递归遍历二叉树的便利性</p>
<h5 id="递归套路步骤"><a class="markdownIt-Anchor" href="#递归套路步骤">#</a> 递归套路步骤</h5>
<ol>
<li>假设以 X 节点为头，假设可以向 X 左树和 X 右树要任何信息</li>
<li>在上一步的假设下，讨论以 X 为头节点的树，得到答案的可能性 (最重要)</li>
<li>列出所有可能性后，确定到底需要向左树和右树要什么样的信息</li>
<li>把左树信息和右树信息求全集，就是任何一 一棵子树都需要返回的信息 S</li>
<li>递归函数都返回 S，每一棵子树都这么要求</li>
<li>写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</li>
</ol>
<hr>
<h3 id="图"><a class="markdownIt-Anchor" href="#图">#</a> 图</h3>
<h4 id="图-2"><a class="markdownIt-Anchor" href="#图-2">#</a> 图：</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> nodes<span class="token punctuation">;</span><span class="token comment">//点的集合</span>
	<span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">></span></span> edges<span class="token punctuation">;</span><span class="token comment">//边的集合</span>

	<span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="点"><a class="markdownIt-Anchor" href="#点">#</a> 点：</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment">//节点的数值</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> in<span class="token punctuation">;</span><span class="token comment">//入度（有多少个节点指向我）</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> out<span class="token punctuation">;</span><span class="token comment">//出度（我指向多少个节点）</span>
	<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">></span></span> nexts<span class="token punctuation">;</span><span class="token comment">//从我出发能到达的下一级节点，邻居节点</span>
	<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">></span></span> edges<span class="token punctuation">;</span><span class="token comment">//从我出发发散出的边的集合</span>

	<span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
		in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="边"><a class="markdownIt-Anchor" href="#边">#</a> 边：</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span><span class="token comment">//这个边的权重是多少</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> from<span class="token punctuation">;</span><span class="token comment">//这个边从哪里出发</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">;</span><span class="token comment">//这个边到达哪里的</span>

	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> weight<span class="token punctuation">,</span> <span class="token class-name">Node</span> from<span class="token punctuation">,</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="图生成器接口这个要按需求以及输入的来改变"><a class="markdownIt-Anchor" href="#图生成器接口这个要按需求以及输入的来改变">#</a> 图生成器 (接口，这个要按需求以及输入的来改变)：</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GraphGenerator</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Graph</span> <span class="token function">createGraph</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//输入一个矩阵</span>
		<span class="token class-name">Graph</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化自定义的图</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token class-name">Integer</span> weight <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//边的权重</span>
			<span class="token class-name">Integer</span> from <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//from节点的序列</span>
			<span class="token class-name">Integer</span> <span class="token keyword">to</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//to节点的序列</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//先检查from节点存在否,不存在就建</span>
				graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//再检查to节点存在否,不存在就建立</span>
				graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token class-name">Node</span> fromNode <span class="token operator">=</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿出from点</span>
			<span class="token class-name">Node</span> toNode <span class="token operator">=</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿出to点</span>
			<span class="token class-name">Edge</span> newEdge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span> fromNode<span class="token punctuation">,</span> toNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立新的边</span>
			fromNode<span class="token punctuation">.</span>nexts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//from的邻接点增加了一个to节点</span>
			fromNode<span class="token punctuation">.</span>out<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//from的出度加1</span>
			toNode<span class="token punctuation">.</span>in<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//to节点的入度加1</span>
			fromNode<span class="token punctuation">.</span>edges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newEdge<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//from节点的边集增加</span>
			graph<span class="token punctuation">.</span>edges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newEdge<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加到整个图的边集里</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> graph<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="对数器"><a class="markdownIt-Anchor" href="#对数器">#</a> 对数器</h3>
<p>使用对数器，具体步骤：<br>
1）有一个你想要测的方法 a<br>
2）实现一个绝对正确但是复杂度不好的方法 b<br>
3） 实现一个随机样本产生器<br>
 4）实现比对的方法<br>
 5）把方法 a 和方法 b 比对很多次来验证方法 a 是否正确。<br>
6）如果有一个样本使得比对出错，打印样本分析是哪个方法出 错<br>
 7）当样本数量很多时比对测试依然正确，可以确定方法 a 已经 正确。</p>
<p>好处：</p>
<p>验证方法对不对<br>
可以很快找到错误 case（几千几万 case 中）<br>
判断贪心对不对<br>
具体实现（例如测试冒泡排序方法是否正确）：<br>
想要测试冒泡排序方法 a（判断该方法是否正确）：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> e <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> e<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//范围每次缩减1，因为每次都排好了一个数</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//从头到e进行两两比较</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//（前面比后面大就进行交换）</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//两两交换</span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1产生一个长度随机的数组可能为正也可能为负0"><a class="markdownIt-Anchor" href="#1产生一个长度随机的数组可能为正也可能为负0">#</a> 1）产生一个长度随机的数组（可能为正，也可能为负，0）</h4>
<p>随机样本产生器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateRandomArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>maxValue <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> arr<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2绝对正确的方法"><a class="markdownIt-Anchor" href="#2绝对正确的方法">#</a> 2）绝对正确的方法</h4>
<p>调用函数自带的排序方法（实现一个绝对正确但是复杂度不好的方法 b，用于和冒泡排序测试方法比较，判断测试方法是否正确）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">comparator</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="3大样本测试"><a class="markdownIt-Anchor" href="#3大样本测试">#</a> 3）大样本测试</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> testTime <span class="token operator">=</span> <span class="token number">500000</span><span class="token punctuation">;</span><span class="token comment">//测试次数</span>
		<span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
		<span class="token keyword">boolean</span> succeed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testTime<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token function">generateRandomArray</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//产生随机数组</span>
			<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token function">copyArray</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试的方法</span>
			<span class="token function">comparator</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绝对正确的方法</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				succeed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>succeed <span class="token operator">?</span> <span class="token string">"Nice!"</span> <span class="token operator">:</span> <span class="token string">"Fucking fucked!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//实现比对的方法 ，比较两个数组的每个数是否相等</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>arr1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">.</span>length <span class="token operator">!=</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="回溯模板"><a class="markdownIt-Anchor" href="#回溯模板">#</a> 回溯模板</h3>
<h4 id="subsets"><a class="markdownIt-Anchor" href="#subsets">#</a> Subsets</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="subsets-ii-contains-duplicates"><a class="markdownIt-Anchor" href="#subsets-ii-contains-duplicates">#</a> Subsets II (contains duplicates)</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets-ii/">https://leetcode.com/problems/subsets-ii/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// skip duplicates</span>
        tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="permutations"><a class="markdownIt-Anchor" href="#permutations">#</a> Permutations</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// Arrays.sort(nums); // not necessary</span>
   <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
         <span class="token keyword">if</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// element already exists, skip</span>
         tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
         tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="permutations-ii-contains-duplicates"><a class="markdownIt-Anchor" href="#permutations-ii-contains-duplicates">#</a> Permutations II (contains duplicates)</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">https://leetcode.com/problems/permutations-ii/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
            tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span>
            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
            tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="combination-sum"><a class="markdownIt-Anchor" href="#combination-sum">#</a> Combination Sum</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> remain<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>remain <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>remain <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span><span class="token punctuation">&#123;</span> 
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> remain <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not i + 1 because we can reuse same elements</span>
            tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="combination-sum-ii-cant-reuse-same-element"><a class="markdownIt-Anchor" href="#combination-sum-ii-cant-reuse-same-element">#</a> Combination Sum II (can’t reuse same element)</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/">https://leetcode.com/problems/combination-sum-ii/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> remain<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>remain <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>remain <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// skip duplicates</span>
            tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> remain <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="palindrome-partitioning"><a class="markdownIt-Anchor" href="#palindrome-partitioning">#</a> Palindrome Partitioning</h4>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> list<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> tempList<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>tempList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            tempList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> tempList<span class="token punctuation">,</span> s<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tempList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>low<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>high<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="代码随想录"><a class="markdownIt-Anchor" href="#代码随想录">#</a> 代码随想录</h3>
<h4 id="二分查找法"><a class="markdownIt-Anchor" href="#二分查找法">#</a> 二分查找法</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 我们定义target在左闭右开的区间里，[left, right)  </span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为left == right的时候，在[left, right)是无效的空间</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">// target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在 [middle+1, right)中</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span>
                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值的情况，直接返回下标</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id=""><a class="markdownIt-Anchor" href="#">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#kmp">#</a>KMP</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">kmp</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> next<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-2"><a class="markdownIt-Anchor" href="#-2">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E4%BA%8C%E5%8F%89%E6%A0%91">#</a>二叉树</h4>
<p>二叉树的定义：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    TreeNode <span class="token operator">*</span>left<span class="token punctuation">;</span>
    TreeNode <span class="token operator">*</span>right<span class="token punctuation">;</span>
    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-3"><a class="markdownIt-Anchor" href="#-3">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92">#</a>深度优先遍历（递归）</h4>
<h5 id="前序遍历中左右"><a class="markdownIt-Anchor" href="#前序遍历中左右">#</a> 前序遍历（中左右）</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中 ，同时也是处理节点逻辑的地方</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="中序遍历左中右"><a class="markdownIt-Anchor" href="#中序遍历左中右">#</a> 中序遍历（左中右）</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中 ，同时也是处理节点逻辑的地方</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="后序遍历左右中"><a class="markdownIt-Anchor" href="#后序遍历左右中">#</a> 后序遍历（左右中）</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中 ，同时也是处理节点逻辑的地方</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-4"><a class="markdownIt-Anchor" href="#-4">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>深度优先遍历（迭代法）</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>
    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 左</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 中</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 节点处理逻辑</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="中序遍历左中右-2"><a class="markdownIt-Anchor" href="#中序遍历左中右-2">#</a> 中序遍历（左中右）</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span> <span class="token comment">// 存放中序遍历的元素</span>
    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 中</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 左</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 节点处理逻辑</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="后序遍历左右中-2"><a class="markdownIt-Anchor" href="#后序遍历左右中-2">#</a> 后序遍历（左右中）</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>
    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 中</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 左</span>

        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 节点处理逻辑</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-5"><a class="markdownIt-Anchor" href="#-5">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E9%98%9F%E5%88%97">#</a>广度优先遍历（队列）</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 这里一定要使用固定大小size，不要使用que.size()</span>
            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 节点处理的逻辑</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-6"><a class="markdownIt-Anchor" href="#-6">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6">#</a>二叉树深度</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-7"><a class="markdownIt-Anchor" href="#-7">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F">#</a>二叉树节点数量</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-8"><a class="markdownIt-Anchor" href="#-8">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">#</a>回溯算法</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        存放结果<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        处理节点<span class="token punctuation">;</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
        回溯，撤销处理结果
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-9"><a class="markdownIt-Anchor" href="#-9">#</a> <a target="_blank" rel="noopener" href="https://programmercarl.com/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html#%E5%B9%B6%E6%9F%A5%E9%9B%86">#</a>并查集</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1005</span><span class="token punctuation">;</span> <span class="token comment">// 根据题意而定 </span>
<span class="token keyword">int</span> father<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 并查集初始化</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 并查集里寻根的过程</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> u <span class="token operator">==</span> father<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">?</span> u <span class="token operator">:</span> father<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>father<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 将v->u 这条边加入并查集</span>
<span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    father<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 判断 u 和 v是否找到同一个根</span>
<span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
    v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> u <span class="token operator">==</span> v<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="个人看法"><a class="markdownIt-Anchor" href="#个人看法">#</a> 个人看法</h2>
<h4 id="第一题"><a class="markdownIt-Anchor" href="#第一题">#</a> 第一题</h4>
<ul>
<li>
<p>换个角度思考，比如说找两个数字相加会等于一个数字 (target), 也就是说找那个数字 (target) 减去其中一个数字的数字，这个样子我们可以固定一个数字 (比如说一个 for loop 的 i 每次 iteration 都是固定的) 然后去找 target-i.</p>
</li>
<li>
<p>注意数据结构，看要想干什么，是查询还是什么？查询用什么块？(数组遍历 O (N),hash table 约 O (1) 除非 worst case)</p>
</li>
<li>
<p>如果我们要按照一个数字找跟他相关的比如说这个数字在一个 array 里面的下标可以用一个 hash table (HashMap) 来存他们的 key value pair. 这个样子要是搜查 key (数字) 的时候可以通过他的 hash function 更快的查询到那个 key, 找到那个 key 也可以知道那个 key 的 value (下标) 了.</p>
</li>
<li>
<p>如果我们要把数据传到另外一个数据结构比如说 array to HashMap (hash table) 一般会用到一个 loop 然后挨个传进来，然后再进行操作，想想能不能在传的时候，在那个 loop 里面，直接在传每一个数据之前或者之后进行操作？</p>
<ul>
<li>比如说我们要找像上面的说的 target-i, 必须要有一个数字是固定的 (就让我们这个 loop 本身的数字每个 iteration 的数字固定住), 然后还需要找 target-i. 我们可以直接看这个数字在不在这个新的数据结构里面 (这样就是查询可以像上面的说的用 hash table 更快), 如果已经有了就直接 return, 如果不在 再 把当前这个固定的数字给传进新的数据结构。接下来下一个 iteration 下一个数字固定住，找相对应的 target-i. 这么做是对的因为我们还是会把数据一个一个传进去，所以如果有复合需求的那两个数字在的话，在第一个数字当固定，另外一个数字因为还没放进去所以没有，但是当第二数字当固定，这前面的数字已经放进去了，那就会查到。如果没有复合条件的，那就不会有结果.</li>
</ul>
</li>
</ul>
<h4 id="第二题"><a class="markdownIt-Anchor" href="#第二题">#</a> 第二题</h4>
<ul>
<li>如果需要的是一个 linkedlist 的第一个 node (他的 next 会指向下一个然后 next 的 next 指向…so on), 不一定需要我们第一个就是那个第一个 node, 我们可以先暂时用一个不是第一个的 node (value 不一样) 来指向第一个 node, 然后返回的时候再 <code>return node.next;</code>  就可以得到第一个 node</li>
<li>如果 linkedlist 已经指向了结尾 (到了 null), 是不是可以认为 value 为 0 然后再继续.</li>
<li>sum = number1 + number2 + carry(from previous number)</li>
</ul>
<h4 id="第387-first-unique-character-in-a-string"><a class="markdownIt-Anchor" href="#第387-first-unique-character-in-a-string">#</a> 第 387. First Unique Character in a String</h4>
<ul>
<li>用一个数组，长度 26, 每一个都是存字符串里面出现哪个字符出现几次。比如说下标为 1 的就是‘b’-‘a’, 然后记录着‘b’这个字符出现了几次</li>
<li>之后返回哪个存的是 1 的下标对应的字符就行了</li>
</ul>
<h4 id="第91-decode-ways"><a class="markdownIt-Anchor" href="#第91-decode-ways">#</a> 第 91. Decode Ways</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323180906289.png" alt="image-20220323180906289"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323180955458.png" alt="image-20220323180955458"></p>
<h4 id="第881-boats-to-save-people"><a class="markdownIt-Anchor" href="#第881-boats-to-save-people">#</a> 第 881. Boats to Save People</h4>
<ul>
<li>直接排序然后双指针 O (nlogn)</li>
<li>因为说了每条船两个人最多，所以双指针很合适</li>
<li>注意我这里用的 res++ 到处都是，其实可以改进，只需要记录双指针，只要 left&lt;=right 就执行，之后其实我们靠 right 指针获取需要多少串，或许用个变量去 track</li>
</ul>
<h4 id="第300-longest-increasing-subsequence"><a class="markdownIt-Anchor" href="#第300-longest-increasing-subsequence">#</a> 第 300. Longest Increasing Subsequence</h4>
<p>序列问题</p>
<ul>
<li>
<p>brute force 的话会是所有 subsequence, 这个复杂度为 2<sup>n</sup>-1 (跟求一个字符串的所有 subset 差不多一样)</p>
</li>
<li>
<p>dp 方法，就是创建一个数组，数组每一个元素代表原数组中当前元素为结尾的最长合法的数组序列长度，最后答案就是 dp 里面最大值，是 O (n<sup>2</sup>) 因为需要 dp 里面每一个元素都需要往之前的元素找最大的值，才可以知道自己的最大值可以是多少</p>
<blockquote>
<p>做法就是两个 for loop, 每一个元素，我们一开始把 dp 对应位置设置为 1, 然后接着 for loop 看 dp 数组里面这个位置之前有多少个比这个小的，每一次遇到就让当前他的值跟那个值 + 1 (代表他自己) 比较，之后要是又遇到了个小的，会接着比，这是因为这个数字存的当前数字作为结尾的数字序列最长长度不一样比后面的数字存的当前数字作为结尾的数字序列最长长度小，因为那个后面的数可能比自己这个数还要小 (但确实是符合那个比我们当前到了的 i 位置的数字要小)</p>
<p>期间我们没处理完一次 dp [i] 我们就查看一下，反正就是保存最大的 dp [i] 值就是答案</p>
<p><strong><mark>注意这个 dp 数组的作用，是记录每一个数作为数字序列结尾的最长长度是多少</mark></strong></p>
</blockquote>
</li>
<li>
<p>dp 加 binary search</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220324221200046.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220324221231487.png" alt="image-20220324221231487"></p>
<p>在这里，dp [i] 存的值代表 i+1 长度的序列中，结尾最小的元素是什么</p>
<ul>
<li>如果当前数是大于我们 dp 数组此时存的最后一个数 (比如说 x 位置), 那直接把当前数加到 dp 数组 (x+1 位置), 说明我们现在 so far 处理的<strong>合法的</strong>最长数组序列长度增加了一个，然后这个长度最小的元素也就是我们这个新加的</li>
<li>如果当前素是小于或者等于我们 dp 数组此时存的最后一个数 (比如说 x 位置), 说明我们之前处理的那些位置有一个位置，有可能被换成当前这个数 (只有这个数比那个数也小的话), 代表当前数才是作为那个长度合法的最长数组序列的最后一个元素是最小的，他能换哪个？他能换当前 dp 数组第一个比他小的 / 或者是跟他数一样的 (dp 数组很明显是升序排序的), 我们可以用 Array.binarySearch 找到那个数 (<em><em>这个系统函数如果找不到你要找的数，就会返回一个负数，然后你把返回的负数</em> - 1 然后再 - 1 就是那个第一个比我们找的数要大的数的下标！<span class="spoiler" title="..."> 新东西</span>！学到了！！！</em>*), 然后把当前数替代那个数</li>
<li>之后处理完所有数，答案就是我们的 dp 数组的长度 (如果用的是 arraylist, 如果是数组的话用变量记录什么的就行了)</li>
</ul>
<h4 id="第94-binary-tree-inorder-traversal"><a class="markdownIt-Anchor" href="#第94-binary-tree-inorder-traversal">#</a> 第 94. Binary Tree Inorder Traversal</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220324233825283.png" alt="image-20220324233825283"></p>
<h4 id="第1663-smallest-string-with-a-given-numeric-value"><a class="markdownIt-Anchor" href="#第1663-smallest-string-with-a-given-numeric-value">#</a> 第 1663. Smallest String With A Given Numeric Value</h4>
<ul>
<li>用一个字符数组，n 的大小，一开始直接设置为全是 a, 然后让 k 值 - n*1</li>
<li>之后只要 k 还要比 0 大，就需要把字符数组 (从最后一个开始往前) 变成 z 或者变成 k 值哪个更小边哪个 (可以用 char 直接加 Math.min (25,k))</li>
<li>然后当然把 k 更新，就是减去 Math.min (25,k)</li>
<li>之后就是 while 循环检查 k 是不是还是大于 0 等等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325130637393.png" alt="image-20220325130637393"></p>
<h4 id="第22-generate-parentheses"><a class="markdownIt-Anchor" href="#第22-generate-parentheses">#</a> 第 22. Generate Parentheses</h4>
<ul>
<li>回溯方法就是传一个 list 用来存每一个答案，然后每个答案就用 stringbuilder</li>
<li>回溯函数还有 max,open 代表当前层穿件来的 sb 有多少左括号，close 代表当前层穿件来的 sb 有多少右括号</li>
<li>我们当前 sb 等于 max*2 的话代表找到一个直接加入到 list 里面去</li>
<li>否则如果我们左括号加的数量没超过 max 数量我们就一直加，加完回调自己</li>
<li>我们右括号在下面，只有右括号没有超过左括号数量时，我们才让右括号增加，然后回调自己</li>
<li>每次右括号加完回调完自己都会先经过左括号的判断看看当前层符不符合那个小于 max 的情况</li>
<li>注意！！！
<ul>
<li>我们左边在最后是需要清除掉最后一个加的！！！这么做了才能创造其他的可能性</li>
<li>我们右边在最后是需要清除掉最后一个加的！！！这么做了才能创造其他的可能性</li>
</ul>
</li>
</ul>
<blockquote>
<p>相当于我们对于当前刚加完的左括号数做完回调之后我们我们把改层加的这个左括号从 sb 去掉，然后再试试加右边括号等等等</p>
<p>同理，我们右边的刚加的可能也需要去掉，这样才有其他的可能性</p>
</blockquote>
<p>可以这么想:</p>
<ul>
<li>每一次的排序都是靠着你 ** 所有左边括号 (中间还有可能夹着几个右括号)** 怎么放的，然后对于每种包括着所有左括号之间的排序，我们可以对剩下的 (没被包括住的右括号), 进行增加，一直增加到合适长度就把结果放入 list 里面去</li>
<li>因为当前的结果已经放回到 list, 然后就会 return, 一层一层往回走，因为我们之后放的右边括号 (这个判断在下面), 我们在返回的时候就把我们当初一个一个加的右括号从 sb 里面删除</li>
<li>直到回溯到我们那个保存的排序的最后一个左括号也被删除了，就会接着往下看此时的 sb 符不符合那个下面加右括号的 if, 如果符合就会添加，此时这个左括号相当于是被之后再加了，等等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325152259246.png" alt="image-20220325152259246"></p>
<h4 id="第283-move-zeroes"><a class="markdownIt-Anchor" href="#第283-move-zeroes">#</a> 第 283. Move Zeroes</h4>
<ul>
<li>第一次遍历，保持自己的一个 index, 然后只有当前数组数不是 0 就把放到自己维持的 index 上</li>
<li>之后从自己的 index 数到数组长度位置都是 0</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220326201752015.png" alt="image-20220326201752015"></p>
<h4 id="第844-backspace-string-compare"><a class="markdownIt-Anchor" href="#第844-backspace-string-compare">#</a> 第 844. Backspace String Compare</h4>
<ul>
<li>从每一个字符串后面开始生成字符串，如果是 #就增加 count</li>
<li>要不是 #的话那么只有在 count 为 0 的时候才可以加到字符串</li>
<li>为 s 生成字符串，为 t 生成字符串，之后比较他们相不相等就行了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220326205536346.png" alt="image-20220326205536346"></p>
<h4 id="第209-minimum-size-subarray-sum"><a class="markdownIt-Anchor" href="#第209-minimum-size-subarray-sum">#</a> 第 209. Minimum Size Subarray Sum</h4>
<ul>
<li>滑动窗口，规矩定好 (loop 然后里面 if 的更改情况)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220326214741412.png" alt="image-20220326214741412"></p>
<h4 id="第904-fruit-into-baskets"><a class="markdownIt-Anchor" href="#第904-fruit-into-baskets">#</a> 第 904. Fruit Into Baskets</h4>
<ul>
<li>滑动窗口</li>
<li>让左指针直接跳到一个位置</li>
<li>right-left+1 代表目前窗口长度</li>
<li>right 不一定要停啊等等等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220326224208493.png" alt="image-20220326224208493"></p>
<hr>
<h2 id="算法课"><a class="markdownIt-Anchor" href="#算法课">#</a> 算法课</h2>
<h3 id="异或"><a class="markdownIt-Anchor" href="#异或">#</a> 异或</h3>
<h4 id="异或换值"><a class="markdownIt-Anchor" href="#异或换值">#</a> 异或换值</h4>
<p>给两个变量的值换过来:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">a <span class="token operator">=</span> a<span class="token operator">^</span>b
b <span class="token operator">=</span> a<span class="token operator">^</span>b
a <span class="token operator">=</span> a<span class="token operator">^</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意 a 和 b 可以是一样的数字等等等，但是不可以是同一个，比如说数组里面 a 和 b 不能代表同一个元素</p>
</blockquote>
<h4 id="异或算一个不一样的"><a class="markdownIt-Anchor" href="#异或算一个不一样的">#</a> 异或算一个不一样的</h4>
<p>数组有一个数字出现了奇数次，其他的数都是偶数:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> xor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    xor<span class="token operator">^=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后 xor 会等于那个出现奇数次的，出现偶数次的数都被自己消除掉了</p>
<blockquote>
<ul>
<li>0^N=N</li>
<li>N^N=0</li>
<li>a^b=b^a</li>
<li>a^b^c=a^(b^c)</li>
</ul>
</blockquote>
<h4 id="异或算两个不一样的"><a class="markdownIt-Anchor" href="#异或算两个不一样的">#</a> 异或算两个不一样的</h4>
<p>数组有两个数字出现了奇数次，其他的数都是偶数:</p>
<ul>
<li>我们还是一个奇数次的做法先得到 xor, 那两个出现奇数次的数字 (比如说 a 和 b) 最后 xor 会等于 a^b</li>
<li>因为这两个数不一样，所以把他们转换成二进制他们肯定会在某一位上有一个是 0 有一个个是 1</li>
<li>0^1=1, 所以 xor (=a^b) 在那个位上也会是 1, 所以我们可以把 xor 的二进制最右边的数字部分获取出来</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306231800107.png" alt="image-20220306231800107"></p>
<blockquote>
<p>我们可以使用 <code>eor &amp; (~eor + 1)</code>  这个能提取出这个数 (eor) 的二进制最右边的 1 的数字以及后面转换成十进制的数字</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220304180850412.png" alt="image-20220304180850412"></p>
</blockquote>
<ul>
<li>我们有了这个数后我们就可以声明一个新变量 xor2 再次遍历数组，然后只有那个元素的结尾那几个我们上面取出来的几位二进制一样才可以让 xor2^= 那个元素 (使用 <code>&amp;</code>  判断就行，这个是 bit by bit, 这个细节比较多 (自己去查), 注意只是一个 <code>&amp;</code> !!!)</li>
<li>就算我们这个判断可能会让别的数也判断对，但那也是对于出现偶数次的数，我们知道另外一个出现奇数次的数字不可能在这个对应二进制位置上是一样的 (我们当前这个数的最右边的二进制为 1 的位置在另外一个出现奇数次的数字在那个位置肯定会是 1, 所以我们 xor 的结果在那个二进制位置也才可以是 1)</li>
<li>这样我们相当于是给那两个出现奇数次的元素给分成两个组了，然后出现偶数次的不同数字随便分，反正他们会自己消灭自己的 (异或就是这样的)</li>
</ul>
<p>最后 xor2 得出的就是要么是 a 要么是 b, 我们再 <code>xor^xor2</code>  就可以获得另外一个数字了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306234124719.png" alt="image-20220306234124719"></p>
<h3 id="排序"><a class="markdownIt-Anchor" href="#排序">#</a> 排序</h3>
<h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序">#</a> 冒泡排序</h4>
<ul>
<li>遍历数组</li>
<li>每次遍历让所有的元素 (除了最后) 跟下一个元素比，如果出现 inversion 就换过来</li>
<li>每次 outerloop 遍历就会让当前没有 sorted 部分找出一个最大元素放到正确的位置上 (被换到那)</li>
</ul>
<p>不管什么输入都是固定操作，除了最好 case 不需要换的操作</p>
<h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序">#</a> 选择排序</h4>
<ul>
<li>遍历数组</li>
<li>每次遍历都要遍历数组没有 sorted 部分找到当前最大 / 最小元素放到正确的位置上</li>
</ul>
<p>不管什么输入都是固定操作</p>
<h4 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序">#</a> 插入排序</h4>
<ul>
<li>遍历数组</li>
<li>首先做到 0-0 有序，这个很明显本身就做到了</li>
<li>接着我们要做到 0-1 有序，所以先看在 1 号元素
<ul>
<li>如果比前一个小就交换，交换完了再看前面有没有要交换的了，(前面没数了，也挺了), 我们此时做到了 0-1 有序</li>
<li>如果比前一个大，不需要交换</li>
</ul>
</li>
<li>接着我们要做到 0-2 有序，所以先看在 2 号元素
<ul>
<li>如果比前一个小就交换，交换完了再看前面有没有要交换的了，一直换到对的地方</li>
<li>如果比前一个大，不需要交换</li>
</ul>
</li>
<li>接着我们要做到 0-3 有序，所以先看在 3 号元素
<ul>
<li>如果比前一个小就交换，交换完了再看前面有没有要交换的了，一直换到对的地方</li>
<li>如果比前一个大，不需要交换</li>
</ul>
</li>
</ul>
<p>… 最终我们做到了 0-nums.length-1 有序了</p>
<blockquote>
<p>这个不像冒泡排序和选择排序是固定操作，如果给的就是有序的，那就比一比就完成了所以会是 O (N), 但我们说时间复杂度都是 worst case 所以还是 O (N^2)</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306235935011.png" alt="image-20220306235935011"></p>
<h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序">#</a> 归并排序</h4>
<ul>
<li>找到当前中心点 mid</li>
<li>调用自己排序 left 到 mid</li>
<li>调用自己排序 mid+1 到 right</li>
<li>然后就 merge (需要一个 helper array 当工具人，然后需要考虑要是 merge 的某一边没清理干净，还有剩的)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307004137921.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307004303105.png" alt="image-20220307004303105"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307004355645.png" alt="image-20220307004355645"></p>
<p>空间复杂度就是那个 helper 数组，每次递归就会用到然后用完就没了会被垃圾回收器自动清理，注意这个并不是在递归里面产生的数组，那就不一样了，要是是在递归可能就不是 O (N) 空间复杂度了，merge 不是递归操作</p>
<h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序">#</a> 快速排序</h4>
<p>快排 3.0 (1.0 和 2.0 参考别处，这里直接讲 3.0)</p>
<blockquote>
<ul>
<li>就是随机选一个数组中的数字把他放到数组最后面</li>
<li>接着让这个数字按照我们那个荷兰国旗问题解决方式一样，让小于这个数组放左边，<strong> 等于这个数字放中间</strong>，大于这个数字的放右边</li>
<li>然后把最后这个元素换到大于区域的当前 k 下标也就是大于区域第一个数，我们把这个数放到这就是可以让他和他一样的数 (如果有) 贴贴</li>
<li>接着直接调用自己递归，对当前的小于区域和当前的大于区域重复上面的操作，这就会让__每一个元素__他的左边就是比他小的，他的右边就是比他大的</li>
</ul>
<p>我们这里使用荷兰国旗问题解决方式，那个等于区域就相当于如果有一些数字和当前数字一样，完全没有必要让他们在进行什么操作，直接拍一块，然后操作小于这个数的和大于这个数的就行了，就相当于一次可能处理了多个数，也有可能就处理了一个 (如果这个数字在这个数组里面是 unique 的)</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307020953035.png" alt="image-20220307020953035"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307021203696.png" alt="image-20220307021203696"></p>
<blockquote>
<p>注意如果不使用随机数字当做 pivot, 那么时间复杂度就是 O (N^2) 因为这个就是针对于 worst case, 所以要是固定选一个位置的当做 pivot 肯定他的 worst case 就是 O (N^2)</p>
<p>比如说固定从最后一个数当做 pivot:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307020042372.png" alt="image-20220307020042372"></p>
</blockquote>
<blockquote>
<p>最好情况是</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307020136189.png" alt="image-20220307020136189"></p>
</blockquote>
<blockquote>
<p>我们使用随机选的，都是概率事件，最后按照数学结论就是 O (Nlog (N)), 所以我们快排都是随机挑的 pivot (或者其他的等等等)</p>
</blockquote>
<p><strong>如果不是随机 (或者什么奇特的方法) 找 pivot 那么最差情况是 O (N)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307021546134.png" alt="image-20220307021546134"></p>
<p><strong>如果好情况，或者就是随机也可以，那么空间复杂度就是 O (logN)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307021912969.png" alt="image-20220307021912969"></p>
<blockquote>
<p>可以看到，就是类似于二叉树的展开</p>
<p>注意空间复杂度在递归的计算方法！！！这根我之前想的不太一样哈</p>
<p>可以理解为最大需要的额外的空间</p>
</blockquote>
<p>我们是否可以使用非递归方式写快排，是不是可以省掉这个空间呢？<strong>不行！</strong></p>
<blockquote>
<p>这是因为我们快排实际的 partition 我们是不知道划分成什么样的，我们是跟实际状况的，有个小于区域，有一个等于区域，有个大于区域，就是因为我们这些数据状况 (到底每一层被划分成什么样子) 我们不知道，我们需要看实际状况，所以才需要记录这些区域的中点位置</p>
</blockquote>
<blockquote>
<p>就好比我们当前需要递归左边的小于区域，我们去执行压栈… 然后把小于区域执行完成了，我们返回到了这一层，我们此时需要递归右边的大于区域，但我们怎么知道这个大于区域到底是哪部分？当然是靠我们压栈保存这些中点信息，有了每一层的中点细，我们才可以按照那个中点信息 (那个下标), 来找到右边的大于区域然后递归他</p>
</blockquote>
<blockquote>
<p>所以就算自己写，自己写让他压栈，也照样是保存那个数据，所以那个空间是省不了的！</p>
</blockquote>
<h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序">#</a> 堆排序</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307152259668.png" alt="image-20220307152259668"></p>
<p><strong>一个一个数字传进来的 heap insert</strong></p>
<ul>
<li>
<p>首先有数组，然后 heapSize 一开始是 0, 这个就是数组中现在几个数是我现在的堆</p>
</li>
<li>
<p>先接收第一个数字 (注意这样就是一个一个传的，而不是整个直接给你让你变成大根堆)</p>
</li>
<li>
<p>把那个数字放到我们 heapSize 现在的值的下标位置上，heapSize++, 现在我们数组中有一个数是我们的大根堆</p>
</li>
<li>
<p>接着把下一个数字放到 heapSize 现在的值的下标位置上，heapSize++</p>
<p>现在看这个放的数字的位置会是第一个的子孩子，所以要看现在还是不是大根堆，也就是当前数字有没有他父亲大 (他可以靠 (i-1)/2 下标算出他父亲的下标)</p>
<ul>
<li>如果没有父亲大或者等于，那就直接下一个</li>
<li>如果有父亲大，那就 bubble up (注意要是比当前父亲大，然后互换了，需要继续比较看换了后比那个时候的父亲是不是更大，如果还是更大，那就需要继续换，这个就是 bubble up 或者 heap insert)</li>
</ul>
</li>
<li>
<p>把一个一个传进来的数字都这么操作放入数组中，然后当结束时 heapSize==nums.length</p>
</li>
<li>
<p>我们已经有了一个大根堆结构</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307145443654.png" alt="image-20220307145443654"></p>
<p>** 如果直接让我们对一个数组变成一个大根堆，而不是一个一个元素 heap insert, 用这个方式！！！**</p>
<blockquote>
<p>修改我们的 heapSort 里面的方法，就是不用 heap insert, 而是从最后一个元素使用 heapify</p>
<p><strong>使用这个<span class="spoiler" title="..."><span class="spoiler" title="..."><span class="spoiler" title="...">这个更快</span></span></span>！！！时间复杂度比一个一个 heap insert 更低 (虽然之后一个个元素放到正确位置然后进行 heapify 还是占大头 O (NlogN) 所以 overall 还是 O (NlogN) 时间复杂度)</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307154759749.png" alt="image-20220307154759749"></p>
<blockquote>
<p>其实这么做更好，比一个一个进行 heap insert 形成大根堆要更好，这是因为:</p>
<ul>
<li>首先如果 N 个元素，那么差不多会有 N/2 个 leaf node, 每个 leaf node 进行 heapify 操作，因为他下面什么都没有，所以假设只是看了一眼，所以就是 1</li>
<li>如果 N 个元素，那么差不多会有 N/4 个倒数第二层的节点，每个那一层节点进行 heapify 操作，最多只是看一眼然后移动一步，所以就是 2</li>
<li>如果 N 个元素，那么差不多会有 N/8 个倒数第三层的节点，每个那一层节点进行 heapify 操作，最多只是看一眼然后移动一步然后再看一眼再移动一步，所以就是 3 (其实应该是 4, 但就差不多，这些大概理念)</li>
</ul>
<p>所以整体复杂度:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307154324809.png" alt="image-20220307154324809"></p>
<p>我们可以解开:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307154409827.png" alt="image-20220307154409827"></p>
<p>__== 所以如果我们直接整个数组变成堆，而不是一个一个元素 heap insert (复杂度 O (NlogN)), 那么我们复杂度只需要 O (N) 了！！！==__</p>
<p>不过之后一个个元素放到正确位置然后进行 heapify 还是占大头 O (NlogN)<strong> 所以 overall 还是 O (NlogN) 时间复杂度</strong></p>
</blockquote>
<ul>
<li>把每一个子树变成一个大根堆，这样子整个都会是个大根堆</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307153119002.png" alt="image-20220307153119002"></p>
<blockquote>
<p>其实从这个数组最后一个数字也就是，最后最右一个 leaf 出发开始 heapify 也可以！！！只不过那些 leaf 进行 heapify 都是不会动的</p>
</blockquote>
<p><strong>heapify</strong></p>
<ul>
<li>有了一个大根堆我们就可以从数组中取出第一个元素就是最大的元素，然后让剩下的进行 heapify 操作，再次形成大根堆，然后再取出第一个元素也就是我们所有的数据的第二个大的，so on…</li>
<li>不过我们也可以直接把第一个元素也就是最大的直接跟最后一个元素交换，heapSize–(此时 heapSize=nums.length-1, 没错就是这，不过我们知道我们接下来就不用管这最后一个元素了，因为已经在正确的位置上了)</li>
<li>此时我们第一个元素是当初最后一个元素，我们可以使用 heapify 也就是 bubble down, 跟他的 左孩子和右孩子 (都是使用数组下标可以算出来的) 之间更大 的那个，如果比我们当前元素更小，那么交换，<strong>注意左孩子或者 == 左孩子和右孩子 (因为堆结构就是往左到右 fill 的，想想也合理，你数组如果有左孩子和右孩子，那么右孩子的下标就是左孩子的下一个，怎么可能会有 左孩子有右孩子没有 的情况)== 可能会是 null!!!</strong>  如果是 null 那就不换呗</li>
<li>我们就一直比，直到我们的元素比他此时的 左孩子和右孩子之间更大 的那个更大或者一样的话，那就不换了，到那就行了</li>
<li>此时我们就又形成了堆结构，接着把第一个元素也就是数组所有数第二大的放到 heapSize 现在的值 - 1 的下标位置，然后 heapSize–, so on…</li>
<li>直到我们的 heapSize 变成 0 代表数组所有的数我们都排序好了</li>
</ul>
<p>注意在每次我们的把一个数放到了正确的地方后，我们的 heapSize 就成为了那个数的下标的位置，我们下次 heapify 操作只需要针对数组下标为 0 到 heapSize-1 位置就行了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307150111094.png" alt="image-20220307150111094"></p>
<blockquote>
<p>问题:</p>
<p>如果我们已经形成了一个大根堆，结果有人突然把大根堆里面的一个下标的数改了，我们再怎么形成堆？</p>
<ul>
<li>我们可以__对这个下标的元素__调用一次 heapify, 调用一次 heap insert</li>
<li>这样如果这个数改小了，那么就会按照 heapify 到合适自己的位置上去，heap insert 不会起效果</li>
<li>这样如果这个数改大了，那么就会按照 heap insert 到合适自己的位置上去，heapify 不会起效果</li>
</ul>
</blockquote>
<blockquote>
<p>时间复杂度</p>
<p>因为堆其实就是二叉树操作相当于了，所以你对于一个元素然后 heap insert (也可以不用) 或者 heapify, 其实就是二叉树的高度，也就是 logN 级别，最多只需要走一个高度就行了，其他不需要碰</p>
<p><strong><mark>所有的 N 元素，那么就就是 O (NlogN)</mark></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307151032322.png" alt="image-20220307151032322"></p>
<p>空间复杂度</p>
<p>**O(1)!!!**</p>
<p>因为 heapify 和 heap insert 只有用到有限几个变量</p>
</blockquote>
<h4 id="桶排序-计数排序-基数排序"><a class="markdownIt-Anchor" href="#桶排序-计数排序-基数排序">#</a> 桶排序、计数排序、基数排序</h4>
<p><strong>计数排序</strong></p>
<p>每次统计当前数有多少个，然后给对应的元素位置中的数字 + 1，下次输出时按元素中的个数输出。</p>
<p><strong>基数排序</strong></p>
<p>比计数排序要好，因为没有那么麻烦创造那么多空间，只需要准备几个几个桶就行了，但是还是依然跟数据状况有关，排的东西还是需要是进制的，不然还是不行，不基于比较的排序都需要从数据状况搞点什么</p>
<ol>
<li>非基于比较的排序，与被排序的样本的实际数据状况很有关系，所以实际中并不经常使用</li>
<li>时间复杂度 O (N)，额外空间复杂度 O (N)</li>
<li>稳定的排序</li>
</ol>
<p><mark><strong>时间复杂度、空间复杂度 均为 O (N)，工程中不常用，但是笔试过程种可以使用这种办法来降低时间复杂度</strong></mark></p>
<p>对于给定的排序范围的数，进行排序。需要排序的数有 n 个。准备 n+1 个桶。</p>
<p>遍历每个数，将每个数装到对应的桶之后。再从第一个桶中取出，依次输出。</p>
<p>桶，基数排序就是先个位排序再十位排序，最后就是百位，然后等等等</p>
<p>先把个位数的排了，然后十位… 优先级更高的之后再排，先把个位数的优先级给搞好，然后一层一层来，最后就是所有位数的都排好了</p>
<blockquote>
<p><strong>都是准备十个桶</strong></p>
<p><mark>十进制的数就 10 个桶，3 进制 3 个，2 进制 2 个…</mark></p>
<p>属于不基于比较的排序，但是要求数字就是某种进制的才行</p>
</blockquote>
<p>实际理论比较复杂！！！(这里代码没用桶而是词频表，看视频！<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=4">https://www.bilibili.com/video/BV13g41157hK?p=4</a> 大概 2:09:35 部分)— 很大的优化 -&gt; 分片，然后出桶直接从右到左等等等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307174352474.png" alt="image-20220307174352474"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220305154925189.png" alt="image-20220305154925189"></p>
<h4 id="排序总结"><a class="markdownIt-Anchor" href="#排序总结">#</a> 排序总结</h4>
<blockquote>
<ol>
<li>
<p>不基于比较的排序，对样本数据有严格要求，不易改写</p>
</li>
<li>
<p>基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用</p>
</li>
<li>
<p><strong>基于比较的排序，时间复杂度的<mark>极限</mark>是 O (NlogN)</strong></p>
</li>
<li>
<p>时间复杂度 O (NlogN)、额外空间复杂度__低于 O (N)__、且稳定的__基于比较的__排序是不存在的。</p>
</li>
<li>
<p><mark><strong>为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并</strong></mark></p>
</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307175921601.png" alt="image-20220307175921601"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307183314578.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220307182859347.png" alt="image-20220307182859347"></p>
<hr>
<h3 id="查找"><a class="markdownIt-Anchor" href="#查找">#</a> 查找</h3>
<h4 id="二分"><a class="markdownIt-Anchor" href="#二分">#</a> 二分</h4>
<ul>
<li>找出 mid position</li>
<li>看数组的 mid position 的元素跟我们要找的一不一样
<ul>
<li>可以使用 <code>left + ((right - left) &gt;&gt; 1)</code>  防止溢出，移位也更高效</li>
</ul>
</li>
<li>要是要找的数字更大我们就去 mid+1 到 right 找回调自己继续找</li>
<li>要是要找的数字更小我们就去 left 到 mid-1 找回调自己继续找</li>
<li>所有操作要被 <code>left &lt; = right</code>  条件的 while 循环包括着，如果 left&gt;right 说明
<ul>
<li>比如说找到最后一个元素一比要是当前找的更大就往右找也就是 mid+1 到 right
<ul>
<li>因为当前是最后一个元素，说明 mid 算出来的就是他自己，此时要是 mid+1 然后还是那个 right 老值然后回调的话，收到的 left 就会比 right 更大，此时我们 return -1 说明二分到最后一个元素也不符合，所以没有要找的</li>
</ul>
</li>
<li>比如说找到最后一个元素一比要是当前找的更小就往左找也就是 left 到 mid-1
<ul>
<li>因为当前是最后一个元素，说明 mid 算出来的就是他自己，此时要是 mid-1 然后还是那个 left 老值然后回调的话，收到的 right 就会比 left 更小，此时我们 return -1 说明二分到最后一个元素也不符合，所以没有要找的</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* 注意：题目保证数组不为空，且 n 大于等于 1 ，以下问题默认相同 */</span>
<span class="token keyword">int</span> <span class="token class-name">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果这里是 int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：</span>
    <span class="token comment">// 1、下面循环的条件则是 while(left &lt; right)</span>
    <span class="token comment">// 2、循环内当 array[middle] > value 的时候，right = middle</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>  <span class="token comment">// 循环条件，适时而变</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 防止溢出，移位也更高效。同时，每次循环都需要更新。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span>
            right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span>
            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> middle<span class="token punctuation">;</span>
        <span class="token comment">// 可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多</span>
        <span class="token comment">// 如果每次循环都判断一下是否相等，将耗费时间</span>
    <span class="token punctuation">&#125;</span>
  
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>O (logN)-&gt; 因为比如说 N=16, 那最多要看 4 次，而 2<sup>4</sup>=16, 所以 log16=4, 所以 logN = 最多要看的次数</p>
</blockquote>
<p>一般是用于已经有序的数组但这不代表无序就不可以用了！！！</p>
<p>比如说数组中无序，邻近数字不相等，想找出任意一个局部最小的数字 -&gt; 局部最小指的是比左右元素 (如果有) 都要小的数字，也可以用二分查找，肯定会找到一个的，这比暴力 O (N) in this case 更快</p>
<blockquote>
<p>主要看情况，看适不适合</p>
</blockquote>
<hr>
<h3 id="一些数据结构"><a class="markdownIt-Anchor" href="#一些数据结构">#</a> 一些数据结构</h3>
<h4 id="堆"><a class="markdownIt-Anchor" href="#堆">#</a> 堆</h4>
<p>其实就是完全二叉树的结构，或者就是从左到右开始满的二叉树</p>
<p>用数组对应一个完全二叉树 (好像只是堆我们这么做，反正最上面 (数组第一个下标) 的放着我们最大的 / 最小的元素 -&gt; 大根堆，小根堆)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307141618205.png" alt="image-20220307141618205"></p>
<blockquote>
<p>这样因为是使用数组方式存的节点，所有对于每个下标为 i 的元素</p>
<ul>
<li>他的左孩子，如果不是 null, 就会在 i*2+1 下标</li>
<li>他的右孩子，如果不是 null, 就会在 i*2+2 下标</li>
<li>他的父亲，就会在 (i-1)/2 下标 —&gt; 如果是 root 也就是下标为 0 的，那么 (0-1)/2 照样还是 0, 还是他自己</li>
</ul>
</blockquote>
<hr>
<h4 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h4>
<blockquote>
<p>记住如果链表带有换头操作，那么返回值设为 head, 返回的就是最终答案的 head (好像和这个还有助于递归算什么东西)</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307200916870.png" alt="image-20220307200916870"></p>
<hr>
<h4 id="优先级队列和java的priority-queue"><a class="markdownIt-Anchor" href="#优先级队列和java的priority-queue">#</a> 优先级队列和 java 的 Priority Queue</h4>
<ul>
<li>优先级队列底层就是堆结构，堆顶就是优先级最大的</li>
<li>Java 里面的是 Priority Queue, 如果放的是数字，那么默认就是小根堆结构</li>
</ul>
<p>这个底部是数组模拟二叉树的堆结构，所以会有时候加多了，需要扩容，扩容好像就是当前大小 x2, 然后把旧数组里面的拷贝到新建的大数组里面到对应的位置</p>
<blockquote>
<p>一共加了 N 个数，经历了 logN 次，因为:</p>
<p>比如说 N=16</p>
<ul>
<li>我们加了两个数超了一下，扩容</li>
<li>我们加了四个数超了一下，扩容</li>
<li>我们加了八个数超了一下，扩容</li>
<li>我们加了 16 个数超了一下，扩容</li>
</ul>
<p>总共扩容了四次，也就是 logN 级别的 (log16=4)</p>
<p>而我们每次扩容的代价是 O (N) 时间复杂度的，所以所有的操作就会 O (NlogN),<strong> 也就是我们添加了 N 个元素的总代价就是 O (NlogN)</strong></p>
<p><strong>而我们想要的是平均下来，每添加一个数，会是多少时间复杂度，也就是 <code>O(NlogN)÷N</code> , 也就是平均下来，<mark> 每添加一个元素，即便考虑了扩容问题，也就是 O (logN) 的时间复杂度</mark></strong></p>
</blockquote>
<blockquote>
<p>所以扩容这个事，并不会影响__比如说让我们使用堆排序__最终的表现，以为我们每个元素的添加 /poll 形成的堆是 O (logN) 的时间复杂度的，这个扩容也是 O (logN) 的时间复杂度，所以并不会怎么影响我们 overall 时间复杂度的计算的</p>
</blockquote>
<p><strong>这个是人家 java 底层帮我们维持的堆结构，我们无法对堆结构里面的某一个元素进行改变然后 expecting it to 再次形成堆结构</strong>所以这个相当于是个不好的地方，我们自己创造堆结构的话可能会更 flexible 想改哪个改哪个，只不过之后自己要给那个调用 heapify 和 heap insert 让整个结构再次变成想要的堆结构</p>
<blockquote>
<p>他就是个黑盒，你给他一个又一个，他可以按照结构给你一个又一个，你无法直接改变黑盒里面的东西，就算可以改也会是代价比较高的 (因为要扫描每一个找到那个被改的，然后进行各种操作变回堆结构)</p>
</blockquote>
<hr>
<h4 id="哈希表hashmaphashset"><a class="markdownIt-Anchor" href="#哈希表hashmaphashset">#</a> 哈希表 (hashMap,hashSet)</h4>
<p>java 的 hashMap 和 hashSet 底层就是哈希表实现的</p>
<ul>
<li>hashmap/hashset 增删改查任何操作不管数据以及有了多少，都是常数操作 O (1), 比较大的常数 (比数组直接寻址要大得多)</li>
<li>treemap/treeset (有序表) 增删改查任何操作不管数据以及有了多少，都是 O (log (n))</li>
<li>注意要是往 treemap/treeset 里面放复杂数据类型或者自己定义的各种类型，需要你提供一个比较器，按照你定的规则来排序</li>
</ul>
<p>有序表！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220305165951234.png" alt="image-20220305165951234"></p>
<hr>
<h4 id="二叉树以及各种先中后序递归非递归遍历"><a class="markdownIt-Anchor" href="#二叉树以及各种先中后序递归非递归遍历">#</a> 二叉树以及各种 (先中后序) 递归，非递归遍历</h4>
<p>二叉树的先序、中序、后序遍历</p>
<p>先序:<strong><mark> 任何子树</mark>的处理顺序都是，先头节点、再左子树、然后右子树</strong></p>
<p>中序:<strong><mark> 任何子树</mark>的处理顺序都是，先左子树、再头节点、然后右子树</strong></p>
<p>后序:<strong><mark> 任何子树</mark>的处理顺序都是，先左子树、再右子树、然后头节点</strong></p>
<h5 id="递归序"><a class="markdownIt-Anchor" href="#递归序">#</a> 递归序</h5>
<p><strong>每个结点都会经过三次</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306191941761.png" alt="image-20220306191941761"></p>
<p>递归序:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306192222814.png" alt="image-20220306192222814"></p>
<blockquote>
<p>前序，第一次到达当前节点就打印</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220306191645537.png" alt="image-20220306191645537"></p>
<blockquote>
<p>中序，第二次到达当前节点就打印</p>
</blockquote>
<blockquote>
<p>后序，第三次到达当前节点就打印</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/843f0a6c2e24423e843a1ee5ab239b14.png" alt=""></p>
<h5 id="非递归遍历"><a class="markdownIt-Anchor" href="#非递归遍历">#</a> 非递归遍历</h5>
<h6 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历">#</a> 前序遍历</h6>
<p>准备一个栈，</p>
<ol>
<li>
<p>第一步__将非空根结点压栈__</p>
<p>出栈并打印</p>
</li>
<li>
<p><strong>先将刚刚那个出栈的节点的非空右子树结点压栈 (空了就不压呗)</strong></p>
</li>
<li>
<p><strong>后将刚刚那个出栈的节点的非空左子树结点压栈 (空了就不压呗)</strong></p>
<blockquote>
<p>还是先序，只不过非递归方式就是我们自己放入栈，要先把右边的压进去，再把左边的压进去</p>
</blockquote>
</li>
</ol>
<p>​	当前栈顶的节点出栈并打印</p>
<ol start="4">
<li>重复 2,3</li>
</ol>
<p>直到栈空了，说明所有的都出栈了 (这里出站顺序就是前序，我们可以做各种操作), 所有的都出栈了就一定是在所有节点 (每次循环栈 pop 出来的) 左孩子都已经压栈然后出栈或者就是空的，所有右孩子也都已经压栈然后出栈或者就是空的</p>
<h6 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历">#</a> 后序遍历</h6>
<p>两个栈，一个工具栈，一个收栈</p>
<ol>
<li>第一步__将非空根结点压栈__</li>
</ol>
<p>​	出这个栈，入收栈</p>
<ol start="2">
<li>
<p><strong>先将刚刚那个出栈的节点的非空左子树结点压栈 (空了就不压呗), 注意这里又是左边先了</strong></p>
</li>
<li>
<p><strong>后将刚刚那个出栈的节点的非空右子树结点压栈 (空了就不压呗)</strong></p>
</li>
</ol>
<p>​	出这个栈 (此时就是我们上面刚放的那个右孩子节点 (注意如果是空的话就不是这个了)), 入收栈</p>
<ol start="4">
<li>重复 2,3</li>
</ol>
<p>最后收栈的样子就是:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308004559534.png" alt="image-20220308004559534"></p>
<p>此时再将收栈的节点一个一个 pop 出，那么最后的顺序就是后续了！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308005443712.png" alt="image-20220308005443712"></p>
<blockquote>
<p>可以这么理解:</p>
<ul>
<li>我们压入工具栈又取出的顺序就是 --&gt; 头 右 左 (因为先压入然后先 pop 的头，然后先压入左边的又压入的右边的，然后 pop 的是先 pop 右边的再 pop 左边的)</li>
<li>把这个顺序一个一个压入收栈里面就是想要逆序呗  --&gt; 左 右 头 (__先压入头，再压入左，再压入右，所以最后取出的顺序就是 左 右 头 __<mark>也就是后序了！</mark>)</li>
</ul>
</blockquote>
<h6 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历">#</a> 中序遍历</h6>
<ol>
<li>第一步__将非空根结点压栈__</li>
<li>将当前栈里面的节点的左节点压栈，一直重复直到当前栈顶的那个节点没有左节点了</li>
</ol>
<blockquote>
<p><strong>第一次</strong>执行第二步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308010729006.png" alt="image-20220308010729006" style="zoom:33%;" />
</blockquote>
<ol start="3">
<li>pop, 打印 pop 出来的，再讲 pop 出来的右节点 **(如果不是空，如果没有右节点就不用管了，继续 pop 下一个栈顶然后打印然后看有没有右节点等等等)** 给压入栈中，然后对这个右节点 (可能代表的子树) 做第二步</li>
</ol>
<p>这就做到了让头先入栈，接着左边再入栈一直入到底，然后弹出左的 (因为此时弹出左的肯定是 leaf, 没有右节点), 我们就会回到对于那个弹出的左节点是头节点，然后这个会再弹出，然后看有没有右节点有的话就压栈，此时这个右节点又会去看自己有没有左节点压栈的，有的话就重复我们上面的 steps, 没有的话就弹出来，<strong> 所以我们最终打印 (或者可以在弹栈进行操作的顺序为–&gt; 左中右，就是中续！！！)</strong>. 对于每一个子树来说都是左头右的顺序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308012622316.png" alt="image-20220308012622316"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308013441803.png" alt="image-20220308013441803"></p>
<p>都是任何树先做再头，然后对于右边的先做再头，so on…</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308013651696.png" alt="image-20220308013651696"></p>
<blockquote>
<p>我们当前完全反过来，按照右边的为主，那么就会是右头左顺序了，<strong> 看自己什么需求</strong></p>
</blockquote>
<h5 id="二叉树的深度优先遍历"><a class="markdownIt-Anchor" href="#二叉树的深度优先遍历">#</a> 二叉树的深度优先遍历</h5>
<blockquote>
<p>其实就是二叉树的先序遍历，就同一回事</p>
</blockquote>
<h5 id="二叉树的宽度优先遍历"><a class="markdownIt-Anchor" href="#二叉树的宽度优先遍历">#</a> 二叉树的宽度优先遍历</h5>
<blockquote>
<p><strong>== 宽度遍历用队列！！！==</strong> 先进先出</p>
</blockquote>
<ol>
<li>
<p>首先头节点进去队列</p>
<p>然后出列，此时打印或者各种操作…</p>
</li>
<li>
<p>让当前出列的左节点 (如果有) 先入列</p>
</li>
<li>
<p>再让当前出列的右节点 (如果有) 再入列</p>
</li>
</ol>
<p>​	然后出列，此时打印或者各种操作…</p>
<ol start="4">
<li>重复 2,3</li>
</ol>
<p>就是按照宽度来的，一层一层打印</p>
<blockquote>
<p><strong><mark>java 里面 linkedList 就是双链表，双链表可以做队列的 (也可以用来做 stack, 看你用什么方法了), 所以可以直接用 linkedList 当队列用</mark></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308015354510.png" alt="image-20220308015354510"></p>
<hr>
<h4 id="图-3"><a class="markdownIt-Anchor" href="#图-3">#</a> 图</h4>
<p>adjacency list</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311020725233.png" alt="image-20220311020725233"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311020926275.png" alt="image-20220311020926275"></p>
<p>adjacency matrix</p>
<p>(直接带 weight 的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311021111926.png" alt="image-20220311021111926"></p>
<blockquote>
<p>矩阵中每一个值是按照 edge 来考虑的，有没有<strong> direct edge (两个点直接就有一个 edge 而不是比如说 B 导向 C 然后 C 导向 D)</strong></p>
</blockquote>
<p>其实图的代表方式很多，甚至可以用一个数组来代表</p>
<blockquote>
<p>我们可以对一种数据结构做所有图的算法，然后之后面试要是给我们不同数据结构代表的图，我们只需要 process 那个转化成我们想要的数据结构，然后传进去我们之前已经会的模板，就可以了</p>
</blockquote>
<p>左神用的:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311065737333.png" alt="image-20220311065737333"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311065851464.png" alt="image-20220311065851464"></p>
<p>比如说这个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311064340158.png" alt="image-20220311064340158"></p>
<ul>
<li>A 的 nexts 是 B 和 C</li>
<li>B 的 nexts 是 C</li>
<li>C 的 nexts 是 null</li>
</ul>
<blockquote>
<p>也就是我们当前这个节点属于我们自己的 edge 而且是往外指向的节点</p>
<p>我们那个节点存的 edge 属性则是那个当前节点<strong>往外指</strong>的所有 edges 本身，并不是那些 edges 指向的节点</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311065210153.png" alt="image-20220311065210153"></p>
<p>只要管 digraph 就足以，因为我们 graph 其实就是两面的 directed edges 互相指 (you get what i mean)</p>
<p>然后就是我们上面说到的接口函数转换成我们想要的结构:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311065956224.png" alt="image-20220311065956224"></p>
<blockquote>
<p><strong>左神的这种数据结构支持所有的 (大部分的) 算法</strong></p>
<p>如果有哪个算法并不需要某些值，比如说不需要 Nodes 的 nexts 属性什么的，那么直接不用设了那个就好了</p>
<p>只把我们需要的设置好，我们就可以使用这个结构弄那个算法，复杂度不会提高很高</p>
</blockquote>
<blockquote>
<p>图跟二叉树不一样，可能有环，所以遍历要考虑这个，不要陷入死循环</p>
<p>注意下面这个只是针对于这个 graph 里面连着的节点，要是那个节点没有连，或者是对于 digraph, 然后他的 in 是 0 我们还不从那个节点出发，也会忽略掉那个节点</p>
</blockquote>
<h5 id="图的宽度优先遍历"><a class="markdownIt-Anchor" href="#图的宽度优先遍历">#</a> 图的宽度优先遍历</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311072427437.png" alt="image-20220311072427437"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311151346159.png" alt="image-20220311151346159"></p>
<h5 id="图的广度优先遍历"><a class="markdownIt-Anchor" href="#图的广度优先遍历">#</a> 图的广度优先遍历</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311072431998.png" alt="image-20220311072431998"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311153011240.png" alt="image-20220311153011240"></p>
<blockquote>
<p>注意用栈然后这种方式，有一刻会让所有的节点都会存在于栈中，然后之后他们因为还没空所以还是会挨个 pop, 也就是反序了</p>
<p>不过不管我们事，看需求吧大部分。反正我们处理一个节点是那个节点加入到 set (第一次加入到 stack 里面去 (可能会被重复加入好几次)) 就处理。就是别忘了一开始的头节点一开始加入到 set/stack 也是需要处理</p>
</blockquote>
<hr>
<h4 id="前缀树"><a class="markdownIt-Anchor" href="#前缀树">#</a> 前缀树</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311200413953.png" alt="image-20220311200413953"></p>
<p>首先我们可以把数组中存的字符串挨个来看</p>
<ul>
<li>一般是用字符放到 edge 上然后 toNode 指向一个不是 null 的，也就是指向一个节点就行 (不过要是想把字符放到节点上也可以)</li>
<li>没有字符的道路那就建一个，如果有就复用等等等</li>
</ul>
<p>看以下数组形成的前缀树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311200556866.png" alt="image-20220311200556866" style="zoom:50%;" />
<blockquote>
<p>我们其实可以对那些节点做些自定义，让他存一些我们想要他存的信息</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311201042478.png" alt="image-20220311201042478"></p>
<p>比如说</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311201255675.png" alt="image-20220311201255675"></p>
<ul>
<li>一开始头节点，算是经过 pass 是 1,end 是 0,nexts 是一个数组，数组每个下标都是指向 null</li>
<li>接下来有了个 a 字符，我们看有没有 a 的路也就是我们头节点的 nexts 的下标为 0 指向的是不是 null</li>
<li>发现是 null 就会让那个改成不是 null-&gt; 而是让下标指向我们新建的一个节点</li>
<li>然后我们这个新建的节点就会是 pass 是 1 (p++ 了),end 是 0, 然后处理 b 等等…</li>
</ul>
<p>…</p>
<ul>
<li>到了最后 c 处理完了生成了一个新节点，发现当前这个字符串结束，那么就让我们这个新建的节点的 end++ 此时就是变成 1 (要是之后还有字符串最后在这节点结束，那么继续加加等等等)</li>
</ul>
<p>比如说一堆字符串，最后会是这样:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311202005813.png" style="zoom:50%;" />
<blockquote>
<p>此时比如说我们想要查这些里面有没有 &quot;bc&quot; 这个字符串</p>
</blockquote>
<ul>
<li>我们先按照上面的方式让他一个一个走 (不要改值啊！我们之前已经把前缀树建好了，我们只是找一个字符串在不在而已), 走 b 然后走 c 然后那个 c 指向的节点再看那个节点的 end 值是不是 0, 如果是 0 说明你之前加的字符换都没有 &quot;ab&quot;, 要是等于 x (不等于 0), 那就一定意味着之前已经加了 x 次这个字符串</li>
</ul>
<p>我们这样做代价很低，我们只要把一个前缀树建好了，然后再去找一个字符在不在我们的那个数组或者等等等里面 (which we took as input and made a 前缀树 for it), 他的代价只是查找的字符串的字符的数量，只要从头结点出发走过字符这个数量的距离就可以确定这个事</p>
<blockquote>
<p>你会发现这还不如用哈希表，还方便，其实这个前缀树还有更厉害的用处</p>
</blockquote>
<p>比如说：你想要找你之前加过的字符串，有多少个字符串是有 ab 作为前缀的？</p>
<ul>
<li>我们可以先从头节点出发，然后看有没有 a 的道，有的话就走</li>
<li>接着看有没有 b 的道有的话就走，走到的这个节点他的 pass 值就是我们之前所有加过的字符串前缀为 ab 的数量</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311203104282.png" alt="image-20220311203104282" style="zoom:50%;" />
<p><strong>注意头节点的 pass 属性就是当前前缀树存的字符串是以 &quot;&quot;(空字符串) 作为前缀的</strong></p>
<blockquote>
<p>这个哈希表就做不到，而我们的前缀树可以做到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311203842045.png" alt="image-20220311203842045"></p>
<blockquote>
<p>要是我们想要的不只是针对于 letters, 比如说任何可能的字符，那么我们可能需要一个一个 hashmap 来存 (nexts 属性) 信息，key 作为那个路 (也就是那个字符),value 作为那个路指向的节点，这样我们就不需要用数组 (元素一多就没法子了), 如果需要有序的还可以 treemap 等等等，都可以</p>
</blockquote>
<p>搜索前缀树有没有一个字符串，如果有的话，有几个:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312015825672.png" alt="image-20220312015825672"></p>
<p>搜索前缀树有没有一个字符串作为前缀，如果有的话，有几个:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312020008466.png" alt="image-20220312020008466"></p>
<p>删除前缀树中的存的所有字符串的其中一个:</p>
<ul>
<li>我们先看我们前缀树确实是有那个字符串 (用上面的那个方法看看返回值是不是不等于 0)</li>
<li>有的话我们再删，从头一个一个开始看，经过的节点都让 pass 值–, 然后让最后这个字符串结尾的那个节点的 end 值–就行了</li>
</ul>
<blockquote>
<p>如果我们删除的时候到了一个节点然后把他的 p 值–, 结果 p 变成了 0, 那么说明这个节点需要删掉，也就是上面那个的 nexts 数组里面的某个下标指向这个节点的指针应该指向 null 了，因为这个节点现在因为我们删除了那个字符串，导致了他的 pass 是 0 了说明就已经不会有任何字符串是通过他那里的，就算他后面还有节点，也都一样，不会有经过的了.</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312021048576.png" alt="image-20220312021048576"></p>
<hr>
<h3 id="master公式"><a class="markdownIt-Anchor" href="#master公式">#</a> Master 公式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307002908215.png" alt="image-20220307002908215"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307003049742.png" alt="image-20220307003049742"></p>
<hr>
<h3 id="排序数组等问题"><a class="markdownIt-Anchor" href="#排序数组等问题">#</a> 排序，数组等问题</h3>
<h4 id="找出数组范围最大值"><a class="markdownIt-Anchor" href="#找出数组范围最大值">#</a> 找出数组范围最大值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307002354464.png" alt="image-20220307002354464"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307002705864.png" alt="image-20220307002705864"></p>
<ul>
<li>O (logN) 时间复杂度 -&gt; 用 master 公式</li>
</ul>
<hr>
<h4 id="小和问题"><a class="markdownIt-Anchor" href="#小和问题">#</a> 小和问题</h4>
<p>就是你遍历数组，所有在当前元素左边且要比当前元素的数字相加就是当前元素的小和，算出每个元素的小和然后把他们相加</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307004911790.png" alt="image-20220307004911790"></p>
<p>整个数组的小和，在这例子里面是 0+1+4+1+10=16</p>
<blockquote>
<p><strong>这个我们可以在使用归并排序的同时，多做些操作，计算出来答案</strong></p>
</blockquote>
<p>我们换种想法，每个元素，他的右边有几个比自己大，比如说上面例子</p>
<ul>
<li>第一个元素是 1, 然后看右边有 4 个元素比自己大，所以我们需要 4 个 1</li>
<li>第二个元素是 3, 然后看右边有 2 个元素比自己大，所以我们需要 2 个 3</li>
<li>第三个元素是 4, 然后看右边有 1 个元素比自己大，所以我们需要 1 个 4</li>
<li>第四个元素是 2, 然后看右边有 1 个元素比自己大，所以我们需要 1 个 2</li>
<li>第五个元素是 5, 然后看右边有 0 个元素，所以我们需要 0 个 5</li>
</ul>
<p>所以最后 4*1 + 2*3 + 1*4 + 1*2 = 16, 所以一样的</p>
<blockquote>
<p>所以每次 merge 执行的时候，如果左边的要比右边的___要小___(注意 等于 不算！) 的话，就代表产生了小和，也就是当前左边这个值.<strong><mark> 如果右边的这个数组是多个元素，那如果右边第一个比当前左边的这个元素要大，右边数组后面所有的元素都大，我们可以用右边数组下标快速地 (<em>其实这个就是更快的原因，直接就找到了多少个元素更大，而不是一个一个比</em>) 计算出有多少个比他大的然后小和值就增加比他大的那个靠下标快速算出来的数量 * 当前左边这个更小的值</mark></strong></p>
</blockquote>
<blockquote>
<p><strong>== 但是注意！！！这个 merge 过程跟我们之前的 merge 过程有点不一样 ==</strong></p>
<p>在这里，<strong> 我们如果左边和右边数组当前数是相等的</strong>，我们不会先放左边的，而是先放右边的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307011747924.png" alt="image-20220307011747924"></p>
<p><mark>注意，正因为我们这里如果相等是先放了右边的，我们破坏了 merge sort 的稳定性，merge sort 在 O (logN) 的比较排序里面最有特色的就是他的稳定性，其他的都不怎么样 (比如说空间复杂度是 O (N), 是 O (logN) 的比较排序里面最大的)</mark></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307012301273.png" alt="image-20220307012301273"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307012355067.png" alt="image-20220307012355067"></p>
<p>当然需要本身的排序也是实实在在的需要的，要是不排序那就不对了，比如说右组必须是排序的我们才可以用下标快速的算出有多少个比元素更大的 -&gt;(下标快速算就是 O (1) 啊)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307010619437.png" alt="image-20220307010619437"></p>
<p><strong><mark>每个小和都是没有遗漏的，分批的，没有重复的</mark></strong></p>
<ul>
<li>不遗漏 -&gt; 因为 merge 过程中，是一定会把某一个数右侧范围扩到一个整体的</li>
<li>不重复 -&gt; 因为已经变成一个部分的东西，在这个东西内部是不重复产生小和的，只是左组跟右组 merge 的过程中，因为左组的数比右组的小，才会产生小和，所以不重算</li>
</ul>
<p>因为这个差不多就是 merge sort, 所以时间复杂度就是 O (NlogN)</p>
<hr>
<h4 id="逆序队问题"><a class="markdownIt-Anchor" href="#逆序队问题">#</a> 逆序队问题</h4>
<p>比如说:</p>
<p>[3,2,4,5,0] -&gt; 3,0 是个逆序队  3,2 是个逆序队  4,0 是个逆序队 etc…</p>
<p><strong>计算总共有多少个逆序队</strong></p>
<blockquote>
<p>使用归并排序</p>
<ul>
<li>每次 merge 我们都看，左边当前元素是不是比右边的要大
<ul>
<li>如果大，直接用下标方式快速算出多少个大的</li>
<li>如果小__或者等于__, 就直接左边的这个，然后看左边的下一个元素进行比较，…</li>
</ul>
</li>
</ul>
<p><strong><mark>不难看出，跟小和问题贼像，只不过反过来了，而且没那么复杂了</mark></strong></p>
</blockquote>
<p>** 多想想像这种类似于 combination 的题，他问的不是 combination 哈，反正总是试试看 merge sort 能不能行，merge sort 就是可以快速找出左边和右边的某种区别 (一般是大于，小于这些的), 然后要是我们平常需要一个一个比，但是因为 merge sort 确保每次 merge 两边都已经是有序的，我们可以非常迅速靠着下标算出有多个匹配的！！！**</p>
<hr>
<h4 id="荷兰国旗问题"><a class="markdownIt-Anchor" href="#荷兰国旗问题">#</a> 荷兰国旗问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307014134284.png" alt="image-20220307014134284"></p>
<blockquote>
<p>很简单</p>
<ul>
<li>遍历我们数组，下标 i 一开始是 0</li>
<li>有个小于区域和大于区域 (<strong>如果只想要小于一个数的在左边，其他随便就不需要大于区域，大于区域是为了把大于那个数的放到右边，这样既有小于区域和大于区域，那么如果有和那个数一样的，那么会出现在中间左右的位置</strong>)</li>
<li>如果当前元素 &lt;那个数，把当前元素跟小于区域下一个元素互换，小于区域往前走一步 (用下标比如说 j++),i++</li>
<li>如果当前元素 = 那个数，直接跳过让 i++</li>
<li>如果当前元素 &gt; 那个数，把当前元素跟大于区域上一个元素互换，大于区域往前走一步 (用下标比如说 k–),i__不变！__</li>
<li><em><strong>当 i 和 k 的值一样了，说明都处理完了</strong></em>，结束，完成！</li>
</ul>
</blockquote>
<p>如果只想要小于等于的放在左边，大于的放到右边的规则:</p>
<ul>
<li>如果当前元素 &lt;= 那个数，把当前元素跟小于等于区域下一个元素互换，小于等于区域往前走一步 (用下标比如说 j++),i++</li>
<li>如果当前元素 &gt; 那个数，直接跳过让 i++</li>
</ul>
<p><mark>这就跟双指针一样的</mark></p>
<hr>
<h4 id="排序一个几乎有序的数组"><a class="markdownIt-Anchor" href="#排序一个几乎有序的数组">#</a> 排序一个几乎有序的数组</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307155507076.png" alt="image-20220307155507076"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307164619260.png" alt="image-20220307164619260"></p>
<p>** 使用堆排序！！！**</p>
<ul>
<li>首先我们有个数组，然后一个 k 值</li>
<li>我们首先把下标从 0 到 k 的所有数字放到一个小根堆 (这里使用小根堆是为了方便，因为我们取的就是从 0 下标开始的一些数字) 里面，这样我们就有了这个范围的小根堆，我们知道数组最小的数字肯定是在这里，因为最多不会超过 k, 不会出现在超过那个范围的！</li>
<li>我们接着取出堆顶也就是数组最小值把它放入数组下标为 0 的位置，注意我们小跟堆需要把那个堆顶 pop 掉！！！</li>
<li>我们再从数组的 k+1 下标的位置取出一个放入到小根堆，然后让那个 heap insert 或者什么什么的再次形成小跟堆</li>
<li>此时我们再取出堆顶也就是数组第二个最小的放入到数组下标为 1 的位置，注意我们小跟堆需要把那个堆顶 pop 掉！！！</li>
<li>so on…</li>
<li>直到我们数组取不出元素了，到头了，我们就让现在的小根堆 pop 完后那个样子自己形成小根堆，然后取堆顶等等等就行了</li>
<li>最后我们数组都是有序了</li>
</ul>
<p>我们小根堆每次只处理 k+1 个数，所以每次每一个元素 heapify 形成一个新的小根堆，其实就是 O (logk) 左右的时间复杂度</p>
<p>我们数组有 N 个元素，每个元素都要被放到小跟堆进行 heapify/heap insert, 也就是总共就共__O (NlogN) 的时间复杂度__</p>
<p>所以如果 k 的值很小，我们这个甚至就跟 O (N) 差不多了！所以堆排序很适合这个问题！！！</p>
<blockquote>
<p>学到了 堆结构很管用！！！任何合适的都可以，任何想要我们选择某一个数，然后是按照某种跟其他的比较的规则，比如说比其他的都小 / 都大都可以！！！</p>
</blockquote>
<blockquote>
<p>注意我们可以用自己自定义的类的实例按照他们的属性的值来进行这个堆结构然后堆排序都可以，很自定义，很不错！</p>
</blockquote>
<hr>
<h3 id="比较器和java底层的排序操作"><a class="markdownIt-Anchor" href="#比较器和java底层的排序操作">#</a> 比较器和 java 底层的排序操作</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220305152440660.png" alt="image-20220305152440660"></p>
<p>就是一般:</p>
<ul>
<li>return 第一个参数 - 第二个参数，那么就是从小到大排 (貌似)</li>
<li>return 第二个参数 - 第一个参数，那么就是从大到小排 (貌似)</li>
</ul>
<blockquote>
<ul>
<li>java 的 priority queue 直接用默认是小根堆，要是想要大根堆就要创建个类实现 comparator 接口重写 compare 方法并把那个类实例化传给 priority queue 的构造函数才可以实现实例化出来的 priority queue 是别样的，比如说大根堆，或者我们那个 priority queue 放我们自定义的类，也可以按照我们的某个属性 (我们定的规则) 来吧对应的放到堆顶</li>
<li>就是如果那个 compare 方法返回正数代表第一个参数 (或者那个类的某个属性的值等等等) 在顶堆，返回负数第一个参数放上面等等等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220305153252969.png" alt="image-20220305153252969"></p>
<p>大根堆就是第二个减第一个参数就行了，如果是正数说明会把第二个放到堆顶，第二个数更大，所以放堆顶是大根堆</p>
</blockquote>
<blockquote>
<p>还可以自己自定义各种复杂的比较策略</p>
</blockquote>
<p><strong><mark>java 底层的排序操作:</mark></strong></p>
<p><strong>size 大于 60 时 使用 merge 和 quick 进行综合排序，如果小于 60，系统默认使用插入排序以求最快速度完成。</strong></p>
<p><strong>自己定义的 class 类型排序时，会使用 merge 排序，<mark> 为什么？？？原因当然是稳定性，自己定义的类型一般会想要稳定性的，快排又做不到稳定性</mark>。</strong></p>
<blockquote>
<p>这是因为小样本量的时候，N 平方没那么起的快，反之插入排序的常数系数啥的更低，所以小样本量的时候用这些 N 平方更快一些些，按照情况使用不同排序的优点</p>
</blockquote>
<p><mark><strong>比如说</strong></mark></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220305163759596.png" alt="image-20220305163759596"></p>
<hr>
<h3 id="链表问题"><a class="markdownIt-Anchor" href="#链表问题">#</a> 链表问题</h3>
<h4 id="找出两个有序链表共同值的节点"><a class="markdownIt-Anchor" href="#找出两个有序链表共同值的节点">#</a> 找出两个有序链表共同值的节点</h4>
<ul>
<li>一个指针指向第一个链表头，另外一个指向第二个链表头</li>
<li>比大小，谁更小谁移动到下一个</li>
<li>如果遇到一样的，记录那个一样的，然后共同移动 (两个都往下一个移，说不定还有一样的)</li>
<li>任何一个链表到头了，结束</li>
</ul>
<hr>
<h4 id="两个链表是否有回文结构"><a class="markdownIt-Anchor" href="#两个链表是否有回文结构">#</a> 两个链表是否有回文结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307201025237.png" alt="image-20220307201025237"></p>
<p><strong>使用额外空间方式:</strong></p>
<ul>
<li>把每一个元素放入栈里面</li>
<li>从栈取出的顺序就是链表的逆序，我们边弹出边比较一不一样，如果回文结构一定一样，所以直到栈弹空要是还是都一样那么就回文</li>
<li>如果有一步不一样，就不是回文</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307205122227.png" alt="image-20220307205122227"></p>
<p><strong>稍微再省一些空间的方法:</strong></p>
<ul>
<li>把链表右边的放在栈里面，然后再跟链表前一半比</li>
<li>栈只要弹空了就停</li>
<li>因为要是是回文结构，不管链表有的元素是不是偶数或者奇数个，反正比了左边和右边就会是一样的，就算是奇数个也不会 reach 到中间那个</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307201524347.png" alt="image-20220307201524347"></p>
<p>但是我们怎么做到只把右边的放入栈？</p>
<p><strong>快慢指针！</strong></p>
<ul>
<li>快指针比如说一次走两步</li>
<li>慢指针比如说一次走两步</li>
<li>这样最后快指针最后指向最后一个，慢指针差不多指到中间位置</li>
</ul>
<blockquote>
<p>这些快慢指针可以自己任何定制，按照自己想要的方式实现</p>
</blockquote>
<p>我们想要</p>
<ul>
<li>如果链表奇数个节点，我们慢指针指向中间那个</li>
<li>如果链表偶数个节点，我们慢指针指向中间的左边那个</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307205206835.png" alt="image-20220307205206835"></p>
<p><strong>超级省空间的方法 (面试做的时候很加分):</strong></p>
<ul>
<li>快慢指针，最后让慢指针指向差不多中间位置</li>
<li>中间那个节点的 next 指向 null</li>
<li>然后让那个节点后面的节点都逆序</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307202617632.png" alt="image-20220307202617632"></p>
<p>然后再 A 指针和 B 指针挨个比，一样的话就一块走下一个，如果有一个不一样就返回 false</p>
<p><strong>一直到最后有任何一个为空 (null), 就停止，就说明最终结果就是回文结构</strong></p>
<p><strong><mark>注意如果最后返回 true 的话，有时候需要把链表的指向恢复一下，看需求吧</mark></strong></p>
<blockquote>
<p>这个对于偶数次的节点的链表也可以！自己想象一下！</p>
</blockquote>
<p>这个方法就有限几个变量，最省空间的！！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307211039758.png" alt="image-20220307211039758"></p>
<hr>
<h4 id="逆序链表"><a class="markdownIt-Anchor" href="#逆序链表">#</a> 逆序链表</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307204941850.png" alt=""></p>
<blockquote>
<p>还有什么递归方式等等等</p>
</blockquote>
<hr>
<h4 id="单链表按某值划分左边小中间相等右边大的形式"><a class="markdownIt-Anchor" href="#单链表按某值划分左边小中间相等右边大的形式">#</a> 单链表按某值划分左边小，中间相等，右边大的形式</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307211223805.png" alt="image-20220307211223805"></p>
<p><strong>笔试里面做法:</strong></p>
<p>把链表里面的数放到__Node 类型的__数组里面去，然后对数组玩 partition, 然后再把数组里面的数放回链表就行了</p>
<p><strong>面试里面做法 (省空间！):</strong></p>
<blockquote>
<p>有很多类似于这种的问题，要多想想类似的看看这个解法适不适用</p>
</blockquote>
<p>有些复杂我们用一个例子来讲解答案:</p>
<p>链表:<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307212234294.png" alt="image-20220307212234294"></p>
<p><strong>对于划分的值是⑤</strong></p>
<p>需要六个变量:</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>等于什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>SH (一开始是 null)</td>
<td>小于部分的头</td>
</tr>
<tr>
<td>ST (一开始是 null)</td>
<td>小于部分的尾</td>
</tr>
<tr>
<td>EH (一开始是 null)</td>
<td>等于部分的头</td>
</tr>
<tr>
<td>ET (一开始是 null)</td>
<td>等于部分的尾</td>
</tr>
<tr>
<td>BH (一开始是 null)</td>
<td>大于部分的头</td>
</tr>
<tr>
<td>BT (一开始是 null)</td>
<td>大于部分的尾</td>
</tr>
</tbody>
</table>
<ul>
<li>首先第一个节点④, 发现比我们的⑤小，所以让 SH 和 ST④</li>
<li>下一个节点⑥, 发现比我们的⑤大，所以让 BH 和 BT⑥</li>
<li>下一个节点③, 发现比我们的⑤小，所以让 ST 当前指向的节点④指向③, 然后让 ST 指向③(SH 不要动之后只有是一开始 null 的时候才会被第一个更新)</li>
<li>下一个节点⑤, 发现跟我们的⑤相等，所以让 EH 和 ET 都指向这个当前找到的⑤!!!<strong> 需要这个，因为可能有多个，我们要串起来所有相等的，然后让头代表第一个，尾代表最后一个 (<mark>可以看出是稳定的，保持了顺序，小于区域和大于区域都是同理</mark>)</strong></li>
<li>等等等</li>
<li>最后就是:</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307214130524.png" alt="image-20220307214130524"></p>
<ul>
<li>ST 的当前指向的节点的 next 指向 EH</li>
<li>ET 的当前指向的节点的 next 指向 BH</li>
</ul>
<p>== 不过注意！！！== 可能压根没有小于区域，可能压根没有等于区域，可能压根没有大于区域！！！</p>
<blockquote>
<p>所以只有不是 null 的时候才可以调用 next 连，如果有一个是 null, 需要连下一个区域等等等</p>
</blockquote>
<p>完成，结束！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307214548685.png" alt="image-20220307214548685"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307214635184.png" alt="image-20220307214635184"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307214724787.png" alt="image-20220307214724787"></p>
<blockquote>
<p>我们相当于用很多指针 (基本上就是两个指针一个头一个尾代表一个区域，然后可能有多个这种对子), 然后<strong>我们就可以按照我们想来的规则</strong>把代表不同区域的指针头和尾指向不同节点 (期间需要如果那个区域的尾指针要换成别的，就让当前的尾指针 (<strong>如果不是 null</strong>) 的 next 指向新的那个，这样才能全部最终正确得串起来)</p>
<p>说到底就是那个链表，我们只是对节点的 next 改变就可以做很多事请</p>
</blockquote>
<hr>
<h4 id="复制含有随机指针的链表"><a class="markdownIt-Anchor" href="#复制含有随机指针的链表">#</a> 复制含有随机指针的链表</h4>
<p>比如说:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307215220898.png" alt="image-20220307215220898"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307215205411.png" alt="image-20220307215205411"></p>
<p><strong>使用比较多额外空间方式:</strong></p>
<p>哈希表！HashMap!</p>
<ul>
<li>遍历原来的链表，我们只需要把原来的链表的节点 (的指针) 和对应的新链表的新建的节点 (的指针) 作为 key 和 value 存入 hashMap</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307215516386.png" alt="image-20220307215516386"></p>
<ul>
<li>遍历老链表，或者遍历哈希表</li>
<li>对于每一个哈希表里面的值也就是新链表的节点的指针，我们让他的 next 指向这个新节点对应的 key (也就是老节点的指针) 的 next<strong> 指向的节点在哈希表里面对应的值</strong>，然后让他的 rand 指向这个新节点对应的 key (也就是老节点的指针) 的 rand<strong> 指向的节点在哈希表里面对应的值</strong>，就可以了</li>
</ul>
<blockquote>
<p>我们产生了一个 mapping (自己造的次) 相当于，就大概理念就这样！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307220130558.png" alt="image-20220307220130558"></p>
<p><strong>不使用比较多额外空间方式:</strong></p>
<ul>
<li>生成一个个新节点，但是我们让他们跟老链表的节点这么串起来</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307220404585.png" alt="image-20220307220404585"></p>
<ul>
<li><strong>我们让每一个新生成的节点的 rand 指针指向当前这个新节点对应的老节点的 rand 指向的节点的 next</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307220730899.png" alt="image-20220307220730899"></p>
<blockquote>
<p>反正这种想法就是让老的节点和旧的产生连接，这样我们就可以按照老节点的方式连的连我们自己的这个新节点，毕竟我们想要的是复制嘛，肯定是照着来啊</p>
</blockquote>
<ul>
<li>这么做后，就会成这样:</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307220742783.png" alt="image-20220307220742783"></p>
<ul>
<li>接着就把 next 改变，让新链表从这里分离出来</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307221255136.png" alt="image-20220307221255136"></p>
<p>​</p>
<p>​             <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307221515163.png" alt="image-20220307221515163"></p>
<hr>
<h4 id="一个链表是否有环如果有怎么找到入环点"><a class="markdownIt-Anchor" href="#一个链表是否有环如果有怎么找到入环点">#</a> 一个链表是否有环，如果有怎么找到入环点</h4>
<p>一个有环的链表，和他的入环节点:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307222020533.png" alt="image-20220307222020533"></p>
<blockquote>
<p>可以发现有环的最终不会指向 null, 所以最后要是走到了 null, 说明肯定没有环</p>
</blockquote>
<p><strong>使用 HashSet 方式很容易:</strong></p>
<ul>
<li>每个节点 (存节点的 HashSet, 不是节点的值！！) 存入哈希表之前先看看是不是已经有了，如果没有才存，如果有说明有环</li>
</ul>
<p><strong>不适用那么多额外空间的方式:</strong></p>
<p><mark><em>* 快慢指针！！！</em>*</mark></p>
<blockquote>
<p>链表好多都是快慢指针和哈希表解法啊</p>
</blockquote>
<ul>
<li>两个指针方法，快指针慢指针</li>
<li>如果一个链表有环 (说明最终不会指向 null)</li>
<li>那么快指针一下走两步，满指针一下走一步</li>
<li>他们肯定会在有环的部分相遇的！<span class="spoiler" title="..."> 并且满指针和快指针在环中转的圈数不会大于两次以上</span>！！！</li>
<li>这个时候！接着让快指针指向 head, 然后跟慢指针一样一步一步走，直到他们相遇，他们相遇的那个节点一定是链表入环的节点！！！</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307223548687.png" alt=""></p>
<hr>
<h4 id="两个单链表相交"><a class="markdownIt-Anchor" href="#两个单链表相交">#</a> 两个单链表相交</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307221623172.png" alt="image-20220307221623172"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307231852899.png" alt="image-20220307231852899"></p>
<h5 id="如果两条链表都无环"><a class="markdownIt-Anchor" href="#如果两条链表都无环">#</a> 如果两条链表都无环</h5>
<p><strong>用 set 方式:</strong></p>
<p>第一条链表节点都入 set，第二条链表查，查到重复即为相交节点</p>
<p><strong>不用 set:</strong></p>
<ul>
<li>遍历第一条链表，记录最后一个节点，且记录链表长度  （长度记作 x）</li>
<li>遍历第二条链表，记录最后一个节点，且记录链表长度 （长度记作 y）</li>
<li><strong>如果两个<mark>最后</mark>节点不同</strong>，则不相交 —&gt; 如果相交最后一个节点肯定会是一样的</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220305185328234.png" alt="image-20220305185328234"></p>
<ul>
<li><strong>如果最后一个节点是一样的，那么</strong> x 与 y 大的先开始走， 走 x-y 步 (<mark>如果相交，那么共享的部分肯定不会出现在那个 x-y 步里面，因为后面的长度都会是共享的部分，细品，细细品</mark>)</li>
<li><strong>然后那个长的那个走完 x-y 步后，两条链表一起走，某一刻肯定会在<mark>相交的节点</mark>相遇</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307230020238.png" alt="image-20220307230020238"></p>
<h5 id="如果一条链表无环一条节点无环"><a class="markdownIt-Anchor" href="#如果一条链表无环一条节点无环">#</a> 如果一条链表无环一条节点无环</h5>
<blockquote>
<p>这种情况绝对不会发生，因为只有 next 一个指针，只能最终指向一个方向</p>
</blockquote>
<h5 id="两个都有环"><a class="markdownIt-Anchor" href="#两个都有环">#</a> 两个都有环</h5>
<blockquote>
<p>如果两个有环链表相交，那他们一定是共用这个环</p>
</blockquote>
<p><strong>一共有三种情况</strong></p>
<ol>
<li>两个有环但是不相交</li>
<li>两个有环且相交点是同一个</li>
<li>两个有环且是靠着环来相交的 (<strong>这里我们认为任何一个链表的入环点就是相交点</strong>)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/4c274bb024e443e2bb628ae36b27ad4c.png" alt=""></p>
<ul>
<li>
<p>如果 loop1 (第一个链表的入环点) 的内存地址等于 loop2 (第二个链表的入环点) 的内存地址 -&gt; 则为第二种情况 (两个入环节点一样)</p>
<ul>
<li>那我们就用无环的方式就行了，差不太多的</li>
</ul>
</li>
<li>
<p>如果 loop 1 不等于 loop 2</p>
<ul>
<li>让 loop1 沿着环走，如果没有遇到 loop2 则为第一种情况，也就是没有相交</li>
<li>如果遇到了 loop2 就是第三种情况 (两个入环节点不一样)</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220307231240997.png" alt="image-20220307231240997"></p>
<blockquote>
<ul>
<li>无非就是有了两个头节点和两个链表的入环节点</li>
<li>如果入环节点一样，说明是第二种情况，就按照我们无环的做法一样就行，长的先走 x-y 步，然后两个一起一块走，一直走到一样的说明找到了相交点 (<em>* 这个不一定他们的入环点，因为可能入环点之前就相交了，参考第二种情况的图片！！！</em>*)</li>
<li>如果如环节点不一样，我们就 while loop 让那个 loop1 入环节点走一圈，如果这一圈没遇到和另外一个 loop2 入换节点，说明是情况 1, 如果遇到了一样的说明是情况 3-&gt; 返回 loop1 或者 loop2 都行，都叫做第一个相交的节点</li>
</ul>
</blockquote>
<hr>
<h4 id="能不能不给单链表的头节点只给想要删除的节点就能做到在链表上把这个点删掉"><a class="markdownIt-Anchor" href="#能不能不给单链表的头节点只给想要删除的节点就能做到在链表上把这个点删掉">#</a> 能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</h4>
<p>抖机灵</p>
<ul>
<li>将删除节点的下一个结点的值赋值给删除节点</li>
<li>然后将删除节点的 next 指向下一个节点的下一个节点</li>
<li>然后删除下一个节点就行了</li>
</ul>
<blockquote>
<p><strong><mark>注意这个不能删除最后一个节点</mark></strong></p>
</blockquote>
<hr>
<h3 id="二叉树问题"><a class="markdownIt-Anchor" href="#二叉树问题">#</a> 二叉树问题</h3>
<h4 id="求一个二叉树的最大宽度"><a class="markdownIt-Anchor" href="#求一个二叉树的最大宽度">#</a> 求一个二叉树的最大宽度</h4>
<p>比如说:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308015607000.png" alt="image-20220308015607000"></p>
<blockquote>
<p>我们只需要在宽度遍历的时候能知道当前的节点是第几层就能开始计数了</p>
</blockquote>
<p>使用 hashMap!</p>
<blockquote>
<p>下面的听个大概意思就行，不需要死记硬背</p>
</blockquote>
<ul>
<li>一开始我们把那个头节点插入到队列中，我们也 put 一个 key 为那个头节点然后 value 为 1 (代表第 1 层) 到 hashMap 里面去</li>
<li>到了我们循环里面，每次我们让一个节点出列，我们就靠这个节点来查 hashMap 里面对应的 value, 也就是那个出列的节点的值
<ul>
<li>如果取出的值跟我们当前操作的层次 (一开始设置为了 1) 一样，那么就说明当前是同一层的节点，我们就让保存那一层节点数量的变量 ++</li>
<li>如果取出的值跟我们当前操作的层次 (一开始设置为了 1) 不一样，那么就说明当前是下一层的节点，说明上一层我们那个那一层节点数量的变量已经是计算完了那一层的数量
<ul>
<li>我们就需要计算看这个跟我们当前用变量 max (一开始设置为了数字最小值) 比，如果更大，就要更新 max 值</li>
<li>并且我们还需要把那个当前层数的变量 ++</li>
<li>然后清空当前层一共多少节点的那个变量设置为 1 (因为当前就是这一层的节点，所以发现了一个)</li>
</ul>
</li>
</ul>
</li>
<li>然后就是之前的宽度遍历部分先让非空左节点的进队列
<ul>
<li>我们把这个非空左节点作为 key 存入 hashmap, 他的 value 就是当前保存层数的变量 + 1</li>
</ul>
</li>
<li>再让非空右节点的进队列
<ul>
<li>我们把这个非空右节点作为 key 存入 hashmap, 他的 value 就是当前保存层数的变量 + 1</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220308021804991.png" alt="image-20220308021510226"></p>
<blockquote>
<p><strong>上面代码有点 bug, 比如说出列最后一个节点时，可能会没有到 Math.max (那里比较), 也就是没有比较最后一层</strong></p>
</blockquote>
<hr>
<h4 id="如何判断一颗二叉树是否是搜索二叉树"><a class="markdownIt-Anchor" href="#如何判断一颗二叉树是否是搜索二叉树">#</a> 如何判断一颗二叉树是否是搜索二叉树</h4>
<blockquote>
<p>搜索二叉树就是每一颗子树，他的左孩子都要比头小，他的右孩子都要比头大</p>
<p>经典的搜索二叉树没有重复的</p>
</blockquote>
<p><strong>答案:</strong></p>
<p>我们直接使用中序递归–&gt; 左中右，如果是搜索二叉树，那么最后中序递归出来的顺序一定是<strong>升序</strong>的</p>
<p>如果某个点不是升序的，那就不是搜索二叉树</p>
<p><strong>递归方法:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310130318621.png" alt="image-20220310130318621"></p>
<blockquote>
<p>递归的想法就是把问题缩小到你最关心的大小上，比如说这里最主要的是每一个节点 (mergesort 最小的就是两个连着的元素，等等等), 然后这里这个可能不是最小的，比如说 leaf 也是一个节点，但他的左孩子和右孩子是 null, 我们一般不会用到 null 做什么处理，就测如果 head==null 那就怎么怎么样直接返回等或者返回 true/false. 这样就足够了，因为回调自己的 null 左 / 右子节点都会遇到这个。接着就是在合适的顺序，处理那个那个你关心的最小单位，爱这里处理你只要关心你那关心的节点就好了 (可能一个，可能两个，等等等), 当然他们的结果可能是当前回调自己参数传进来的，可能是来自之前回调自己的结果等等等，反正你可能会有多个自己的调用，顺序很重要，返回值也重要！</p>
<p>我们把关心的那个范围的节点处理好了，我们只要保证其他节点 (或其他) 都要经过我们设置的操作就行，如果是返回什么值，一定要注意所有可能性，有没有需要多些 if 看看情况等等</p>
</blockquote>
<blockquote>
<p>就是我们左边子树需要先判断，也就是一直到左节点，这里我们再跟我们那个比较逻辑比，然后返回上一层，上一层会调用右边的逻辑也是那一层的 head 比 (还没必过！) 然后让右子树也这么做，要是都对了返回 true 到他的上一层，到了这一层又要拿那一层的 head 跟那个比，然后右子树也这么做 (因为还没处理过).</p>
<p>但是我们如果这整个有哪个返回 false, 我们直接作为上一层的左子树调用，返回了 false, 然后我们那个一层还没判断这个左边的是不是 false 就直接拿他的一层的 head 比较，万一比过了，那就是 true 了，明明他的左子树没有符合，但他这一层却把整个他所代表的他自己 (head) 和他子树的结果返回为 true 了，这肯定不对！！！我们要先测左边的对不对，要是不对，直接让这个一整层就返回 false,head 也不用比了，右子树也不用比了，直接一直返回到一开始的 (栈底) 的那个一层然后直接返回 false 作为整个方法的结果.</p>
</blockquote>
<p>比较费空间的写法:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310130906923.png" alt="image-20220310130906923"></p>
<p>然后再主函数调用这个方法传参数，接着我们只要对那个传进去的 list 在这个方法结束后遍历一下，看看是不是升序的就行了</p>
<p><strong>非递归方法:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310132549681.png" alt="image-20220310132549681"></p>
<blockquote>
<p>同理：我们当然可以做到–&gt; 后头左，这个样子的中序，看你什么需求了</p>
</blockquote>
<hr>
<h4 id="如何判断一颗二叉树是否是完全二叉树"><a class="markdownIt-Anchor" href="#如何判断一颗二叉树是否是完全二叉树">#</a> 如何判断一颗二叉树是否是完全二叉树</h4>
<blockquote>
<p>完全二叉树就是要么全满，要么左边往右填，右边的还没满</p>
</blockquote>
<p>答案: <strong>使用宽度遍历！</strong></p>
<ol>
<li>遇到的每一个节点，如果这个节点有右孩子没有左孩子，直接返回 false</li>
<li>在第一个条件不违规的情况下，如果遇到的第一个节点他要么只有左孩子，或者两个都没有 (复合第一个条件), 那么之后的<strong>所有节点都必须是叶节点</strong>，如果不是则返回 false, 如果都是返回 true</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310133426286.png" alt="image-20220310133426286"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310134254554.png" alt="image-20220310134035901"></p>
<hr>
<h4 id="如何判断一颗二叉树是否是满二叉树"><a class="markdownIt-Anchor" href="#如何判断一颗二叉树是否是满二叉树">#</a> 如何判断一颗二叉树是否是满二叉树</h4>
<p>麻烦但好理解的做法:</p>
<ul>
<li>有个函数统计这个树的最大深度 (D)</li>
<li>有个函数统计这个树的节点个数 (N)</li>
</ul>
<blockquote>
<p>满二叉树一定符合 <strong>N = 2<sup>D</sup>-1</strong></p>
</blockquote>
<hr>
<h4 id="如何判断一颗二叉树是否是平衡二叉树以及树型dp套路介绍️重要"><a class="markdownIt-Anchor" href="#如何判断一颗二叉树是否是平衡二叉树以及树型dp套路介绍️重要">#</a> 如何判断一颗二叉树是否是平衡二叉树 (以及树型 dp 套路介绍⭐️重要！！！)</h4>
<blockquote>
<p><strong><mark>这里就可以说到了二叉树题目 (判断是不是满二叉树，是不是搜索二叉树等等等) 的套路！注意这里的逻辑，很重要！以后遇到问题这么来没差</mark></strong></p>
</blockquote>
<blockquote>
<p>平衡二叉树就是对于任何一个子树来说，他的左子树的层数和他的右子树的层数<strong>相差最多为 1</strong></p>
</blockquote>
<p>对于一个头节点来说</p>
<ul>
<li>他的左子树是平衡的</li>
<li>他的右子树是平衡的</li>
<li>然后 | 左高 - 右高 | &lt;= 1</li>
</ul>
<p>才可以代表这棵树是平衡二叉树</p>
<blockquote>
<p>所以我们需要</p>
<ul>
<li>左边是不是平的？以及高度是多少？</li>
<li>右边是不是平的？以及高度是多少？</li>
</ul>
<p>所以我知道，左树和右树需求是一样的，那就递归</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310224534953.png" alt="image-20220310224534953"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310225002017.png" alt="image-20220310225002017"></p>
<h5 id="同理看是不是搜索二叉树还是使用同一个套路递归"><a class="markdownIt-Anchor" href="#同理看是不是搜索二叉树还是使用同一个套路递归">#</a> 同理看是不是搜索二叉树还是使用同一个套路 (递归)</h5>
<p>就像给了我们一个节点，问我们这个节点以及他下面的这个树是不是搜索二叉树</p>
<ul>
<li>首先左边是个二叉树</li>
<li>右边是个二叉树</li>
<li>并且左树的最大值应该小于我 (这是对于每一个子树 (有左孩子的) 来说，因为是递归，确实啊，没毛病)</li>
<li>并且右树的最小值应该大于我 (这是对于每一个子树 (有右孩子的) 来说，因为是递归，确实啊，没毛病)</li>
</ul>
<p><em><em>== 我们可以跟他的_左树要信息</em>，可以跟他的_右树要信息</em>，我们再看有什么需求 (要什么信息)==__</p>
<p>我们需要左树的信息</p>
<ul>
<li>是不是搜索二叉树</li>
<li>这个左树的最大值</li>
</ul>
<p>我们需要右树的信息</p>
<ul>
<li>是不是搜索二叉树</li>
<li>这个右树的最小值</li>
</ul>
<blockquote>
<p>但是！我们递归全都是一样的，参数等等等</p>
<p><mark>所以，<strong> 不管是哪边的树，我们都会让他返回三个信息</strong></mark></p>
<ul>
<li>是不是二叉树</li>
<li>最小值</li>
<li>最大值</li>
</ul>
</blockquote>
<p>代码:</p>
<p>首先是自定义返回值:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310230004122.png" alt="image-20220310230004122"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310232943524.png" alt="image-20220310232943524"></p>
<h5 id="同理看是不是满二叉树还是使用同一个套路"><a class="markdownIt-Anchor" href="#同理看是不是满二叉树还是使用同一个套路">#</a> 同理看是不是满二叉树还是使用同一个套路</h5>
<p>比如说给我们了一个头节点，我们要看是不是满二叉树，我们</p>
<ul>
<li>首先知道他左子树的高度以及多少个节点</li>
<li>再知道他右子树的高度以及多少个节点</li>
</ul>
<p>我们可以结合当前节点的信息 (高度加 1, 节点加 1), 然后调用这个这个 formula—&gt;<strong>N = 2<sup>D</sup>-1</strong></p>
<blockquote>
<p>满二叉树一定符合 <strong>N = 2<sup>D</sup>-1</strong></p>
</blockquote>
<p><strong>我们需要左子树的信息:</strong></p>
<ul>
<li>多少个节点</li>
<li>最高什么高度</li>
</ul>
<p><strong>我们需要右子树的信息:</strong></p>
<ul>
<li>多少个节点</li>
<li>最高什么高度</li>
</ul>
<p>所以我们自定义返回值就是有这个两个属性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310234905570.png" alt="image-20220310234905570"></p>
<p><strong>模板</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310235017961.png" alt="image-20220310235017961"></p>
<p><strong>正确答案:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310235114103.png" alt="image-20220310235114103"></p>
<p>主函数调用:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220310235401492.png" alt="image-20220310235401492"></p>
<blockquote>
<p>这里相当于是先把所有要的值都获取了，然后才一块判定对不对</p>
<p><strong>而不是之前那种让每一个左树 / 右树附带一个 isFull 这种数据作为返回值等等等</strong></p>
</blockquote>
<h5 id="树型dp套路"><a class="markdownIt-Anchor" href="#树型dp套路">#</a> 树型 dp 套路</h5>
<p><mark>这个不一定可以解决所有二叉树问题，但是可以解决所有树型 dp 类型的题</mark></p>
<blockquote>
<p>比如说，需要看整棵树才可以决定的答案，这种需要结合所有情况来看的，不过这种一般都是没有优化的方法，都是暴力解，面试中一般不会考的</p>
</blockquote>
<p><strong>树型 dp 的题就是解一个题可以通过跟左树和右树要信息，把这个事给解决了，只要是这种类型的，都可以这个套路解决</strong></p>
<blockquote>
<p>所以发现套路了吧！！！</p>
<ul>
<li>
<p>我们一般都是自定义返回值，里面存着我们想要的 (不管是左树还是右树还是什么) 各种信息</p>
</li>
<li>
<p>然后递归方法里面，首先返回值肯定是我们的那个自定义的返回值，然后一般接收参数也是一个节点 (当前的头节点)</p>
<ul>
<li>
<p>我们 base case, 这里一般要看你感兴趣的范围以及返回的值都是看你需求</p>
</li>
<li>
<p>接着调用自己传参传当前节点左边的树，然后这个返回一个我们自定义类型的值代表我们每一颗子树都有可能返回的值 (不用管那么多其实，就当做是黑盒，你只管调用自己就行)</p>
<p>反正最后会返回给你那个想要的左边树的信息</p>
</li>
<li>
<p>接着调用自己传参传当前右节边的树，然后这个返回一个我们自定义类型的值代表我们每一颗子树都有可能返回的值 (不用管那么多其实，就当做是黑盒，你只管调用自己就行)</p>
<p>反正最后会返回给你那个想要的右边树的信息</p>
</li>
<li>
<p><mark><em>_我们接下来必须要考虑有了左边数的信息和右边树的信息，他们怎么和我们当前这个节点比，才能让他们连起来 (这个很重要！！！)</em>_</mark></p>
<ul>
<li>我们首先可以给那个自定义类的每个属性定义一个变量代表</li>
<li>接着对着每一个变量，让他们，结合着左边数的信息和右边树的信息来设对应的值</li>
<li>然后我们再把这些值封装成我们自定义类然后返回，作为我们这个当前整个树的返回值 (这个因为会是递归，会被每一个能算是被叫成树的 (有左孩子 / 右孩子 / 都有等等等) 都会执行这一块)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>再多说几句:</p>
<p>我们在最后处理当前节点的，只要考虑我们左边数的信息和右边树的信息就行了，比如说左边数的信息和右边树的信息里面有最小值，直接用，那肯定就是我们左树 / 右树一个一个算出来最后到了那一层算出的最小值 (<strong>就认为左 / 右树给的信息就是全量的–&gt; 我们想要的信息都有，“比如 36,37 行的递归代码，我管你怎么执行，反正你把我要的结果给我了”</strong>), 然后我们这一层再比，跟当前节点比，如果当前节点更小，那么更新那个最小值，由此可见，其实最小值就是这么更出来的，最后这个也会返回到上一层！</p>
</blockquote>
<p><mark>这个套路可以解决一切面试里面的树型的 dp 题</mark></p>
<hr>
<h4 id="树型dp题之二叉树节点间最大距离问题"><a class="markdownIt-Anchor" href="#树型dp题之二叉树节点间最大距离问题">#</a> 树型 dp 题之二叉树节点间最大距离问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319122427241.png" alt="image-20220319122427241"></p>
<p>两种可能性</p>
<ol>
<li>不包括头节点 x, 说明就是要么 x 的左树 / 右树有两个节点他们之间距离最大</li>
<li>包括头节点 x, 说明就是 x 左树最深的节点到 x 右树最深的节点 (也就是 <code>左高+右高+1(x他自己)</code> )</li>
</ol>
<p>所以就是左边取最大距离，右边取最大距离，然后左高 + 右高 + 1 (x 他自己), 这三个当中取最大值</p>
<blockquote>
<p>这种按照头节点包不包括的可能性分类就是经验，这种可能性的分类很重要！</p>
</blockquote>
<p>树型 dp 套路</p>
<ul>
<li>左树和右树都需要最大距离 (这个最大距离就是按照每一层的节点以他来看高度的得出来的) 和高度信息</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319123434337.png" alt="image-20220319123434337"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319123615166.png" alt="image-20220319123615166"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319123632440.png" alt="image-20220319123632440"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319123848552.png" alt="image-20220319123848552"></p>
<h4 id="树型dp题之排队最大快乐值问题"><a class="markdownIt-Anchor" href="#树型dp题之排队最大快乐值问题">#</a> 树型 dp 题之排队最大快乐值问题</h4>
<blockquote>
<p>这个是个多叉树的结构</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319123938396.png" alt="image-20220319123938396"></p>
<p>解法:</p>
<p>假设 x 头节点，然后直接孩子是 a,b,c</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319124648644.png" alt="image-20220319124648644"></p>
<ul>
<li>x 参与，代表 abc 就无法参加，那么整颗 x 代表的树的最大快乐值就是</li>
</ul>
<p><code>x快乐值+a整棵树在a不来的情况下最大的快乐值+b整棵树在b不来的情况下最大的快乐值+c整棵树在c不来的情况下最大的快乐值</code></p>
<ul>
<li>x 不参与，代表 abc 可以参加也可以不参加，那么整颗 x 代表的树的最大快乐值就是</li>
</ul>
<p><code>0 + Math.max(a整棵树在a来的情况下最大的快乐值,a整棵树在a不来的情况下最大的快乐值)                              + Math.max(b整棵树在b来的情况下最大的快乐值,b整棵树在b不来的情况下最大的快乐值)                         + Math.max(c整棵树在c来的情况下最大的快乐值,c整棵树在c不来的情况下最大的快乐值)</code></p>
<p>所以对于我们的所有子树 (多叉树), 我们需要:</p>
<ul>
<li>那个子树包括子树节点来的最大值</li>
<li>那个子树不包括子树节点来的最大值</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319125334253.png" alt="image-20220319125334253"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319125920667.png" alt="image-20220319125920667"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319125940924.png" alt="image-20220319125940924"></p>
<blockquote>
<p>树型 dp 套路可以对多叉树也可以用，都是那个想法</p>
</blockquote>
<hr>
<h4 id="两个二叉树的最低公共祖先"><a class="markdownIt-Anchor" href="#两个二叉树的最低公共祖先">#</a> 两个二叉树的最低公共祖先</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311000630082.png" alt="image-20220311000630082"></p>
<p>比如说:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311000704493.png" alt="image-20220311000704493"></p>
<ul>
<li>D 和 E 的最低公共祖先是 B</li>
<li>E 和 F 的最低公共祖先是 E</li>
</ul>
<p>所以问题就是整个二叉树的头给我们，然后给了那个 node1 和 node2</p>
<blockquote>
<p>潜规则，node1 和 node2 一定是属于 head 为头的这个二叉树的节点</p>
</blockquote>
<ul>
<li>使用 HashMap 来存<strong>每一个节点 (key) 和他的父亲 (value)</strong></li>
<li>接着把 head 和这个 hashMap 作为参数传进一个递归方法</li>
<li>这个递归方法里面的套路就是模板 (有稍微一点不一样)(只不过我们这里没有返回值，不用自定义返回值类型，我们只是改 hashMap 里面的数据)</li>
</ul>
<p>我们在这个递归方法里面:</p>
<ul>
<li>base case</li>
<li>把左节点作为 key 和当前 head 作为 value 存进 hashmap</li>
<li>把右节点作为 key 和当前 head 作为 value 存进 hashmap</li>
<li>调用自己左子树传进去 hashMap</li>
<li>调用自己右子树传进去 hashMap</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311001549751.png" alt="image-20220311001549751"></p>
<p>这个样子所有左子树会把他的所有节点和对应的父亲都设置好放进了 hashMap, 所有右子树会把他的所有节点和对应的父亲都设置好放进了 hashMap, 我们就可以返回到我们的主函数里面再做操作</p>
<ul>
<li>首先，我们 ** 整个的大头 head (只有这一个！)** 他的父节点是没有设置的，所以在主函数一个设置一下</li>
<li>然后使用一个 hashSet 把 node1 (或者 node2) 先放进去</li>
<li>然后接着一直放，放到头节点 (包括) 为止，此时这个 hashSet 就是这个 node1 到头节点的道路经过的节点</li>
<li>然后接着我们可以使用 hashMap, 让 node2 检查是不是已经在那个 hashSet 里面了，如果没有一个一个往上升 (变成他自己的父亲), 然后一个一个检查，直到查到一样的 (可能是 head 主的那个头节点), 然后返回那个节点就行了，因为就是从下往上的 (通过成为找父亲，找父亲的父亲), 要是有一样的 (一定会有的，因为最后肯定都是 head),<strong> 那么一定就是最低的公共祖先</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311002523443.png" alt="image-20220311002523443"></p>
<h5 id="更短但是很难理解的方法"><a class="markdownIt-Anchor" href="#更短但是很难理解的方法">#</a> 更短，但是很难理解的方法</h5>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=7&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV13g41157hK?p=7&amp;spm_id_from=pageDriver</a></p>
<p>1:35:00, 比较抽象</p>
</blockquote>
<p>有两种可能</p>
<ol>
<li>
<p>O1 是 O2 的 LCA (最低公共祖先), 或者 O2 是 O1 的 LCA</p>
<blockquote>
<p>那么我们直接把那个更上面的那个返回出来，另外一个没有遇到 (根本不去), 代表最后只有一个然后另外一个是 null</p>
<p>那么整体返回的就是那一个，也就是对的</p>
</blockquote>
</li>
<li>
<p>O1 和 O2 不互为 LCA, 要往上才能找到</p>
<blockquote>
<p>那么这两个都会被找到然后往上传，一直传到他们的 LCA 就会直接返回那个 LCA</p>
</blockquote>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311003806232.png" alt=""></p>
<hr>
<h4 id="二叉树找一个节点的后继节点"><a class="markdownIt-Anchor" href="#二叉树找一个节点的后继节点">#</a> 二叉树找一个节点的后继节点</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311004037076.png" alt="image-20220311004037076"></p>
<p>这里 -&gt;D 的后继节点是 B,B 的后继节点是 E,E 的后继节点是 A,…G 的后继节点是 null</p>
<p>也就是中序排序中的一个节点后一个节点</p>
<blockquote>
<p>同理，前驱节点就是后继节点反过来–&gt; 中序排序的一个节点的前一个节点</p>
</blockquote>
<p>题目:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311004334430.png" alt="image-20220311004334430"></p>
<blockquote>
<p><strong>我们之前做法可能就是遍历一下然后把所有的按照中序排好存到一个 set 里面</strong>，然后看节点后面的节点是什么就行，但是这样会耗空间因为有那个 set, 我们这里有很好的解法:</p>
</blockquote>
<p>我们这里每个节点都有 parent 指针指向他的 parent, 所以没有必要像之前的做法</p>
<p>我们完全可以让那个节点他的 parent 指针找到对应的后继节点就行了</p>
<ul>
<li>假设我们节点是在第三层然后他的 parent 也就是他的后继节点在第二层，那么只需要走一步就行了</li>
<li>假设我们节点是在第三层然后他的 parent 的 parent 也就是他的后继节点在第一层，那么只需要走两步就行了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311005037619.png" alt="image-20220311005037619"></p>
<blockquote>
<p>还有各种可能，或许不是通过 parent 等等等，看代码！！！</p>
</blockquote>
<p><strong>所以，假设我们节点和他的后继节点之间的距离是 k, 那么我们可以有个 O (k) 时间复杂度的解法</strong></p>
<p>比如说给了个节点 X 找后继节点，有几种情况:</p>
<ul>
<li>
<p>X 有右子树的时候，那么右子树的<strong>最左</strong>的 leaf 节点就是这个 X 的后继节点 (因为中序遍历，搞完 X 就去的右子树，他的右子树会先去搞他的左子树，等等等)</p>
</li>
<li>
<p>X 没有右子树，那么就会看 parent 然后看是不是我父亲的左孩子</p>
<ul>
<li>如果是，那么这个父亲就是我们的后继节点</li>
<li>如果不是，那就继续往上看，一直看是头还不是，那就代表我们这个 X 是整颗数最右的叶节点，中序排序最后一个节点，没有后继节点，返回 null</li>
<li>如果不是，那就继续往上看，一直看是为止，此时那个父亲 (我们这个是左孩子了) 就是我们的 X 的后继节点</li>
</ul>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311005859220.png" alt="image-20220311005859220" style="zoom: 50%;" />
<blockquote>
<p>这是因为对于我们 Y 节点来说，我们的 X 就是 Y 的左子树最右的叶节点，也就是中序排序中他前面的那个节点 (打印完 X 就打印 Y)</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311011440010.png" alt="image-20220311011440010"></p>
</li>
</ul>
<hr>
<h4 id="二叉树的序列化和反序列化"><a class="markdownIt-Anchor" href="#二叉树的序列化和反序列化">#</a> 二叉树的序列化和反序列化</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311011513929.png" alt="image-20220311011513929"></p>
<blockquote>
<p>就是我们这颗树的<strong>结构</strong>以及他的<strong>值</strong>都能对应一个字符串，这样我们可以序列化 (内存变成字符串), 然后接着反序列化 -&gt; 字符串还原出来之前那棵树的结构以及值</p>
</blockquote>
<p>好几种做法</p>
<ol>
<li>先序</li>
</ol>
<p>序列化:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311012028469.png" alt="image-20220311012028469"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311012116467.png" alt="image-20220311012116467"></p>
<blockquote>
<p>可以看出不一样，easy</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311012703315.png" alt="image-20220311012703315"></p>
<p>反序列化:</p>
<ul>
<li>因为我们序列化是用_作为每个数的结尾，我们可以把_之前的每一个数都存入存入数组中</li>
<li>当初按照先序序列化的，现在按照先序反序列化</li>
<li>然后读数组第一个值作为 head, 然后再看下一个数作为 head 的左边的节点，so on…</li>
<li>如果遇到一个 #代表 null, 我们返回上一层，看那一层的右节点，so on…</li>
</ul>
<blockquote>
<p>这不就递归嘛！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311013031046.png" alt="image-20220311013031046"></p>
<hr>
<h4 id="凹凸折痕"><a class="markdownIt-Anchor" href="#凹凸折痕">#</a> 凹凸折痕</h4>
<p>假设一张纸，给你个 N, 让你算出这张纸折叠 N 次，让你给出这张纸平摊后从上到下的折叠方向</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311014059375.png" alt="image-20220311014059375" style="zoom:33%;" />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311014230793.png" alt="image-20220311014230793"></p>
<blockquote>
<p>整个就是二叉树</p>
<ul>
<li>左子树都是凹折痕</li>
<li>右子树都是凸折痕</li>
<li>然后整个的头节点就是凹折痕</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220311014956765.png" alt="image-20220311014956765"></p>
<blockquote>
<p>就是中序遍历，因为毕竟要求是从上到下的折叠方向也就是先把那个比如说 3 凹打印，然后 2 凹，3 凸等等等</p>
</blockquote>
<p><strong>我们这里的空间复杂度是 O (N),N 是那个传进来的 N 值，因为我们最深 (递归) 打印到 N 层，所以很省空间</strong></p>
<p>要是让我们暴力，可能会发现凹凸折痕是 2<sup>N</sup>-1 个，然后我们就挨个存上面的，然后挨个打印，那么空间复杂度就到了 O (2<sup>N</sup>) 级别了</p>
<p>我们这里直接递归，最多就是空间复杂度是 O (N), 因为我们最多深入到 N 层，之后返回就会挨个清空，之后要是还再深入也还是用我们之前清空的空间，也就最多 O (N) 空间复杂度</p>
<hr>
<h3 id="二叉树的morris遍历"><a class="markdownIt-Anchor" href="#二叉树的morris遍历">#</a> 二叉树的 Morris 遍历</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319130543600.png" alt="image-20220319130543600"></p>
<blockquote>
<p>Morris 遍历，每个有左子节点的节点都会被访问两次，没有左子节点的只会被访问一次</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319152650230.png" alt="image-20220319152650230"></p>
<blockquote>
<p>时间复杂度就是 O (N), 因为每一个节点都最多被访问两次所以其实就是 O (n)(具体看视频)</p>
<p>空间复杂度就是 O (1), 就用了那几个指针</p>
</blockquote>
<h4 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历">#</a> 先序遍历</h4>
<p>1</p>
<p>2 3</p>
<p>4 5 6 7</p>
<p>morris 序列 1 2 4 2 5 3 6 3 7</p>
<p>打印 morris 序列中第一次出现的元素就是先序遍历</p>
<p>（有左孩子即会出现两次）</p>
<p>先序 1 2 4 5 3 6 7</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//第一次到达时，打印</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">morrisPre</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> mostRight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			mostRight <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					mostRight <span class="token operator">=</span> mostRight<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// 有左树，第二次到达时打印</span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
					cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 没有左树，第一次就打印</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="中序遍历-2"><a class="markdownIt-Anchor" href="#中序遍历-2">#</a> 中序遍历</h4>
<p>对于出现两次的元素，第二次打印，只出现一次的元素，第一次出现就打印</p>
<p>morris 序列 1 2 4 2 5 3 6 3 7</p>
<p>中序 4 2 5 1 6 3 7</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">morrisIn</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> mostRight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		mostRight <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight <span class="token operator">=</span> mostRight<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
     <span class="token comment">//只能到达一次的第一次打印，可以到达两次的第二次到达才打印</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="后序遍历-2"><a class="markdownIt-Anchor" href="#后序遍历-2">#</a> 后序遍历</h4>
<p>对于可以到达两次的元素，第二次回到该元素时，逆序打印右边界</p>
<p>整个树遍历后，逆序打印整棵树的右边界</p>
<p>原理为：</p>
<p>一个树可以被右边界分解掉，由左往右，每次逆序打印其右边界，就是后序遍历</p>
<p>中途要求逆序打印，但 morris 要求 O（1）空间，即排除了使用额外空间的办法</p>
<p>可以使用反转链表来实现逆序打印</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">morrisPos</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> mostRight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		mostRight <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight <span class="token operator">=</span> mostRight<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
         <span class="token comment">//第二次回到该节点时，逆序打印此节点</span>
				<span class="token function">printEdge</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
   <span class="token comment">// 结束之后，打印整个树的右边界</span>
	<span class="token function">printEdge</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//先链表反转，遍历后再反转回去</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printEdge</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">Node</span> tail <span class="token operator">=</span> <span class="token function">reverseEdge</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Node</span> cur <span class="token operator">=</span> tail<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">reverseEdge</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">reverseEdge</span><span class="token punctuation">(</span><span class="token class-name">Node</span> from<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">Node</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token class-name">Node</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>from <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		next <span class="token operator">=</span> from<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
		from<span class="token punctuation">.</span>right <span class="token operator">=</span> pre<span class="token punctuation">;</span>
		pre <span class="token operator">=</span> from<span class="token punctuation">;</span>
		from <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="判断是否为二叉查找树"><a class="markdownIt-Anchor" href="#判断是否为二叉查找树">#</a> 判断是否为二叉查找树</h4>
<p>中序遍历为递增序列则为二叉查找树</p>
<p>使用 morris 遍历</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> mostRight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token class-name">Integer</span> pre<span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		mostRight <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight <span class="token operator">=</span> mostRight<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
				cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
     <span class="token comment">// 如果上一个值大于等于当前值，则这个树一定不是 bst</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">>=</span>cur<span class="token punctuation">.</span>value  <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
     pre <span class="token operator">=</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">;</span> 
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="求二叉树最小高度"><a class="markdownIt-Anchor" href="#求二叉树最小高度">#</a> 求二叉树最小高度</h4>
<p>给定一棵二叉树的头节点 head</p>
<p>求以 head 为头的树中，最小深度是多少？</p>
<p>递归办法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>
 
		<span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			val <span class="token operator">=</span> x<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
 
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">minHeight1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token function">p</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
 
	<span class="token comment">// 返回x为头的树，最小深度是多少</span>
    <span class="token comment">// 使用递归求解</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 左右子树起码有一个不为空</span>
		<span class="token keyword">int</span> leftH <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			leftH <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">int</span> rightH <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			rightH <span class="token operator">=</span> <span class="token function">p</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>leftH<span class="token punctuation">,</span> rightH<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>morris 办法</p>
<p>需要做到以下两点</p>
<p>每到一个节点，可以知道它的高度</p>
<p>每到一个节点，可以判断出是否为叶子节点</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 根据morris遍历改写</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">minHeight2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token class-name">Node</span> mostRight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> curLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> minHeight <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		mostRight <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
         <span class="token keyword">int</span> rightBoardSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> mostRight<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
           <span class="token comment">// 由下往上的元素层数</span>
           rightBoardSize<span class="token operator">++</span><span class="token punctuation">;</span>
           mostRight <span class="token operator">=</span> mostRight<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
         <span class="token punctuation">&#125;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 第一次到达</span>
           curLevel<span class="token operator">++</span><span class="token punctuation">;</span>
           mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
           cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
           <span class="token keyword">continue</span><span class="token punctuation">;</span>
         <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> 
           <span class="token comment">// 第二次到达，需要减去rightBoardSize</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>mostRight<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
             <span class="token comment">//此时到达叶节点，计算最小高度</span>
             minHeight <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minHeight<span class="token punctuation">,</span> curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">&#125;</span>
           curLevel <span class="token operator">-=</span> rightBoardSize<span class="token punctuation">;</span>
           mostRight<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
         <span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> 
       <span class="token comment">// 只有一次到达</span>
			curLevel<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> finalRight <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		finalRight<span class="token operator">++</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
   <span class="token comment">// 单独去找一下最右部分的最小高度</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		minHeight <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minHeight<span class="token punctuation">,</span> finalRight<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> minHeight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="图问题"><a class="markdownIt-Anchor" href="#图问题">#</a> 图问题</h3>
<h4 id="括扑排序算法topological-sort"><a class="markdownIt-Anchor" href="#括扑排序算法topological-sort">#</a> 括扑排序算法 (topological sort)</h4>
<ul>
<li>适用于 Directed Acyclic Graph --&gt; directed graph with no loops (无环–&gt; 指的不只是自己指向自己的那种环，还包括多个节点形成的环)</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311153932671.png" alt="image-20220311153932671" style="zoom: 50%;" />
<p>比如说：工程中的依赖</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311154107793.png" alt="image-20220311154107793" style="zoom:50%;" />
<blockquote>
<p>注意不能拥有环，也就像工程中依赖之间不能循环依赖一样</p>
</blockquote>
<p>对于上方的图，我们可以看到我们先需要 E 依赖，然后 C 依赖然后 D 依赖，然后 B 依赖，然后 A 依赖</p>
<p>问题例子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311154442907.png" alt="image-20220311154442907" style="zoom:50%;" />
<p>解法:</p>
<ol>
<li>我们首先入度为 0 的 (如果要拿 topological sort 来解答的话那就一定有这个)(一开始就是 A 节点)</li>
</ol>
<p>​	这个节点就相当于是 (此时) 必须先要有的依赖，然后其他的依赖才可以设起来</p>
<ol start="2">
<li>
<p>接着把这个节点以及他的 outward edge 都擦掉 (肯定只会有 outward, 因为我们找到的是入度为 0 的),</p>
<p>记得把这个节点保存啊，进行什么操作啊等等等</p>
</li>
<li>
<p>重复 1,2–&gt; 因为我们上面把 A 以及他的 outward edge 都擦掉了，此时 B 就是入度为零的节点，等等等</p>
</li>
</ol>
<p>最终的 topological sort 顺序就是:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311155000192.png" alt="image-20220311155000192" style="zoom:50%;" />
<blockquote>
<p>注意如果有多个入度为 0 的节点，那随便哪一个都行，反正我们之后顺序一定不会产生需要依赖的在前面然后被依赖的那个在后面.</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311160040308.png" alt="image-20220311160040308"></p>
<hr>
<h4 id="最小生成树以及相关算法和一些terminologies"><a class="markdownIt-Anchor" href="#最小生成树以及相关算法和一些terminologies">#</a> 最小生成树以及相关算法 (和一些 terminologies)</h4>
<p>关于图的几个概念定义：</p>
<p>** 连通图：** 在无向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该无向图为连通图。<br>
** 强连通图：** 在有向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该有向图为强连通图。<br>
** 连通网：** 在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。<br>
** 生成树：** 一个连通图的生成树是指一个连通子图，它含有图中全部 n 个顶点，但只有足以构成一棵树的 n-1 条边。一颗有 n 个顶点的生成树有且仅有 n-1 条边，如果生成树中再添加一条边，则必定成环。<br>
** 最小生成树 (minimum weight spanning tree)：** 在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/20200208191020235.png" alt=""></p>
<blockquote>
<p>可以用 kruskal 或者 Prim 生成最小生成树</p>
</blockquote>
<h5 id="terminologies"><a class="markdownIt-Anchor" href="#terminologies">#</a> Terminologies</h5>
<h5 id="definitions-graph-vertices-edges"><a class="markdownIt-Anchor" href="#definitions-graph-vertices-edges">#</a> Definitions: Graph, Vertices, Edges</h5>
<ul>
<li>
<p>Define a graph G = (V, E) by defining a pair of sets:</p>
<ol>
<li>V = a set of <strong>vertices</strong></li>
<li>E = a set of <strong>edges</strong></li>
</ol>
</li>
<li>
<p>Edges:</p>
<ul>
<li>Each edge is defined by a pair of vertices</li>
<li>An edge <strong>connects</strong> the vertices that define it</li>
<li>In some cases, the vertices can be the same</li>
</ul>
</li>
<li>
<p>Vertices:</p>
<ul>
<li>Vertices also called <strong>nodes</strong></li>
<li>Denote vertices with labels</li>
</ul>
</li>
<li>
<p>Representation:</p>
<ul>
<li>Represent vertices with circles, perhaps containing a label</li>
<li>Represent edges with lines between circles</li>
</ul>
</li>
<li>
<p>Example:</p>
<ul>
<li A,B,C,D="">V =</li>
<li (A,B),(A,C),(A,D),(B,D),(C,D)="">E =</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/Graph2.png" alt="img"></p>
</li>
</ul>
<h5 id="motivation"><a class="markdownIt-Anchor" href="#motivation">#</a> Motivation</h5>
<p>Many algorithms use a graph representation to represent data or the problem to be solved</p>
<p>Examples:</p>
<ul>
<li>
<p>Cities with distances between</p>
</li>
<li>
<p>Roads with distances between intersection points</p>
</li>
<li>
<p>Course prerequisites</p>
</li>
<li>
<p>Network</p>
</li>
<li>
<p>Social networks</p>
</li>
<li>
<p>Program call graph and variable dependency graph</p>
</li>
</ul>
<h5 id="graph-classifications"><a class="markdownIt-Anchor" href="#graph-classifications">#</a> Graph Classifications</h5>
<ul>
<li>
<p>There are seveal common kinds of graphs</p>
<ul>
<li><strong>Weighted or unweighted</strong></li>
<li><strong>Directed or undirected</strong></li>
<li><strong>Cyclic or acyclic</strong></li>
</ul>
</li>
<li>
<p>Choose the kind required for problem and determined by data</p>
</li>
<li>
<p>We examine each below</p>
</li>
</ul>
<h5 id="kinds-of-graphs-weighted-and-unweighted"><a class="markdownIt-Anchor" href="#kinds-of-graphs-weighted-and-unweighted">#</a> Kinds of Graphs: Weighted and Unweighted</h5>
<p>Graphs can be classified by whether or not their edges have <strong>weights</strong></p>
<ul>
<li><strong>Weighted graph</strong>: edges have a weight
<ul>
<li>Weight typically shows cost of traversing</li>
<li>Example: weights are distances between cities</li>
</ul>
</li>
<li><strong>Unweighted graph</strong>: edges have no weight
<ul>
<li>Edges simply show connections</li>
<li>Example: course prereqs</li>
</ul>
</li>
</ul>
<h5 id="kinds-of-graphs-directed-and-undirected"><a class="markdownIt-Anchor" href="#kinds-of-graphs-directed-and-undirected">#</a> Kinds of Graphs: Directed and Undirected</h5>
<p>Graphs can be classified by whether or their edges are have direction</p>
<ul>
<li><strong>Undirected Graphs</strong>: each edge can be traversed in <strong>either direction</strong></li>
<li><strong>Directed Graphs</strong>: each edge can be traversed <strong>only in a specified direction</strong></li>
</ul>
<h5 id="undirected-graphs"><a class="markdownIt-Anchor" href="#undirected-graphs">#</a> Undirected Graphs</h5>
<ul>
<li>
<p><strong>Undirected Graph</strong>: no implied direction on edge between nodes</p>
<ul>
<li>
<p>The example from above is an undirected graph</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/Graph2.png" alt="img"></p>
</li>
<li>
<p>In diagrams, edges have no direction (ie they are not arrows)</p>
</li>
<li>
<p>Can traverse edges in either directions</p>
</li>
</ul>
</li>
<li>
<p>In an undirected graph, an edge is an <strong>unordered</strong> pair</p>
<ul>
<li>
<p>Actually, an edge is a set of 2 nodes, but for simplicity we write it with parens</p>
<ul>
<li A,="" B="">For example, we write (A, B) instead of</li>
<li>Thus, (A,B) = (B,A), etc</li>
<li>If (A,B) ∈ E then (B,A) ∈ E</li>
</ul>
</li>
<li>
<p>Formally: ∀ u,v ∈ E, (u,v)=(v,u) and u ≠ v</p>
</li>
</ul>
</li>
<li>
<p>A node normally does not have an edge to itself</p>
</li>
</ul>
<h5 id="directed-graphs"><a class="markdownIt-Anchor" href="#directed-graphs">#</a> Directed Graphs</h5>
<ul>
<li>
<p><strong>Digraph</strong>: A graph whose edges are directed (ie have a direction)</p>
<ul>
<li>
<p>Edge drawn as arrow</p>
</li>
<li>
<p>Edge can only be traversed in direction of arrow</p>
</li>
<li (A,B),="" (A,C),="" (A,D),="" (B,C),="" (D,C)="">
<p>Example: E =</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sites.radford.edu/~nokie/classes/360/Diagrams/Graph3.png" alt="img"></p>
</li>
<li>
<p>Examples: courses and prerequisites, program call graph</p>
</li>
</ul>
</li>
<li>
<p>In a digraph, an edge is an <strong>ordered</strong> pair</p>
<ul>
<li>Thus: (u,v) and (v,u) are not the same edge</li>
<li>In the example, (D,C) ∈ E, (C,D) ∉ E</li>
<li>What would edge (B,A) look like? Remember (A,B) ≠ (B,A)</li>
</ul>
</li>
<li>
<p>A node can have an edge to itself (eg (A,A) is valid)</p>
</li>
</ul>
<h5 id="subgraph"><a class="markdownIt-Anchor" href="#subgraph">#</a> Subgraph</h5>
<ul>
<li>If graph G=(V, E)
<ul>
<li>Then Graph G’=(V’,E’) is a <strong>subgraph</strong> of G if V’ ⊆ V and E’ ⊆ E and</li>
</ul>
</li>
</ul>
<h5 id="degree-of-a-node"><a class="markdownIt-Anchor" href="#degree-of-a-node">#</a> Degree of a Node</h5>
<ul>
<li>
<p>The <strong>degree</strong> of a node is the number of edges the node is used to define</p>
</li>
<li>
<p>In the example above:</p>
<ul>
<li>Degree 2: B and C</li>
<li>Degree 3: A and D</li>
<li>A and D have <strong>odd degree</strong>, and B and C have <strong>even degree</strong></li>
</ul>
</li>
<li>
<p>Can also define <strong>in-degree</strong> and <strong>out-degree</strong></p>
<ul>
<li>In-degree: Number of edges pointing <strong>to</strong> a node</li>
<li>Out-degree: Number of edges pointing <strong>from</strong> a node</li>
</ul>
</li>
</ul>
<h5 id="graphs-terminology-involving-paths"><a class="markdownIt-Anchor" href="#graphs-terminology-involving-paths">#</a> Graphs: Terminology Involving Paths</h5>
<ul>
<li>
<p><strong>Path</strong>: sequence of vertices in which each pair of successive vertices is connected by an edge</p>
</li>
<li>
<p><strong>Cycle</strong>: a path that starts and ends on the same vertex</p>
</li>
<li>
<p><strong>Simple path</strong>: a path that does not cross itself</p>
<ul>
<li>That is, no vertex is repeated (except first and last)</li>
<li>Simple paths cannot contain cycles</li>
</ul>
</li>
<li>
<p><strong>Length</strong> of a path: Number of edges in the path</p>
<ul>
<li>Sometimes the sum of the weights of the edges</li>
</ul>
</li>
</ul>
<h5 id="cyclic-and-acyclic-graphs"><a class="markdownIt-Anchor" href="#cyclic-and-acyclic-graphs">#</a> Cyclic and Acyclic Graphs</h5>
<ul>
<li>
<p>A <strong>Cyclic</strong> graph contains cycles</p>
<p>Example: roads (normally)</p>
</li>
<li>
<p>An <strong>acyclic</strong> graph contains no cycles</p>
<p>Example: Course prereqs!</p>
</li>
</ul>
<h5 id="connected-and-unconnected-graphs-and-connected-components"><a class="markdownIt-Anchor" href="#connected-and-unconnected-graphs-and-connected-components">#</a> Connected and Unconnected Graphs and Connected Components</h5>
<ul>
<li>
<p>An <em>undirected</em> graph is <strong>connected</strong> if every pair of vertices has a path between it</p>
<ul>
<li>Otherwise it is unconnected</li>
</ul>
</li>
<li>
<p>An unconnected graph can be broken in to <strong>connected components</strong></p>
</li>
<li>
<p>A <em>directed</em> graph is <strong>strongly connected</strong> if every pair of vertices has a path between them, in <strong>both directions</strong></p>
</li>
</ul>
<h5 id="trees-and-minimum-spanning-trees"><a class="markdownIt-Anchor" href="#trees-and-minimum-spanning-trees">#</a> Trees and Minimum Spanning Trees</h5>
<ul>
<li>Tree: undirected, connected graph with no cycles</li>
<li>Spanning tree: a <strong>spanning tree</strong> of G is a connected subgraph of G that is a tree</li>
<li><strong>Minimum spanning tree</strong> (MST): a spanning tree with minimum weight</li>
<li>Spanning trees and minimum spanning tree are not necessarily unique</li>
<li>We will look at two famous MST algorithms: Prim’s and Kruskal’s</li>
</ul>
<h5 id="data-structures-for-representing-graphs"><a class="markdownIt-Anchor" href="#data-structures-for-representing-graphs">#</a> Data Structures for Representing Graphs</h5>
<ul>
<li>Two common data structures for representing graphs:
<ul>
<li>Adjacency lists</li>
<li>Adjacency matrix</li>
</ul>
</li>
</ul>
<h5 id="adjacency-list-representation"><a class="markdownIt-Anchor" href="#adjacency-list-representation">#</a> Adjacency List Representation</h5>
<ul>
<li>
<p>Each node has a list of adjacent nodes</p>
</li>
<li>
<p>Example (undirected graph):</p>
<ul>
<li>
<p>A: B, C, D</p>
</li>
<li>
<p>B: A, D</p>
</li>
<li>
<p>C: A, D</p>
</li>
<li>
<p>D: A, B, C</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/Graph2.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>Example (directed graph):</p>
<ul>
<li>
<p>A: B, C, D</p>
</li>
<li>
<p>B: D</p>
</li>
<li>
<p>C: Nil</p>
</li>
<li>
<p>D: C</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sites.radford.edu/~nokie/classes/360/Diagrams/Graph3.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>Weighted graph can store weights in list</p>
</li>
<li>
<p>Space: Θ(V + E) (ie |V| + |E|)</p>
</li>
<li>
<p>Time:</p>
<ul>
<li>To visit each node that is adjacent to node u: Θ(degree(u))</li>
<li>To determine if node u is adjacent to node v: Θ(degree(u))</li>
</ul>
</li>
</ul>
<h5 id="adjacency-matrix-representation"><a class="markdownIt-Anchor" href="#adjacency-matrix-representation">#</a> Adjacency Matrix Representation</h5>
<ul>
<li>
<p><strong>Adjacency Matrix</strong>: 2D array containing weights on edges</p>
<ul>
<li>Row for each vertex</li>
<li>Column for each vertex</li>
<li>Entries contain weight of edge from row vertex to column vertex</li>
<li>Entries contain ∞ (ie Integer’last) if no edge from row vertex to column vertex</li>
<li>Entries contain 0 on diagonal (if self edges not allowed)</li>
</ul>
</li>
<li>
<p>Example undirected graph (assume self-edges not allowed):</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>0</td>
<td>∞</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>∞</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/Graph2.png" alt="img"></p>
</li>
<li>
<p>Example directed graph (assume self-edges allowed):</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>∞</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>D</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sites.radford.edu/~nokie/classes/360/Diagrams/Graph3.png" alt="img"></p>
</li>
<li>
<p>Can store weights in cells</p>
</li>
<li>
<p>Space: Θ(V2)</p>
</li>
<li>
<p>Time:</p>
<ul>
<li>To visit each node that is adjacent to node u: Θ(V)</li>
<li>To determine if node u is adjacent to node v: Θ(1)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="kruskal算法k算法-适用范围要求无向图undirected-graphgraph"><a class="markdownIt-Anchor" href="#kruskal算法k算法-适用范围要求无向图undirected-graphgraph">#</a> kruskal 算法（K 算法） 适用范围：要求无向图 (undirected graph/graph)</h4>
<p>此算法可以称为 “加边法”，初始最小生成树边数为 0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p>
<ul>
<li>
<p>可以想象一开始每个点就是一个集合 (甚至可以想象是整张 graph 是 n 棵树组成的森林然后把图中的 n 个顶点看成独立的 n 棵树组成的森林)</p>
</li>
<li>
<p>我们接着按照图中所有的<strong> edges 最小 weight 的那个开始 (升序一个一个来)</strong></p>
</li>
<li>
<p>然后对于那个 edge, 我们检查他的 u (from) 节点和 v (to) 节点是不是在一个集合中 (<strong><mark>也就是这个边连接的点是不是已经是同一棵树了还是两颗不同的树</mark></strong>)</p>
<ul>
<li>
<p>如果不在我们就把这个 edge 加入到我们最小生成树里面，然后把 u 和 v 放到一个集合里面去，</p>
<p>------&gt; 当前的边进入最小生成树的集合中不会形成环</p>
</li>
<li>
<p>如果在我们不会把 edge 加入到我们的最小生成树里面，(这说明他们之间已经有路 (path) 了，不需要这个 weight 更高的路)</p>
<p>------&gt; 当前的边进入最小生成树的集合中会形成环</p>
</li>
</ul>
</li>
<li>
<p>然后当我们的 edges 都处理完，说明我们最小生成树就有了</p>
</li>
</ul>
<blockquote>
<p>这种需要并查集结构才好实现–&gt; 我们这里只是模拟，之后会学到并查集</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/20200208191501154.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311181515302.png" alt="image-20220311181515302"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311182014030.png" alt="image-20220311182014030"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311182902009.png" alt="image-20220311182902009"></p>
<h4 id="prim算法p算法适用范围要求无向图undirected-graphgraph"><a class="markdownIt-Anchor" href="#prim算法p算法适用范围要求无向图undirected-graphgraph">#</a> Prim 算法（P 算法）适用范围：要求无向图 (undirected graph/graph)</h4>
<p>此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<ul>
<li>
<p>任意一个节点开始</p>
</li>
<li>
<p>我们搜索他的 edges, 然后找那个最小 weight 的，看那个 edge 连着的节点是不是已经访问过 (加入到 set 了)</p>
<ul>
<li>已经访问过，那就继续看下一个最小 weight 的 edge 连接的节点</li>
<li>没有访问过，那就把这个节点存入到 set 里面去，并记录这个 edge, 接着把这个新纪录到 set 里面去的节点所有的 edges 放入到小根堆里面，继续找出现在所有的解锁的小根堆里面的有的 edges 按照我们给的比较器规则会找出那个当前最小的 weight 的那个 edge</li>
</ul>
<p>重复，so on…</p>
<p>(这期间可能会把同一个 edges 多次存入到小根堆，这个没事，因为之后我们取出来都会看那个 toNode 是不是已经是在 set 了，如已经在了那个 edge 也不会被处理) 结果就是找到最小生成树，result 存的都是一个一个最小生成树的 edges</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311190946674.png" alt=""></p>
<blockquote>
<p>所以要是问题只是告诉你只是一个连通的，那就没必要那个 for 循环</p>
</blockquote>
<hr>
<h4 id="迪杰斯特拉算法"><a class="markdownIt-Anchor" href="#迪杰斯特拉算法">#</a> 迪杰斯特拉算法</h4>
<p>求解单元点的最短路径问题：给定带权 (weight) 有向图 G 和源点 v，求 v 到 G 中其他顶点的最短路径</p>
<p>限制条件：<strong>图 G 中不可以存在 negative cycle (肯定不行), 也不可以有 negative weight (貌似)</strong></p>
<blockquote>
<p>The algorithm creates a tree of <strong>shortest paths from the starting vertex, the source, to all other points in the graph.</strong></p>
</blockquote>
<p>比如说:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\harry\AppData\Roaming\Typora\typora-user-images\image-20220311191452565.png" alt="image-20220311191452565" style="zoom:50%;" />
<p><strong>要是有 A 节点无法抵达的节点，那么之间的距离就是无限</strong></p>
<p>迪杰斯特拉算法总共就干了两件事：</p>
<p>【1】不断运行广度优先算法找可见点，计算可见点到源点的距离长度</p>
<p>【2】从当前已知的路径中选择长度最短的将其顶点加入 S 作为确定找到的最短路径的顶点。</p>
<blockquote>
<p>有点贪心的意思，每次都锁死一个值，这也为什么不能有 negative weight 因为要是有了那肯定会让之前已经锁死的边的值变，那就不对了</p>
</blockquote>
<ul>
<li>一开始存答案的 hashmap, 每个 key 对应一个图中的节点然后 value 就是 source 到那个节点的最小 weight, 一开始 source 到自己是 0 其他都是无限</li>
<li>先从 source 出发，然后找到他所有的 edges</li>
<li>然后把当前自己的 hashmap 中的值加上每个 edge 的 weight 值然后跟那个 edge 连向的节点当前数组中 hashmap 中的值比较，然后把 hashmap 值改成最小的那个值</li>
<li>处理完这个所有 edges, 我们就相当于结束了由 source 开始的所有 edges (我们也可以锁定当前节点在 hashmap 中的值，因为是第一次所以我们这次锁定就是 source 自己再 hashmap 中的值也就是 0, 他的距离到他自己就是 0)</li>
<li>然后我们从 hashmap 中选出除了以及当过当前节点的比如说 source 的所拥有的最小值的那个节点，然后让那个节点进行一样的操作 (看 edges 然后对于所有的 edges 的 toNodes 让他们的更新), 然后之后我们就把当前的这个节点在 hashmap 中的值锁死，然后让下一个…so on…</li>
<li>直到所有的都锁死了就结束，此时 hashmap 中存的值就是从 source 开始到图中每一个节点所需要的最小 weight (如果没有路就是无限)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311193752158.png" alt="image-20220311193752158"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220311195646125.png" alt="image-20220311195646125"></p>
<blockquote>
<p>一个优化 -&gt; 在选择我们没有处理过且值最小的节点的时候是遍历的方式，可以使用堆结构来存储，然后每次就是存还没处理的，最小值的在堆顶，然后处理过的让他别参加堆结构</p>
<p>但是有一个问题，因为我们那些 values 是存从 source 到每个节点最小的 weight, 所以可能哪次遍历中我们会把一个堆结构中一个节点的值改了改成了一个更小的值，我们知道系统提供的堆结构无法接收让我们改变里面已经在的节点 (你要是硬改，系统里面自己做出的操作其实就跟我们直接遍历的复杂度都差不多了 —&gt; 他需要全局扫描), 所以要是想实现，必须我们自己写一个堆</p>
</blockquote>
<hr>
<h3 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法">#</a> 贪心算法</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312021747214.png" alt="image-20220312021747214"></p>
<h4 id="会议问题"><a class="markdownIt-Anchor" href="#会议问题">#</a> 会议问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312022056453.png" alt="image-20220312022056453"></p>
<ul>
<li>开始时间最早的先安排是不对的，因为这个开始早的很长，之后要是有很多个短的项目都排不上</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312022716370.png" alt="image-20220312022716370" style="zoom:33%;" />
<ul>
<li>时间间隔最短的项目先安排也是不对的，万一你有两个长的在两遍不相互干扰，但是你有个短的正好一部分用了前面的时间另外一部分用了后面的时间</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312023226281.png" alt="image-20220312023226281" style="zoom:33%;" />
<blockquote>
<p>我们在这里正确的贪心的就是</p>
<p>哪一个项目的结束时间早，就先安排谁</p>
<ul>
<li>把当前所有项目哪个结束的最早先安排</li>
<li>然后把所有因为我们安排了那个项目导致进行不了的项目删除掉</li>
<li>接着把下一个结束最早的项目进行安排</li>
</ul>
<p>等等等…</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312023659503.png" alt="image-20220312023659503" style="zoom:33%;" />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312023904383.png" alt="image-20220312023904383"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312025041374.png" alt="image-20220312025041374"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312025437885.png" alt="image-20220312025437885" style="zoom: 67%;" />
<h4 id="贪心题目笔试中套路"><a class="markdownIt-Anchor" href="#贪心题目笔试中套路">#</a> 贪心题目笔试中套路</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312025821548.png" alt="image-20220312025821548"></p>
<blockquote>
<p>多去想，如果想好一个贪心策略，尝试想出一个反例，想出一个就直接 pass 那个贪心策略，继续想别的贪心策略</p>
</blockquote>
<h4 id="字典序例子"><a class="markdownIt-Anchor" href="#字典序例子">#</a> 字典序例子</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312143702630.png" alt="image-20220312143702630"></p>
<blockquote>
<p>而且注意，贪心策略需要注意传递性，像 1&lt;2,2&lt;3 这种都是默认的传递性，而有的传递性就不一样了，需要想好贪心策略</p>
</blockquote>
<p>这里的传递性 (transitivity):</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312144025203.png" alt="image-20220312144025203" style="zoom:50%;" />
<blockquote>
<p>然后各种证明…</p>
</blockquote>
<hr>
<h4 id="金条贪心问题哈夫曼编码树"><a class="markdownIt-Anchor" href="#金条贪心问题哈夫曼编码树">#</a> 金条 (贪心) 问题–&gt; 哈夫曼编码树</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312155028074.png" alt="image-20220312155028074"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312155751777.png" alt="image-20220312155751777"></p>
<ul>
<li>先把数都放进小根堆</li>
<li>接着取出最小的然后 (取完之后那个小根堆结构又形成) 再取那个时候最小的</li>
<li>然后我们拿着这俩相加，也就是当初那个树里面分割自己形成的这两个数，然后那个被分割代表的那个就是所要出的代价 (看下面图，有点难说)</li>
<li>把这个相加的结果记录到一共的代价里面，然后再把这个相加的结果放回小根堆因为为了形成他，当初可能分割了他和另外一个的数的和</li>
<li>重复直到最后只剩一个数，那个数肯定是 60 (in this case), 就一开始的长度</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312161215635.png" alt="image-20220312161215635"></p>
<p><strong><mark>这图只是过程中的一步，11 并不是一开始的长度，27 才是，后面的几步这里没画出来，可以看出来大概就是这么的步骤</mark></strong></p>
<p>最后树的真正样子应该是</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312161422539.png" alt="image-20220312161422539" style="zoom:50%;" />
<blockquote>
<p>贪心策略中</p>
<ul>
<li>堆和排序是最常用的两个技巧</li>
</ul>
</blockquote>
<hr>
<h4 id="项目利润"><a class="markdownIt-Anchor" href="#项目利润">#</a> 项目利润</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312161516503.png" alt="image-20220312161516503" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312161754065.png" alt="image-20220312161754065" style="zoom:50%;" />
<p>想法是:</p>
<ul>
<li>
<p>先把所有的项目按照他们的花费放到小根堆里面去 (自己写比较器)</p>
</li>
<li>
<p><strong>再从小根堆取出当前资金可以花费的所有的项目</strong></p>
</li>
<li>
<p>把那些项目放到一个按照项目利润的大根堆 (自己写比较器)</p>
</li>
<li>
<p>每次花费一个项目获得其利润都要更新当前资金值</p>
</li>
<li>
<p>如果遇到当前资金买不了任何小根堆里面的花费的 (从最低开始比) 也就代表大根堆里面没有元素了，或者已经交易了 k 次，那就直接返回当前资金</p>
</li>
</ul>
<blockquote>
<p>此处的贪心就是按照当前自己的资金可以买的所有的项目中挑选出利润最大的做，做完了更新资金，接着看当前资金可以买的所有的项目中挑选出利润最大的做，…</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312162256738.png" alt="image-20220312162256738"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312162337954.png" alt="image-20220312162337954"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312163152699.png" alt="image-20220312163152699"></p>
<blockquote>
<p>记住这种大根堆小根堆配合的！！！</p>
<p>这里是有两个可以排序的规则</p>
<ul>
<li>花费</li>
<li>利润</li>
</ul>
<p>然后就想一想对于每一个是用大根堆还是小根堆</p>
</blockquote>
<hr>
<h4 id="取得中位数"><a class="markdownIt-Anchor" href="#取得中位数">#</a> 取得中位数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312163741909.png" alt="image-20220312163741909"></p>
<p>就是一个一个给你数，你如何很快地返回一个当前数中的中位数？</p>
<p><strong>答案：大根堆和小根堆！</strong></p>
<ul>
<li>传进来一个数，我们先和大根堆堆顶比
<ul>
<li>如果这个数更小，我们直接放到大根堆里面</li>
<li>如果这个数更大，我们直接放到小根堆里面</li>
</ul>
</li>
<li>然后接着就是检查当前大根堆和小根堆的 size 是不是大于等于 2
<ul>
<li>是的话就需要把 size 更大的那个根堆的元素取出来放到另外一个根堆里面去</li>
<li>不是的话就不用做什么</li>
</ul>
</li>
<li>接着要还传了数，就接着处理</li>
</ul>
<p>这样不管传了多少个数，较小的数都在大根堆里面，较大的数都在小根堆里面</p>
<blockquote>
<p>因为各自维持了堆顶，中位数就很好获取到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312164601228.png" alt="image-20220312164601228"></p>
<blockquote>
<p>然后就是看偶数还是奇数，偶数就是两个堆顶相加除 2, 奇数个就是 size 大的那个根堆的堆顶</p>
</blockquote>
<p>很快，以为大根堆小根堆的调整水平都是 logN 水平的</p>
<hr>
<h3 id="暴力递归"><a class="markdownIt-Anchor" href="#暴力递归">#</a> 暴力递归</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312175619722.png" alt="image-20220312175619722"></p>
<blockquote>
<p>回溯就是在递归的基础之上在每一个步骤上进行标记和取消标记的处理</p>
</blockquote>
<h4 id="n皇后"><a class="markdownIt-Anchor" href="#n皇后">#</a> N 皇后</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312164847529.png" alt="image-20220312164847529"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312165455342.png" alt="image-20220312165455342"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312170554564.png" alt="image-20220312170554564"></p>
<blockquote>
<p>此处的 for 循环检查每一列很关键，这可以直接给出所有可能性，这个性质其实就是 dfs, 每一条路都试了试</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312171339408.png" alt="image-20220312171339408"></p>
<p>斜线就是 dy/dx=1, 也就是 change in x = change in y</p>
<blockquote>
<p>这个算法 ** 时间复杂度是 N<sup>N</sup>** 因为第一行 N 种选择，第二行 N 种选择，第 N 行 N 种选择 —&gt;(NxNxNxNx…) 相乘 N 次</p>
</blockquote>
<p>这个复杂度优化不了，但是我们可以做些常数优化:</p>
<p><strong>用位运算加速！</strong></p>
<p>… 比较复杂</p>
<h4 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题">#</a> 汉诺塔问题</h4>
<p>解题思路：from: 圆盘所在位置；to: 圆盘要去的地方；help: 用于辅助</p>
<ol>
<li>n-1 个圆盘从 from 到 help； (也就是左 -&gt; 中，此时 help 就是右)</li>
<li>第 n 个圆盘从 from 到 to； (也就是左 -&gt; 右，此时 help 就是中)</li>
<li>把那 n-1 个圆盘从 help 移动到 to 上面来。 (也就是中 -&gt; 右，此时 help 就是左)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312233815071.png" alt="image-20220312233815071"></p>
<h4 id="打印一个字符串的全部子序列subsets包括空字符串"><a class="markdownIt-Anchor" href="#打印一个字符串的全部子序列subsets包括空字符串">#</a> 打印一个字符串的全部子序列 (subsets)，包括空字符串</h4>
<ul>
<li>区分子串和子序列： 给定 “pwwkew”
<ol>
<li>子串是 pww,wwk 等很多个子串 是连在一起的</li>
<li>子序列是 pwk,pke 等很多个子序列 ，但是子序列中的字符在字符串中不一定是连在一起的。</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_03_PrintSubString</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printSubStr</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token class-name">String</span> res<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printSubStr</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不需要当前的字符的</span>
        <span class="token function">printSubStr</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>res <span class="token operator">+</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//需要当前的字符的</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
        <span class="token function">printSubStr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">//输出 </span>
   <span class="token punctuation">(</span>包含一个空字符串<span class="token punctuation">)</span>
c
b
bc
a
ac
ab
abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>老师做法:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220312235754710.png" alt="image-20220312235754710"></p>
<h4 id="打印一个字符串的全部子序列要求不要出现重复字面值的子序列"><a class="markdownIt-Anchor" href="#打印一个字符串的全部子序列要求不要出现重复字面值的子序列">#</a> 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</h4>
<p>输出前，加入 set 去重</p>
<h4 id="打印一个字符串的全部排列"><a class="markdownIt-Anchor" href="#打印一个字符串的全部排列">#</a> 打印一个字符串的全部排列</h4>
<p>举个栗子：</p>
<p>字符不重复的情况下：<br>
输入：abc<br>
 输出：abc acb bac bca cab cba</p>
<p>字符重复的情况下：<br>
输入：acc<br>
 输出：acc acc cac cca cca cac</p>
<p>解题思路：把一个字符串看成由两部分组成：第一部分是它的第一个字符；第二部分是后面的所有字符。而我们求整个字符串的排列，可以看成两步。</p>
<p>求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。<br>
固定第一个字符，求后面所有字符的排列。<br>
<strong>这时候我们仍把后面的所有字符分成两个部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符和它后面的所有字符交换。（重复 1、2 步骤）</strong></p>
<p><strong>printAllPermutations2 为分治限界方法，可以减少递归次数</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_04_Print_All_Permutations</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAllPermutations1</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">process1</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//交换的是当前位置之后的元素</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
        <span class="token comment">//如果i没有终止，i... 都可以来到位置</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//这个的理解是难点</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">process1</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

    <span class="token comment">// 在选择位置时就利用set ，减少递归次数，时间换空间</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAllPermutations2</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">process2</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">process2</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">char</span> tmp <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">String</span> test1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
		<span class="token function">printAllPermutations1</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printAllPermutations2</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token class-name">String</span> test2 <span class="token operator">=</span> <span class="token string">"acc"</span><span class="token punctuation">;</span>
		<span class="token function">printAllPermutations1</span><span class="token punctuation">(</span>test2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printAllPermutations2</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
 <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>老师做法:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313120537000.png" alt="image-20220313120537000"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313120453872.png" alt="image-20220313120453872"></p>
<ul>
<li>那个 str 的 char array 相当于就是我们递归的每一层所做的选择</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313120821082.png" alt="image-20220313120821082" style="zoom: 67%;" />
<blockquote>
<p>个人认为那个 for 循环才是秒</p>
<ul>
<li>首先一般你要考虑各种可能性 (然后这个可能性是指这第一个元素各种可能性，第二个元素也是各种可能性，so on…), 那么就可以考虑 for 循环第一个给他安排各种选择，然后递归调用自己的 (也就是对于他第二个元素等等), 然后那一层接着会调用下一层</li>
<li>这样就做到了每一层接着都实现了各种可能性，当然要保证 base case 到达了之后我们做出我们对于每种可能性的结果做出合理的处理 (存起来？打印？返回上一层？等等等)</li>
<li>我们还可以设置各种条件，比如说当前元素有没有已经存在等等等 (这个操作可能需要我们额外传一些参数，这样每一层都能知道当前状况) 如果有，也不要继续递归直接返回什么的，相当于把这个 branch 直接断掉了</li>
</ul>
</blockquote>
<h4 id="打印一个字符串的全部排列要求不要出现重复的排列"><a class="markdownIt-Anchor" href="#打印一个字符串的全部排列要求不要出现重复的排列">#</a> 打印一个字符串的全部排列，要求不要出现重复的排列</h4>
<ul>
<li>
<p>举个栗子：</p>
<blockquote>
<p>输入：acc<br>
 输出：acc cac cca</p>
</blockquote>
</li>
</ul>
<p>思路同上，加入了 HashSet 来去重。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintAllSort</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAllSort</span><span class="token punctuation">(</span><span class="token class-name">String</span> string<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>string <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">// 对i及i以后的字符进行全排序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
 
        <span class="token comment">// 用于保证每次交换的字符不存在重复字符</span>
        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 只有之前没有交换过这个字符才会交换</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 第i个位置有i~n-1这些选择</span>
                <span class="token function">func2</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 搞第i+1的位置</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">// 测试</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printAllSort</span><span class="token punctuation">(</span><span class="token string">"acc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>老师做法:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313134118572.png" alt="image-20220313134118572"></p>
<blockquote>
<p>这种方式比拿到所有数据然后去重要快，因为这里直接如果不达标，那整条路都不用走 **(把不可能的路直接杀死)**, 就不需要拿到所有数据–&gt; 这里就是分支限界–&gt; 时间复杂度并没有减少，因为要是这个条件根本没有复合的那还不一样都是所有的 (branches) 数据，只是常数项有优化罢了</p>
</blockquote>
<hr>
<h4 id="纸牌"><a class="markdownIt-Anchor" href="#纸牌">#</a> 纸牌</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313134624228.png" alt="image-20220313134624228"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313145906219.png" alt="image-20220313145906219"></p>
<hr>
<h4 id="逆序栈"><a class="markdownIt-Anchor" href="#逆序栈">#</a> 逆序栈</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220313145949058.png" alt="image-20220313145949058"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313151337702.png" alt="image-20220313151337702"></p>
<hr>
<h4 id="数字与字符串对应"><a class="markdownIt-Anchor" href="#数字与字符串对应">#</a> 数字与字符串对应</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313151458138.png" alt="image-20220313151458138"></p>
<blockquote>
<p>还是从左到右试，<strong> 从左到右试时很经典的方法！</strong></p>
</blockquote>
<p>我们要这么想 (即使是假设)</p>
<ul>
<li>首先就想 0 到 i-1 位置的元素都已经处理好了</li>
<li>我们只关心 i 到 nums.length-1 就行</li>
</ul>
<p>如果我们这个当前 i 位置的是</p>
<ul>
<li>0 的话，0 没有任何对应的，所以应该是跟之前的已经定好的搁一块决定的，我们直接返回 0</li>
</ul>
<blockquote>
<p>0 字符的话后面怎么转都没有效，因为我们没有 0 对应的字符也没有 0 开头的数字对应的字符</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313151859688.png" alt="image-20220313151859688" style="zoom:50%;" />
<ul>
<li>不是 0 的话
<ul>
<li>我们可以让那个元素直接变成对应的字符，然后处理 i+1 到 nums.length-1 就行</li>
<li>我们也可以看这个字符是 1,2 还是 3-9
<ul>
<li>如果是 3-9, 我们不可以让他跟 i+1 位置的字符结合，因为我们不能有 3 (以及) 开头的数字，(最高也只是 26 个字符，按照题目), 所以我们只能让他自己这个数字直接换，不要想什么跟 i-1 的位置结合，i-1 的位置是定的！对于我们当前层来说，i-1 那层他自己 (只要我们递归的逻辑做对) 自然会按照我们的逻辑试出他所可以的可能性的</li>
<li>如果是 1, 我们总可以让他跟 i+1 位置的数字结合，然后只处理 i+2 以及以后的 (因为开头是 1 的话，个位数任何树都可以有对应的字符)</li>
<li>如果是 2, 我们就可以看他跟 i+1 位置的数字结合有没有超过 26, 超过了我们就不可以，没超过我们就可以结合，然后只处理 i+2 以及以后的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313155624456.png" alt="image-20220313155624456"></p>
<hr>
<h4 id="物体重量和价值"><a class="markdownIt-Anchor" href="#物体重量和价值">#</a> 物体重量和价值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313155846171.png" alt="image-20220313155846171"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316165110672.png" alt="image-20220316165110672"></p>
<blockquote>
<p>思想就是，我们暴力递归</p>
<ul>
<li>取不加当前重量和加当前重量的最大值
<ul>
<li>如果不加当前重量，就接着取不加下一个重量和加的重量的最大值</li>
<li>如果加当前重量，就接着取不加下一个重量和加的重量的最大值</li>
</ul>
</li>
<li>反正我们 return 那里有 Math.max 确保我们每一层返回的都是最大可能性，然后这个是暴力递归 (除了一开始的 if statement 检测当前有没有已经超过了重量，相当于是分支限界) 确保了我们考虑到了每一个合法的可能性然后把最大的一层一层的返回出去了.</li>
</ul>
</blockquote>
<blockquote>
<p>暴力递归尽量选</p>
<ul>
<li>可变的参数为少的</li>
<li>可变的参数形式最简单 (一个值，不要链表什么的，除非必须要)</li>
</ul>
</blockquote>
<hr>
<h3 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数">#</a> 哈希函数</h3>
<ul>
<li>输入可以是无穷大，输出是有限范围内</li>
<li>同样的输入，同样的输出</li>
<li>不同输入可能会有同样的输出–&gt; 毕竟无限输入然后输出是有限的</li>
<li>均匀的，离散的，分散在哈希表</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220313235055319.png" alt="image-20220313235055319" style="zoom:80%;" />
<p>如果想要一张哈希表存大量的数据，放到内存里面，那么如果数据不一样的话，哈希表占用很大的，我们希望数据是有很多是重的，这样多个只不过是对于那个重复的元素的 value 改变改的更大而不是不同数据的那样让很多位置都占满</p>
<ul>
<li>这样我们可以把那些一堆数据 apply 哈希函数，让他们均匀的分散的在哈希表</li>
<li>然后再对哈希函数取模 (比如说 100), 再把对应数据存到对应取模后的位置</li>
<li>那么这样我们最多也就是 0-99 个 key, 而且因为哈希函数保证能差不多均匀的分散来–&gt; 相当于是把数据都分散到 100 个<strong>文件上 (存到硬盘)</strong></li>
<li>那么我们取模后所有数据也都是均匀的分散开来</li>
<li>而我们需要某一个数据处理的时候，我们只需要获取一个 key 对应的值，然后只对那个放内存做处理，这样就做到了不用整张表一大堆 key 都放到内存，可能会让内存爆掉如果内存空间不足</li>
<li>我们哈希表每一个对应的下标位置可以存的也是哈希表，只不过这个是更小数据，内存不会爆</li>
<li>如果想要处理多个下标的数据，我们可以一个一个来，先把第一个放到内存里面处理，接着第二个，… 所以内存是不会爆的</li>
</ul>
<p>如果有一个下标的链表长度超过一个数 (说明其他也都差不多，均匀分散开来), 那么就会扩容</p>
<p>比如说直接扩容成两倍，那么每一个数就接着哈希函数均匀的分散在新的扩容后的哈希表里</p>
<ul>
<li>就比如说想找一个东西，那么会先哈希值 (O (1)), 然后模一个值 (O (1))</li>
<li>找到了下标就会去那个下表的链表找，如果链表长度为 k, 那么就会是 O (k)</li>
<li>如果链表不是特边长，那么查删改一个数据都是 O (1), 因为 k 接近于常数</li>
</ul>
<p>扩容代价:</p>
<ul>
<li>如果加了 n 个数据，就会最多最多 (也就是每次翻倍都会扩容) 经历 log (n) 次扩容，实际扩容次数远远少于 log (n) 不过只是常数减少，还是这个级别</li>
<li>每次扩容都需要 O (n) 的代价 (重新算哈希值，取模，然后挨个放到对应的位置去)</li>
<li>总扩容代价就是 O (NlogN), 这是对于加了 n 个数据的扩容的代价</li>
</ul>
<p>我们除以 n 就可以得出，<strong> 单次查询，删除，更改一个数据的平均代价就是 O (logn) 的级别</strong></p>
<blockquote>
<p>这个 O (logn) 会是小常数，如果链表不要太长</p>
</blockquote>
<p>java 虚拟机可以帮助我们做哈希离线技术</p>
<p><strong>就是我们一个哈希表做扩容不占用用户用哈希表的在线时间的</strong></p>
<p>实际上哈希表用起来无比接近于 O (1)</p>
<blockquote>
<p><strong>但是理论就是 O (logn)</strong></p>
</blockquote>
<hr>
<h4 id="设计一个数据结构"><a class="markdownIt-Anchor" href="#设计一个数据结构">#</a> 设计一个数据结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220314234043726.png" alt="image-20220314234043726"></p>
<ul>
<li>两个 map
<ul>
<li>一个是数据 key,index 作为 value</li>
<li>一个是数据 value,index 作为 key</li>
</ul>
</li>
<li>一个记录 size, 一开始是 0</li>
</ul>
<p>我们只需要随机生产 0-size-1 的值，就可以等概率获得一个数字，然后用 map 取就行了</p>
<p>对于删除操作，我们可以先通过那个 key 在 map 里面找到对应的 index, 然后更新那个 index 到那个被删除的数据的 index, 然后更新 size</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220314235001481.png" alt="image-20220314235001481"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220314235909460.png" alt="image-20220314235909460"></p>
<blockquote>
<p>使用一个或多个哈希表，可以做到很多操作变成 O (1) 操作！实际上来说 (虽然哈希表是 log (N) 的操作，但是之前提到的技术可以做到实际就是 O (1) 的)</p>
</blockquote>
<hr>
<h3 id="岛问题和并查集"><a class="markdownIt-Anchor" href="#岛问题和并查集">#</a> 岛问题和并查集</h3>
<h4 id="岛问题"><a class="markdownIt-Anchor" href="#岛问题">#</a> 岛问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315014825295.png" alt="image-20220315014825295"></p>
<ul>
<li>遍历如果遇到一个 1, 就把当前位置给到一个 infect 函数</li>
<li>这个函数就会把这个位置以及周围是 1 的全部变成 2</li>
<li>此时我们就可以让 ans++, 说明找到一个岛</li>
<li>然后我们继续遍历，如果遇到是 2 就继续找，只有是 1 的时候我们才把当前位置传给 infect</li>
<li>so on…</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315015206674.png" alt="image-20220315015206674"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315015352747.png" alt="image-20220315015352747"></p>
<blockquote>
<p><strong>这整个的时间复杂度是 O (n*m),n 代表 number of rows, m 代表 number of columns (就是主函数里面那个 nested for loop)</strong></p>
<p>外面那个 nested for loop 会碰每一个元素一次</p>
<p>虽然 infect 是递归但其实并不高，每一个位置的元素只能被他的上下左右触及到，所以每一个位置的元素在 infect 阶段最多最多调用四次，所以整个 infect 每个元素都是被调用有限几次。不要想一个位置调用谁，而是想一个位置被谁调用了</p>
<p>那个还是外面那个 nested for loop 最耗时间</p>
</blockquote>
<p><strong>并行算法解决这个问题:</strong></p>
<blockquote>
<p>注意 acm, 面试，一般都是单 cpu, 单进程的题目</p>
<p>但是也有可能是并行触发的题目–&gt; 并发集</p>
</blockquote>
<hr>
<h4 id="并查集"><a class="markdownIt-Anchor" href="#并查集">#</a> 并查集</h4>
<p>一个支持集合合并非常快速的结构</p>
<p>有两个操作:</p>
<ol>
<li>检查两个集合是不是同一个集合</li>
<li>把两个集合变成一个集合</li>
</ol>
<p>用我们经典的数据结构，无法做到两个操作都是 O (1), 反正至少一个得要比遍历</p>
<p><strong>我们并查集就可以在 O (1) 时间复杂度实现这两个操作</strong></p>
<p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/80/v2-09fa3fa35e5411444b327d9cb9a31057_720w.jpg" alt="img"></p>
<p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p>
<p>现在 1 号和 3 号比武，假设 1 号赢了（这里具体谁赢暂时不重要），那么 3 号就认 1 号作帮主 *（合并 1 号和 3 号所在的集合，1 号为代表元素）*。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/80/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_720w.jpg" alt="img"></p>
<p>现在 2 号想和 3 号比武 *（合并 3 号和 2 号所在的集合）<em>，但 3 号表示，别跟我打，让我帮主来收拾你</em>（合并代表元素）*。不妨设这次又是 1 号赢了，那么 2 号也认 1 号做帮主。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-be12a6c795572d2acd77dcd49de35127_720w.jpg" alt="img"></p>
<p>现在我们假设 4、5、6 号也进行了一番帮派合并，江湖局势变成下面这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-3c353bc781c7f3553079d541a9cfdc28_720w.jpg" alt="img"></p>
<p>现在假设 2 号想与 6 号比，跟刚刚说的一样，喊帮主 1 号和 4 号出来打一架（帮主真辛苦啊）。1 号胜利后，4 号认 1 号为帮主，当然他的手下也都是跟着投降了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.jpg" alt="img"></p>
<p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p>
<h5 id="路径压缩"><a class="markdownIt-Anchor" href="#路径压缩">#</a> 路径压缩</h5>
<p>最简单的并查集效率是比较低的。例如，来看下面这个场景：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg" alt="img"></p>
<p>现在我们要 merge (2,3)，于是从 2 找到 1，fa [1]=3，于是变成了这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg" alt="img"></p>
<p>然后我们又找来一个元素 4，并需要执行 merge (2,4)：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/80/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg" alt="img"></p>
<p>从 2 找到 1，再找到 3，然后 fa [3]=4，于是变成了这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/v2-23c367515ace6fc0603692dfd865849f_720w.jpg" alt="img"></p>
<p>大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p>
<p>怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/80/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg" alt="img"></p>
<blockquote>
<p>其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。<mark>下一次再查询时，我们就可以省很多事。</mark></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315220630416.png" alt="image-20220315220630416"></p>
<p>这个就代表我们那个圈，就是不管什么类型进来我们就先让变成一个集合 (像是), 相当于给他包装一层就是这个 element 类</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315221623242.png" alt="image-20220315221623242"></p>
<blockquote>
<p>并查集使用的前提就是初始化的时候把所有数据给我们了，这样我们才可以挨个包装成 Element 然后你接着可以做检查是不是同一集合，以及把两个不是同一个集合的合并成一个集合这种操作。注意这里面数据只是针对于你一开始初始化的，不能使用别的数据</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315222014419.png" alt="image-20220315222014419"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315222834926.png" alt="image-20220315222834926"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315223450337.png" alt="image-20220315223450337"></p>
<blockquote>
<p>所以我们只需要调用并查集的构造函数把所有数据传进去</p>
<p><strong>之后我们就可以对这些数据调用 isSameSet 和 Union 方法，然后时间复杂度很低 O (1)</strong></p>
<p>尽管这两个方法都调用了 findHead 方法，<strong> 其实只要方法被调用够多次数 (O (n) 次)(他内部那个扁平化优化), 其实调用他的时间复杂度是非常非常接近于 O (1)</strong>—&gt;(他的证明很难很难，花了 20 多年才证明出来)</p>
</blockquote>
<hr>
<h4 id="使用并查集解决岛问题"><a class="markdownIt-Anchor" href="#使用并查集解决岛问题">#</a> 使用并查集解决岛问题</h4>
<p>比如说岛问题给的二维数组特别特别大，那么我们之前那种方法只用一个 CPU 就会非常非常耗时间</p>
<p>首先，使用两个 CPU:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315224757842.png" alt=""></p>
<p>其实我们整个来看就一个岛，但是</p>
<ul>
<li>处理左边的 CPU 找到两个岛</li>
<li>处理右边的 CPU 也会找到两个岛</li>
</ul>
<p>这是不对的，所以我们两个 CPU 需要想一个合并逻辑去求出一个正确的岛的数量</p>
<p>我们合并逻辑</p>
<ul>
<li>首先记录我们从哪个点开始感染每一块岛</li>
<li>对于每个感染到的在边缘 (<strong>分割的边缘</strong>), 我们给他们做个记号 (记号就是我们开始感染的那个点)</li>
</ul>
<p>比如说处理我们左边的 CPU 的数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315225517142.png" alt="image-20220315225517142"></p>
<p>右边同理:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315225552604.png" alt="image-20220315225552604"></p>
<p>做合并:</p>
<p>一开始有多少 (从哪开始的) 感染点–&gt; 四个，ABCD, 所以相当于传进去给并查集的构造函数形成四个集合</p>
<p>然后左边右边 CPU 分割算出 2 个岛，也就是一共 4 个岛</p>
<ul>
<li><strong>我们对于 (分割的) 边缘那块连在一起的集合 (如果他们不是同一个集合) 让他们连在一起</strong>，然后让总共岛数 - 1</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220315225849552.png" alt="image-20220315225849552"></p>
<p D="">此时集合是 {A,C} {B}</p>
<ul>
<li>接着看，此时 B 所在的岛和 C 所在的岛 **(他们代表的集合不是同一个，而且还在边缘除相连接，所以就合并！)** 合并在一起，总数 - 1</li>
</ul>
<p D="">此时集合是 {A,C,B}</p>
<ul>
<li>同理 B 和 D 代表的集合不是同一个，而且还在边缘除相连接，所以就合并，总数 - 1</li>
</ul>
<p A,C,B,D="">此时集合是</p>
<ul>
<li>然后 A 和 D 检查，现在是一同一个集合了！！！所以不用 - 1 (而且因为之后也没有其他集合要检查了，如果有的话就继续看然后合并等等等), 也就是现在岛数就是 1, 也就是正确答案</li>
</ul>
<blockquote>
<p>这样就做到了两个 CPU 分别处理一半，然后最后合并等等操作还是正确答案，当然比一个 CPU 处理整块快</p>
</blockquote>
<p>多个 CPU:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315230744390.png" alt="image-20220315230744390"></p>
<blockquote>
<p><strong>同理，分成好多块，然后让每一个 CPU 收集四边 (四边都要！) 的信息，然后就可以之后合并就跟四边都要合并一下</strong>，最后合并成一大块，速度当然非常快</p>
</blockquote>
<hr>
<h3 id="kmp"><a class="markdownIt-Anchor" href="#kmp">#</a> KMP</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315231133683.png" alt="image-20220315231133683"></p>
<p><strong>暴力解法的时间复杂度是 O (n*m)–&gt;n 是 str1 的长度，m 是 str2 的长度</strong></p>
<p>我们需要遍历 str1 然后每一个开头我们都可能要检查接下来的 m 字符看对不对，如果不对要接着 str1 下一个字符看 (不可以直接跳！) 接下来的 m 字符看对不对</p>
<p><strong>KMP</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315232205307.png" alt="image-20220315232205307"></p>
<p>不要取到整的是因为取到整到的话，自己当然跟自己一样，所以没有意义</p>
<p><strong>所以 k 这个字符存什么信息？存对于他之前那些字符比较，最大的且一样前后缀的那个才是，这里就是 3</strong></p>
<p><mark>对于 **str2 (不是对于较长的 str1 求的！！)** 每一个字符，我们都需要这样的信息</mark></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315234602662.png" alt="image-20220315234602662"></p>
<blockquote>
<p>注意对于</p>
<ul>
<li>第一个字符，因为前面压根没有任何字符，我们直接就是 **-1**</li>
<li>第二个字符之前就一个字符，其实怎么样都会是<strong> 0</strong></li>
<li>其他就正常的像我上面说的求</li>
</ul>
<p>这个 next 数组，就代表我们知道 str2 这个字符串中，任何一个字符<strong>他前面的字符串最长的前缀和后缀的长度</strong>，我都知道</p>
</blockquote>
<p>我们可以拿和这个 next 数组做到 KMP 加速，解决问题</p>
<p>列子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315235123057.png" alt="image-20220315235123057"></p>
<ul>
<li>如果是经典暴力做法：我们发现这个不一样，我们就会<strong> str1 中 X 的位置回跳到 i+1 位置</strong>以及<strong> str2 中 Y 的位置回跳到 0 位置</strong>，继续开始比</li>
<li>如果是 KMP 做法：当我们第一次发现 str1 和 str2 有一个字符不一样 (X 和 Y), 我们就知道 str2 中对于这个 Y 字符他前面的字符串最长的前缀和后缀的长度，比如说这一块 (他们当然可以相交，就是错过去，这里只是为了好看理解就放了那么两端的前缀和后缀):</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315235526115.png" alt="image-20220315235526115"></p>
<p>我们让 str1 中不要回跳到 i+1 位置，还是待在 X 的位置</p>
<p>我们让 str2 中会跳到这个位置:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315235754143.png" alt="image-20220315235754143" style="zoom:50%;" />
<p><strong>然后让当前 str2 中新的这个位置和 str1 的 X 的位置相比，看看是不是同一个字符</strong></p>
<p>这个相当于是把前缀位置给推倒后缀相同的部分的位置上去</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316000032986.png" alt="image-20220316000032986" style="zoom:67%;" />
<blockquote>
<p>原来我们是检查 i 开头能不能配出 str2, 现在我们这么做了后，相当于是检查 j 开头的能不能配出 str2, 我们只让可能不同的位置往下验</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316001158507.png" alt="image-20220316001158507"></p>
<p>这么做，我们就可以</p>
<ul>
<li>不用让 str1 回到 i+1 位置 (也有可能回到，具体看 str2 的那个 next 数组), 而是像图里面一样直接让从 x 位置重新比，只不过这次要是找到了，那么返回的开始 index 是 j 而不是 i, 相当于此时是从 j 比的，但我们并没有真正从 j 然后 j+1,… 开始比的，而是直接跳过了直接比 x 因为我们知道 j,j+1,…,x-1 位置上的元素一定跟我们的 str2 的 u,u+1,…,y-1 位置的元素一样，我们才会比到 X 和 Y 位置，我们还知道 u,u+1,…,y-1 这一块，按照我们 Y 字符对应的 next 数组的下标的位置知道对应的前缀是哪一块，也就是 v,v+1,…,k-1, 所以 j,j+1,…,x-1==v,v+1,…,k-1, 这一块是两个 str 都一样的，我们接着只需要比较 str1 的 x 的位置和 str2 的 k 位置的元素是不是同一个就行了 **(前面我们已经确定是一样的了)**, 如果是同一个，那么如果 str1 如果还有元素，就会跟 str2 接下来的 (k+1,k+2,…) 的元素比，如果没有的话，那就不对了，我们这个 str2 当前还没比的元素明显还有，所以就返回没有找到。我们还知道 i 位置到 j-1 位置一定 (作为开头) 配不出 str2, 所以我们把检查位置直接挪到 j 位置.</li>
<li>我们也不需要让 str2 回到 0 (v) 位置继续比，我们直接回到 k 位置就行了，道理上面都说了</li>
</ul>
<p>相当于两个字符串回去的程度都没暴力方式的那么多罢了，道理还是一样的，一个一个比等等等</p>
</blockquote>
<p>具体例子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316002149249.png" alt="image-20220316002149249"></p>
<p>暴力解法：发现最后那一个不一样，会接着从 i+1 也就是 b 开始比 (跟 str 的 0 位置也就是 a) 看看一不一样，发现第一个就不一样，接着就是 i+2…</p>
<p>KMP:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316002400093.png" alt="image-20220316002400093"></p>
<p>相当于我们把 str2 给往右挪了:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316002837964.png" alt="image-20220316002837964"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316002813543.png" alt=""></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316003332774.png" alt="image-20220316003332774" style="zoom:67%;" />
<p>如果这么假设，那就代表:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316003814053.png" alt="image-20220316003814053"></p>
<p>可以看出，我们这里岂不是找出了一个对于 y 字符他当前 next 对应下标存的值还要大的值–&gt; 就是比我们之前看 str2 算 next 数组，出现了更大的对于 y 字符前面的字符串来说前缀和后缀相等的情况–&gt; 这不可能，因为我们 next 存的就是最大最大的对于 y 字符前面的字符串来说前缀和后缀相等的长度，所以我们的假设是不对的，证明 i 到 j-1 位置会有开头然后会匹配 str2 的情况是不可能发生的</p>
<blockquote>
<p><strong><mark>所以我们可以直接从 i 位置跳到 j 位置，不用担心中间的字符会有开头然后会匹配 str2 的情况发生 (因为压根不会发生！)</mark></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316104218266.png" alt="image-20220316104218266"></p>
<p>时间复杂度:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316110459770.png" alt=""></p>
<blockquote>
<p>这两个变量在我们的 while 循环里面，最大幅度就是 2N, 所以那个 while 循环时间复杂度就是 O (N)</p>
</blockquote>
<p><strong>找 next 数组:</strong></p>
<ul>
<li>
<p>第一个默认是 - 1</p>
</li>
<li>
<p>第二个默认是 0</p>
</li>
<li>
<p>之后每一个 i 位置都要靠前面的 i-1 位置的元素得出</p>
</li>
<li>
<p>对于 i 位置来说，如果 next 数组的 i-1 位置是 x, 那么你需要在 str2 里面的 x 位置的元素跟 i-1 位置的元素比较</p>
<ul>
<li>如果一样，那么 next 数组中，<strong>i 位置的元素是 x+1</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316111321420.png" alt="image-20220316111321420"></p>
<blockquote>
<p>必须是 x+1, 可以反证如果不是的话，那么 next 数组中 i-1 位置的元素就不会是 x 了</p>
</blockquote>
<ul>
<li>
<p>如果不一样，比如说 next 数组中 x 位置存的是 y, 那么现在就去 str2 里面拿 y 位置的字符跟 i-1 位置字符比</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316112049743.png" alt="image-20220316112049743"></p>
<ul>
<li>如果一样，那么 next 数组中，<strong>i 位置的元素是 y+1</strong></li>
<li>如果不一样，继续跳…</li>
</ul>
<p>直到最后跳到 next 数组的 0 位置比较</p>
<p>-&gt; 如果一样那么，i 位置的元素是 1</p>
<p>-&gt; 如果不一样，就是 0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316120205360.png" alt="image-20220316120205360"></p>
<p>这个的时间复杂度:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316120241659.png" alt="image-20220316120241659"></p>
<blockquote>
<p>跟之前 KMP 主方法一样的，都是线性的，也就是 O (M) 时间复杂度</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>整个复杂度:</p>
<p>我们知道获取 next 数组是 O (M) 的–&gt;M 是 str2 的长度</p>
<p>我们知道 KMP 主方法是 O (N) 的–&gt;N 是 str1 的长度</p>
<p><strong>我们还知道 str1 是至少要比 str2 长的</strong>，<mark> 所以整个 KMP 算法就是 O (N)</mark>.</p>
<hr>
<h3 id="manacher算法"><a class="markdownIt-Anchor" href="#manacher算法">#</a> Manacher 算法</h3>
<blockquote>
<p>解决字符串最长的回文子串的问题，以及很多…</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316120739796.png" alt="image-20220316120739796"></p>
<p>一般解法:</p>
<ul>
<li>每个字符作为中心轴，像左右两边阔，看看是不是回文</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316121232740.png" alt="image-20220316121232740"></p>
<p>但是这种方法，可能会因为长度为偶数，而错过某个回文，比如说:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316121324394.png" alt="image-20220316121324394"></p>
<p>解决方法，加一个 #到最前面和最后面，然后每两个字符之间加一个#</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316121413600.png" alt="image-20220316121413600"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316121604135.png" alt="image-20220316121604135"></p>
<p><strong>然后再对每一个字符做出这种操作，就可以获得每个字符左右的回文包括 #的，然后我们需要 / 2 就可以获得对于每一个字符正确的回文长度 (相当于除 2 是把所有 #给清掉了)</strong></p>
<blockquote>
<p><strong>其实加的特殊字符是什么都行，就算是原本数组里面有这个字符也没事，不会影响最后答案的！</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316122022474.png" alt="image-20220316122022474"></p>
<blockquote>
<p>经典做法的时间复杂度就是 O (N<sup>2</sup>), 因为比如说:</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316122129541.png" alt="image-20220316122129541"></p>
<p>不管是哪个元素都会扩到两边头，然后又有 n 个元素，所以就是 O (N<sup>2</sup>)</p>
<p><strong>Manacher 也是差不多想法，但是做了加速，导致时间复杂度为 O (N)</strong></p>
<ul>
<li>首先有个 R 变量，一开始是 - 1, 在我们看每一个字符的回文的时候，记录当前最大的右边界的值</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316122824285.png" alt="image-20220316122824285" style="zoom:67%;" />
<ul>
<li>然后有个 C 变量，一开始是 - 1, 在我们看每一个字符的回文的时候，找到的就是对于那个字符找到的那个回文的中心位置，这个 C 也是只存最右的中心位置</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5Charry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220316123200000.png" alt="image-20220316123200000"></p>
<p>…(看下方！)</p>
<h4 id="原始问题"><a class="markdownIt-Anchor" href="#原始问题">#</a> 原始问题</h4>
<p>Manacher 算法是由题目 “求字符串中最长回文子串的长度” 而来。比如 abcdcb 的最长回文子串为 bcdcb，其长度为 5。</p>
<p>我们可以遍历字符串中的每个字符，当遍历到某个字符时就比较一下其左边相邻的字符和其右边相邻的字符是否相同，如果相同则继续比较其右边的右边和其左边的左边是否相同，如果相同则继续比较……，我们暂且称这个过程为向外 “扩”。当 “扩” 不动时，经过的所有字符组成的子串就是以当前遍历字符为中心的最长回文子串。</p>
<p>我们每次遍历都能得到一个最长回文子串的长度，使用一个全局变量保存最大的那个，遍历完后就能得到此题的解。但分析这种方法的时间复杂度：当来到第一个字符时，只能扩其本身即 1 个；来到第二个字符时，最多扩两个；……；来到字符串中间那个字符时，最多扩 (n-1)/2+1 个；因此时间复杂度为 1+2+……+(n-1)/2+1 即 O (N^2)。但 Manacher 算法却能做到 O (N)。</p>
<p>注意：在找回文的过程中，一般要在每个字符中间插入 #之类的间隔符，来避免奇数和偶数的差别回文</p>
<h4 id="补充概念"><a class="markdownIt-Anchor" href="#补充概念">#</a> 补充概念：</h4>
<p>回文直径：以一个位置为中心，扩出来整个串的长度为回文直径<br>
回文半径：以一个位置为中心，扩出来半个串长度为回文半径<br>
回文数组：对于字符串而言，从 0 位置开始，一直到最后，新建一个数组，数组中保存对应位置的回文半径。<br>
最右回文右边界：所有回文半径中，最靠右的边界，回文右边界只要没更新，记录最早取得此处的回文中心。</p>
<p>Manacher 在向外扩展的过程整体跟之前的算法相似，但是有加速。</p>
<h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤">#</a> 【步骤】</h4>
<ol>
<li>
<p><strong>回文右边界 R 不包含位置 i，此时暴力扩展，直到 R 包含 i。</strong>(就是当前位置是&gt; R 当时的值，就是不包含，只能暴力扩展)</p>
</li>
<li>
<p>i 位置在回文有边界内时 (当前位置 &lt;=R 当时的值)，知道了回文右边界可以知道回文左边界，对称中心为 c，此时关于 c 做 i 的对称点 i‘</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316162218542.png" alt="image-20220316162218542"></p>
<ul>
<li>若 i‘的回文彻底在 c 为中心的回文里面，<strong>此时 i 的回文半径和 i’的回文<mark>半径</mark>相同 (所以全径也相同)</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316163233157.png" alt="image-20220316163233157"></p>
<blockquote>
<p>注意正常来讲中间都是加特殊字符的只是这里为了方便而没有那么做</p>
</blockquote>
<ul>
<li>i 位置的对称位置 i’的回文半径越过了以 c 为中心的左边范围。（i‘扩出的范围以 c 为中心的回文没包住，存在一部分在回文直径外面）<em><em>此时 i 的回文<mark>半径</mark>是 R-i (所以全径就是 2</em> (R-i) 长度)</em>*</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316171747843.png" alt="image-20220316171747843"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220316173508899.png" alt="image-20220316173508899"></p>
<blockquote>
<p>注意正常来讲中间都是加特殊字符的只是这里为了方便而没有那么做</p>
</blockquote>
<ul>
<li>正好 i‘的回文半径正好跟左边 L 相等，此时可以直到 i 的回文半径大于等于 R-i (<strong>其实 this case 就是 i’的半径</strong>)，然后需要判断 R 后面的位置，重新返回第一步 (<strong><mark>因为不确定 i 的回文有没有可能更远</mark></strong>)。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318214440252.png" alt="image-20220318214440252"></p>
<blockquote>
<p>注意正常来讲中间都是加特殊字符的只是这里为了方便而没有那么做</p>
</blockquote>
<p><mark>整个算法的复杂度 O (n)，虽然第一步和第 2 步的第三点花费时间长，但是第一步和第 2 步的第三点都会扩展 R，依次变化的过程中，<strong>R 最多也就是变化到 n，所以时间复杂度为 O (n)</strong></mark></p>
<p>伪代码:</p>
<blockquote>
<p>下方代码是为了:</p>
<ul>
<li>让传进来的字符串或者字符数组变成那种包含特殊字符的字符数组 str</li>
<li>然后定义新的 int 数组用来装 str 的每一个字符的回文半径</li>
<li>定义 C,R 变量 (之前说过)</li>
<li>然后就是我们上面的说的，看在不在范围内，不在就暴力扩，在就看左边界有没有超过，有没有压着 L 等等等。让那个存 str 的每一个字符的回文半径的数组填满</li>
<li>期间注意更新 R 值和 C 值</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318215848344.png" alt="image-20220318215848344"></p>
<h4 id="实际代码"><a class="markdownIt-Anchor" href="#实际代码">#</a> 实际代码</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318220655429.png" alt="image-20220318220655429"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318222201556.png" alt="image-20220318222201556"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318222320250.png" alt="image-20220318222320250"></p>
<blockquote>
<p>注意那个一开始获取对于 i 最小需要扩的位置的代码可以看视频 https://www.bilibili.com/video/BV13g41157hK?p=13, 第 1:26:30 部分，说的很清晰，基本上就是考虑了我们上面所说的所有情况然后取了最小的</p>
</blockquote>
<blockquote>
<p>这里的代码主要是为了短，想法跟我们上面所说的其实有些区别，不过主要想法是一样的，只不过没有像我们说的按照不同情况各种 if else 等等等</p>
</blockquote>
<blockquote>
<p><strong>这里我们的那个 str 处理串的回文半径长度能帮我门解决很多问题，而找出一个字符或者字符数组的最长的回文子串 (的长度) 只是其中的一个问题</strong></p>
</blockquote>
<hr>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口">#</a> 滑动窗口</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318222628300.png" alt="image-20220318222628300"></p>
<blockquote>
<p>有两个原则</p>
<ul>
<li>L 和 R 只能往右走</li>
<li>L 不能比 R 还右</li>
</ul>
<p>R++ 代表把一个元素加进窗口</p>
<p>L++ 代表把一个元素移出窗口</p>
</blockquote>
<p>而上面那个题需要我们每次窗口更新都获取最大值，我们可以遍历这也可以，但是效率低，我们可以更新一下结构让用户快速获取最大值，效率会很快</p>
<ul>
<li>
<p>首先有一个双向的队列 (也就是两端都可以取值), 这个队列用来存下标的 (<strong>为什么不存元素？因为存下标可以通过数组快速地获取到对应的值，存下标还可以给我们更多的信息</strong>)</p>
</li>
<li>
<p>我们这个双向的队列<strong>从头到尾</strong>要保证是每一次窗口的值<strong>由大变小</strong>的<strong>排他们的下标</strong></p>
</li>
<li>
<p>当我们 R++, 尝试把这个新加的元素从队列尾部开始加</p>
<ul>
<li>
<p>如果这个新加的元素值比我们的队列尾部那个元素要小，直接让这个新加的元素的下标加入到尾部</p>
</li>
<li>
<p>如果这个新加的元素值比我们的队列尾部那个元素<strong>要大或者等于</strong>，把那个尾部的元素弹出，然后比较下一个，一直比到为空或者遇到比新加的元素值大的元素，我们才让这个新加的元素的下标加入到尾部</p>
<blockquote>
<p>这些被弹出的元素再也不可能成为此时以及以后的窗口的最大值了，因为我们这个新加的元素下标目前是最右的 (记得 L 和 R 只会往右走) 所以最晚过期，且新加的元素值又比那些值要大，那么肯定当前或者之后的窗口要是有这个元素肯定会比过我们当前弹出的元素 (等于或者小于这个新加的元素的值), 所以我们这些值其实不需要了，直接弹出就好了</p>
</blockquote>
</li>
</ul>
<p>此时我们的队列的头保留的就是我们每一次窗口的最大值</p>
</li>
<li>
<p>当我们 L++, 说明想要把一个元素移出我们当前这个窗口，我们检查这个移出元素的下标</p>
<ul>
<li>如果这个下标跟我们当前双向队列的头位置存的下标一样，直接让头弹出</li>
<li>如果这个下标跟我们当前双向队列的头位置存的下标不一样，<strong> 不需要管</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>这个双向队列存的信息就是</p>
<p><strong><mark>&quot;如果目前的窗口不再扩 (R 不 ++), 且我们选择让 L++ 也就是移出一个个元素，谁会依次成为最大值的这个优先级顺序的信息&quot;</mark></strong></p>
</blockquote>
<blockquote>
<p><strong>这个双向队列的总代价 (时间复杂度) 是 O (N)</strong>, 因为你这个滑动窗口往右走的时候，走过 N 个元素，我们双向队列最多让 N 个元素弹出，最多让 N 个元素加入，所以代价就是 O (N) 级别，这个是对于 N 个元素.</p>
<p><strong>如果是单个元素，那么每一个元素的<mark>平均</mark>代价就是 O (N)/N = <mark>O(1)</mark></strong></p>
</blockquote>
<p>注意上面说的是并不代表每一个元素就是 O (1), 而是平均下来每一个是 O (1), 看下方例子就明白了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318231241159.png" alt="image-20220318231241159"></p>
<h4 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题">#</a> 解决问题</h4>
<ul>
<li>只要每次让 L<ins> 和 R</ins> 让窗口保持大小为 w 就解决了</li>
<li>其他的和我们所说的都差不多</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318231712295.png" alt="image-20220318231712295"></p>
<blockquote>
<p>上面是最大值，最小值同理，都是反过来就行了</p>
</blockquote>
<hr>
<h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈">#</a> 单调栈</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220318232054191.png" alt="image-20220318232054191"></p>
<p>例子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319110020972.png" alt="image-20220319110020972"></p>
<ul>
<li>
<p>有一个栈，因为我们关心的是<strong>更大</strong>，所以<strong>栈底到栈顶是从大到小</strong>的顺序，这个栈是用来存下标的 (<strong>为什么不存元素？因为存下标可以通过数组快速地获取到对应的值，存下标还可以给我们更多的信息</strong>)</p>
</li>
<li>
<p>遍历，如果这个元素</p>
<ul>
<li>
<p>比我们栈顶的小，直接把下标放进去</p>
</li>
<li>
<p>比我们栈顶的大，把那个栈顶的元素弹出。注意！只要一个元素要弹出，他的信息就开始生成</p>
<ul>
<li><strong>他的左边最近比他大的就是他弹出的时候的栈底 (原本压被他压在下面的下标的元素), 如果本身就是栈底了，弹出之后没有元素了，那么说明左边最近比他大的元素为 null</strong></li>
<li><strong>他的右边最近比他大的就是此时我们要新加的元素，如果没有新加的元素 (到头了，但是栈里面还有元素) 那么就说明右边最近比他大的元素为 null</strong></li>
</ul>
<p>然后比较下一个，一直比到为空或者遇到比新加的元素值大的元素，我们才让这个新加的元素的下标加入到栈顶，或者遇到一样的直接让他们存在一个集合里面去</p>
</li>
<li>
<p><strong>跟我们栈顶存的下标对应的元素一样，把下标压在一起，可以用集合，然后之后这个位置的存下标的集合弹出了，就会把里面所有的下标对应的元素都生成信息 (对于每一个下标对应的元素信息按照上面说的都一样的)</strong></p>
<p>注意！！！如果一个集合多个下标元素，我们想要用它信息的时候用的是当前集合最后一个元素存的下标</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319113349347.png" alt="image-20220319113349347"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个跟上面的滑动窗口的双向队列的一样，时间复杂度是 O (N)<strong>, 因为你这往右走的时候，走过 N 个元素，我们单调栈最多让 N 个元素弹出，最多让 N 个元素加入，所以代价就是 O (N) 级别，这个是对于 N 个元素.</strong></p>
<p><strong>如果是单个元素，那么每一个元素的<mark>平均</mark>代价就是 O (N)/N = <mark>O(1)</mark></strong></p>
</blockquote>
<p>题目:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319113703844.png" alt="image-20220319113703844"></p>
<p>解法:</p>
<ul>
<li>其实就是单调栈</li>
<li>看每个元素左边最近比自己小的，右边最近比自己小的，然后只扩到不包含那里 (这就保证了我们每一个元素只扩到比自己大的元素，最后形成的子数组就是最大指标累加是最大的)</li>
</ul>
<hr>
<h3 id="大数据"><a class="markdownIt-Anchor" href="#大数据">#</a> 大数据</h3>
<h4 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器">#</a> 布隆过滤器</h4>
<p>比如说你想存 100 亿 url 都是黑名单 (<strong>其实这个跟爬虫去重问题一样</strong>), 每个 url64bytes</p>
<p><strong>我们只需要加 url 以及查一个 url 存不存在这两个功能，且这个需要在内存，因为要是查硬盘存的那就时间太长了</strong></p>
<p>如果要存到一个哈希表那就需要 6400 亿 bytes, 内存根本塞不下</p>
<p>所以我们可以使用布隆过滤器–&gt;</p>
<blockquote>
<p>布隆过滤器也是放在内存里面，使用空间很少</p>
<p><strong>还有就是允许一定程度的失误率 (就是一个 url 在黑名单没查出来 (<mark>布隆过滤器不会有这种失误</mark>), 或者一个 url 不在黑名单结果查出是在黑名单里面 (<mark>布隆过滤器会有这种失误</mark>))</strong></p>
</blockquote>
<p>首先，bit 数组，就是每个元素就是一个比特，如何声明？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001204388.png" alt="image-20220315001204388"></p>
<p>这里就是声明了一个长度为 320 比特的数组</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001245440.png" alt="image-20220315001245440"></p>
<p>现在想拿出下标为 178 的比特</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001333209.png" alt="image-20220315001333209"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001500321.png" alt="image-20220315001500321"></p>
<p>这个 bit 是 1, 那么 s 就是 1, 如果这个 bit 是 0, 那么 s 就是 0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001620963.png" alt="image-20220315001620963"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315001651714.png" alt="image-20220315001651714"></p>
<p>布隆过滤器就是一个超大的 bit 数组，假设 0-m-1, 那么总共就 m 个 bit, 也就是 m/8 个字节，很省空间</p>
<p>对于我们这个列子，对于每一个 url 我们对他<strong>调用多个哈希函数</strong>获得<strong>多个位置</strong>，接着就把 bit 数组对应的下标的值改黑 (0 变成 1or vice versa).</p>
<p>这样子之后想查一个数据，就会按照哈希函数找到所有对应的下标然后去看到底是不是全是被改成黑的，如果全是那么说明就是个黑名单的 url, 如果有起码一个没标成黑的，说明这个 url 不属于黑名单.</p>
<blockquote>
<p>如果有一个 url 是黑名单 (之前已经加过了), 那就说明再查就一定全是黑的，所以这个错误不会发生</p>
<p>所以可能误判的问题就明显了，一个 url 经过多个哈希函数得到的下标，恰恰好就被之前其他多个 url 把那改为黑的，那么这个可能一看正好获得全是黑的，那么就会认为这个 url 也属于黑名单，其实并不</p>
</blockquote>
<blockquote>
<p><strong>m–&gt; 到底多大由你决定，越大失误率更小</strong></p>
<p><strong>k 个哈希函数–&gt; 到底几个由你决定，这个要靠 m 的大小，并不是越多越好，越多一个 url 也会涂更多，所以还是要按照 m 的大小定一个合适的 k 最好</strong></p>
</blockquote>
<p><strong>什么时候使用过滤器</strong></p>
<ul>
<li>在内存</li>
<li>是不是我们上面说的类似的结构–&gt; 只是查询添加，没有删除的这种</li>
<li>允许一定失误率 (本来不在那上面的，结果返回结果还是在上面)</li>
</ul>
<blockquote>
<p>注意！<span class="spoiler" title="..."> 布隆过滤器只和 m 和 k 参数有关，单样本的大小随便，任何大的都行</span>！<span class="spoiler" title="..."> 我们都会对他使用哈希函数等等等</span>！！！<strong> 只要那个哈希函数可以接收那个数据的长度就可以</strong>！！！</p>
<p>== 单样本多大跟我们的布隆过滤器设计多大，设置多少个哈希函数，一点都没关系，只需要保证那个哈希函数可以接收那个长度的数据就可以了！！！==</p>
</blockquote>
<p><strong>三个公式:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315003954305.png" alt="image-20220315003954305"></p>
<p>然后这个 m 是 bits 的个数，我们 ÷8 可以得出多少个 bytes</p>
<p>对于 100 个 url 的例子，我们这里就是 26g (compared to 640g needed by hashset structrue), 内存不会被撑爆</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315004148566.png" alt="image-20220315004148566"></p>
<blockquote>
<p>如果有任何小数，<strong> 都向上取整</strong> (比如说 m, 以及算出来的 k 等等等)</p>
</blockquote>
<p>上面算出的 m 是理论的 (预期的), 如果面试官跟我们说可以更大，那么实际给的大小就是 m 真</p>
<p>然后 k 值按照那个 m 真算出的就叫做 k 真</p>
<p>我们可以用 m 真和 k 真算出实际的失误率 (肯定比我们的预期的失误率还低)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315004647039.png" alt="image-20220315004647039"></p>
<blockquote>
<p><strong><mark>有了这个三个公式，我们只需要 n 的大小，以及允许多少失误率，就可以算出 m 和 k</mark></strong>, 有了 m 我们就能知道多大，如果给我们的大小超过了我们算出的 m, 说明我们实际失误率还有机会更小 (也就是第三个公式的作用)</p>
</blockquote>
<hr>
<h4 id="一致性哈希"><a class="markdownIt-Anchor" href="#一致性哈希">#</a> 一致性哈希</h4>
<p>如果使用分布式数据库，我们需要按照一个 key (用户给的，等等等) 算出他的哈希值，取模，然后去对应数据去找那个 key 对应的数据等等等</p>
<p>所以如果我们另外一个服务器被访问然后要求同一个 key 的数据，那个也会同样哈希函数然后取模到对应的数据库去</p>
<blockquote>
<p>这个底层已经帮我们做好了，很均匀的分配到每一个数据库上</p>
<p>并且还能做到负载均衡，就是经常被查的 key 被均匀分到每一个数据库，然后 less 被查的也是均匀的分布，然后不怎么被查的 key 也是均匀的分布在所有数据库之中</p>
<p>__== 注意 key 一定需要是种类多的，这样就能保证高频，中频，低频 key 都是有一定数量的，那么根据哈希函数的性质就能做到均分，而不是使用那种比如说性别做 key, 只能是男女，所以就算多个数据库，我们这个 key 如果高频，只能被分到两个数据库里面去，一个存男这个 key 对应的数据，一个存女这个 key 对应的数据，不好！！！这会导致其他服务器负载低了，不好的 key 的设计。哈希 key 一定选择那种会有多个高频，多个中频，多个低频的那种数据最好 ==__这些就是底层一般帮你做好的，不需要你管</p>
<p>有个问题:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315012145357.png" alt="image-20220315012145357"></p>
<p>就比如说突然数据特别大，我们数据库不够用了，需要扩展更多的数据库，那么代表我们之前那个 (比如说图里的) 1,2,3 数据库里面的所有数据就需要重新哈希函数取模，然后获取到现在我们添加了其他数据库所对应的新位置</p>
<p><strong>这个经典结构问题可见就是数据迁移问题，代价很大，一加服务器，所有数据都需要按照 key 重新哈希函数然后取模到现在新的位置才可以做到多个服务器之间平均分散</strong></p>
<p>解决方法:</p>
<p><mark><strong>一致性哈希</strong></mark></p>
<p>想象哈希函数然后取模是一个圈，圈代表所有可能取到的值</p>
<ul>
<li>我们对每一个数据库按照某个东西算出个哈希值然后取模</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315011505396.png" alt="image-20220315011505396"></p>
<ul>
<li>比如说有一个数据，我们按照 key 算出哈希值，然后取模</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315011611384.png" alt="image-20220315011611384"></p>
<p>代码层次就是我们可以存每个数据库的哈希值取模的数，然后排序什么的</p>
<p>之后有数据我们算出哈希值然后取模，然后这个值拿来给我们的那个存数据库的哈希值取模的数那个集合里面进行二分查找，一直找到一个数最左且大于我们的这个数据 key 哈希值然后取模的值，我们就知道把当前数据存到哪个数据库了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315012053608.png" alt="image-20220315012053608"></p>
<p>这么做的好处就是我们加数据库机器，数据迁移很低</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315012311369.png" alt="image-20220315012311369"></p>
<p>然后 m1,m2 服务器什么都不用干</p>
<p>同样道理，如果想要撤一个服务器，数据迁移代价也是很低:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315012431787.png" alt="image-20220315012431787"></p>
<p><strong>但是这种方式有两个问题:</strong></p>
<ul>
<li>机器数量少的话，不能保证那些机器能把环均匀的平分开来，哈希函数保证的只是点的数量多起来之后，任何一段含有点的个数几乎是一样的，哈希函数可不是说我们这个三个数 m1,m2,m3 打到环上能做到均匀均分</li>
<li>即便我们机器很少还做到了均匀把环给分开，只要我们添加一台机器，或者减少一台机器，马上就能做到<strong>负载不均衡</strong>，这是因为</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315012918904.png" alt="image-20220315012918904"></p>
<p>** 只要解决了这两个问题，一致性哈希就特别好用！！！**</p>
<p>解决方法:</p>
<p><mark><strong>虚拟节点技术</strong></mark></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315013144178.png" alt="image-20220315013144178"></p>
<ul>
<li>我们不是直接拿机器来算哈希然后取模了，而是每个机器给很多对应的虚拟节点，然后让虚拟节点去哈希值取模去抢环</li>
<li>这样数据迁移也很方便，比如说 a1000 代表的虚拟节点对应的哈希值取模后获取到对应的存储的数据至二级转给 b2 代表的虚拟节点对应的哈希值取模后对应的存储数据的地方 (虚拟节点给数据夺数据很简单很方便的操作)</li>
<li>此时这整个环，随便拿一块，这一块所有的 a 虚拟节点 (所属于 m1) 的哈希取模值，b 虚拟节点 (所属于 m2) 的哈希取模值，c 虚拟节点所属于 m3) 的哈希取模值都是差不多一样多的 (<strong>这个才是哈希函数保证的！</strong>)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220315013637670.png" alt="image-20220315013637670"></p>
<ul>
<li>同理我们想要加一个服务器，给他同样的数量的虚拟节点，让他们都哈希值取模，然后抢环，剩下的就是让别的数据库的虚拟节点里面对应的数据给到我们这个新添加的数据库的对应的虚拟节点对应的存储地方去就行了</li>
</ul>
<p>此时我们环上，m1,m2,m3,m4 的虚拟节点都是差不多的，以及任何环上任何一段他们的数量都是差不多的</p>
<ul>
<li>撤一台服务器，也是按照虚拟节点把数据给到对应的其他数据库的虚拟节点去，直到给广，都是很快的，给的也都很均匀</li>
</ul>
<p>一致性哈希我们还可以，比如说某一个<strong>服务器性能更高</strong>，给他分配更多的虚拟节点，也就代表更多数据都会存到那个数据库去了，以及更多搜索查询等等等都会去那个数据库 (小声 bb 这不就是 nginx 的负载均衡功能吗)</p>
</blockquote>
<blockquote>
<p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=3HijrTeBXt6TDlWypyLvjA%3D%3D.hESRdt2ktQkgBurhv8Xevr93HEzgDpy1dfxrH4ydZwDFay5GePmWAmfx6l7kFDboveuHq6u5TBmw3T3vDHz9jIF9TJQKURYiVHki1nABbTc%3D">哈希表</a>（Distributed Hash Table，DHT）中存在的动态伸缩等问题</p>
</blockquote>
<blockquote>
<p>可以看出哈希函数的均匀的分布性是用处很大的！！！</p>
</blockquote>
<hr>
<h4 id="大数据具体还是看视频"><a class="markdownIt-Anchor" href="#大数据具体还是看视频">#</a> 大数据 (具体还是看视频)</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319161252619.png" alt="image-20220319161252619"></p>
<blockquote>
<p>简答解法就是用 bit 数组 (之前讲过用基础类型实现 bit array), 我们就是形成一个 2<sup>32</sup> 长度的 bit 数组 (代表总共是 2<sup>32</sup>/8 个字节，约 500MB, 所以内存 1G 够用), 每一个下标代表那个数有没有，如果有就让那个下标位置的变成 1 什么的，然后之后看哪个下标为 0 就代表那个数没有</p>
</blockquote>
<p>但是进阶问题就需要:</p>
<p>首先看你内存能存多少空间，然后申请合理的 int 数组，接着把那 40 亿个整数挨个过一下，然后把那个范围到的数字都除你数组大小，然后对于每一个数让包含自己的那个范围的下标存的 count 加加，之后看哪个不达标继续让他自己分成几分几分的继续看，等等等</p>
<blockquote>
<p>建议看视频 https://www.bilibili.com/video/BV13g41157hK?p=14&amp;spm_id_from=pageDriver</p>
<p>1:45:00</p>
</blockquote>
<hr>
<h4 id="url大数据题目"><a class="markdownIt-Anchor" href="#url大数据题目">#</a> URL 大数据题目</h4>
<blockquote>
<p>一般按照下面的解法就没错，主要是多问，看看什么限制等等等</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319164341166.png" alt="image-20220319164341166"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319163740336.png" alt="image-20220319163740336"></p>
<ul>
<li>
<p>可以用哈希函数分流，把 100 个亿 URL 的大文件分流到很多个小文件或者是多台机器，通过哈希函数，每个 url 都获得一个哈希值，然后取模，因为哈希函数的性质，可以保证一种 URL 都会进一个文件。然后我们再对小文件里面统计有哪些重复的 URl (我们可以重复上面的操作，如果需要), 之后查出来再把信息汇总一下就行了</p>
</li>
<li>
<p>可以布隆过滤器，差不多道理，就是边添加的时候查询</p>
</li>
</ul>
<p>补充部分的解法:</p>
<ul>
<li>开始一样还是哈希函数分流到很多个小文件</li>
<li>我们对于每个小文件，数据量很少，我们可以用哈希表计算每个 url 以及他的词频 (count), 哪个词出现更多 count 就更大，然后把它形成一个大根堆，就是按照 count 次数来排序的大根堆</li>
<li>对每一个小文件都这么多，就好多个大根堆，如何合并他们实现所有文件之间出现最频繁的热门 100 词呢？</li>
<li>我们可以把每一个小文件维持的大根堆的堆顶拿出来，把他们都放进一个大根堆里面把这个大根堆叫做总堆</li>
<li>我们接着就可以从这个总堆里面拿数据，我们拿的这个数据来自于哪个小文件的大根堆就会让哪个小文件的大根堆里面的<strong>此时的堆顶</strong>出来加入到总堆里面去，这就相当于各个小文件里面最大的那个元素就行 pk, 然后一个数据走了会继续让那个小文件里面原本第二此时最大的 (出现次数的) 词汇加入到总堆里面进行 pk</li>
</ul>
<p>因为都是堆，所以代价就是 log (n) 水平的，代价不高</p>
<blockquote>
<p>就按照给的那七个看哪个合适，一般都是那之中的解法，还有哈希函数分流是万能的</p>
</blockquote>
<hr>
<h3 id="位运算"><a class="markdownIt-Anchor" href="#位运算">#</a> 位运算</h3>
<h4 id="1给定两个有符号32位整数a和b返回a和b中较大的"><a class="markdownIt-Anchor" href="#1给定两个有符号32位整数a和b返回a和b中较大的">#</a> 1. 给定两个有符号 32 位整数 a 和 b，返回 a 和 b 中较大的</h4>
<p>a * returnA+b*returnB ---------returnA 与 returnB 互斥，可用加法表达 if else<br>
 返回 a 的条件：<br>
（1）if (a 和 b 符号不相同)：a&gt;0 返回 a<br>
（2）if (a 和 b 符号相同)：a-b&gt;=0 返回 a</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//请保证参数n，不是1就是0的情况下</span>
<span class="token comment">//1-->0</span>
<span class="token comment">//0-->1</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">flip</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> n <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//按位异或</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//n是非负数，返回1</span>
<span class="token comment">//n是负数，返回0</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sign</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//不考虑越界的解法</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> scA <span class="token operator">=</span> <span class="token function">sign</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a-b为非负，scA为1；</span>
	<span class="token keyword">int</span> scB <span class="token operator">=</span> <span class="token function">flip</span><span class="token punctuation">(</span>scA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//scA为0，scB为1；</span>
	<span class="token comment">//scA为0，scb必为1；scA为1，scB必为0</span>
	<span class="token keyword">return</span> a <span class="token operator">*</span> scA <span class="token operator">+</span> b <span class="token operator">*</span> scB<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sa <span class="token operator">=</span> <span class="token function">sign</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sb <span class="token operator">=</span> <span class="token function">sign</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sc <span class="token operator">=</span> <span class="token function">sign</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> difSab <span class="token operator">=</span> sa <span class="token operator">^</span> sb<span class="token punctuation">;</span><span class="token comment">//a和b的符号不一样，为1，一样为0</span>
	<span class="token keyword">int</span> sameSab <span class="token operator">=</span> <span class="token function">flip</span><span class="token punctuation">(</span>difSab<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a和b的符号不一样，为0，一样为1</span>
	<span class="token keyword">int</span> returnA <span class="token operator">=</span> difSab <span class="token operator">*</span> sa <span class="token operator">+</span> sameSab <span class="token operator">*</span> sc<span class="token punctuation">;</span><span class="token comment">//返回a的条件：ab不一样且a是正的，ab一样且a-b>0</span>
	<span class="token keyword">int</span> returnB <span class="token operator">=</span> <span class="token function">flip</span><span class="token punctuation">(</span>returnA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> a <span class="token operator">*</span> returnA <span class="token operator">+</span> b <span class="token operator">*</span> returnB<span class="token punctuation">;</span> <span class="token comment">// 就是returnA跟returnB互斥,直接+的话,只会返回一个</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token number">2147483647</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147480000</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wrong answer because of overflow</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMax2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2给定32位正数判断是否是2的幂是否是4的幂"><a class="markdownIt-Anchor" href="#2给定32位正数判断是否是2的幂是否是4的幂">#</a> 2. 给定 32 位正数，判断是否是 2 的幂，是否是 4 的幂</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">is2Power</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//要满足n二进制只有一个1的情况，也就是n &amp; (n - 1)) == 0</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">is4Power</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3加减乘除"><a class="markdownIt-Anchor" href="#3加减乘除">#</a> 3. 加减乘除</h4>
<p>（1）加</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		sum <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
		b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
		a <span class="token operator">=</span> sum<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（2）减</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">negNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">~</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">negNum</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（3）乘</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">multi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			res <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		a <span class="token operator">&lt;&lt;</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		b <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 三个>>>代表无符号右移,最后会移没了</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(4) 除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319201126194.png" alt="image-20220319201126194"></p>
<hr>
<h3 id="暴力递归到动态规划"><a class="markdownIt-Anchor" href="#暴力递归到动态规划">#</a> 暴力递归到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&amp;spm=1001.2101.3001.7020">动态规划</a></h3>
<p>题目 —》找到暴力递归写法（尝试）</p>
<p>—》把可变<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%82%E6%95%B0&amp;spm=1001.2101.3001.7020">参数</a>，不讲究组织的形式，做缓存，那就是记忆化搜索的方法（拥有重复解的前提下）</p>
<p>—》精细化组织 ----》那就是动态规划</p>
<p><strong>如果暴力过程中没有枚举行为（即通过循环来求得值）</strong></p>
<p><strong>则<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2&amp;spm=1001.2101.3001.7020">记忆化搜索</a>和动态规划的时间复杂度一致，没有必要从记忆化搜索再优化为动态规划</strong></p>
<h4 id="什么暴力递归可以继续优化"><a class="markdownIt-Anchor" href="#什么暴力递归可以继续优化">#</a> 什么暴力递归可以继续优化？</h4>
<p>有重复调用同一个子问题的解，这种递归可以优化<br>
如果每一个子问题都是不同的解，无法优化也不用优化</p>
<h4 id="暴力递归和动态规划的关系"><a class="markdownIt-Anchor" href="#暴力递归和动态规划的关系">#</a> 暴力递归和动态规划的关系</h4>
<p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划<br>
任何动态规划问题，都一定对应着某 - 个有解的重复调用的暴力递归<br>
但不是所有的暴力递归，都一定对应着动态规划</p>
<h4 id="面试题和动态规划的关系"><a class="markdownIt-Anchor" href="#面试题和动态规划的关系">#</a> 面试题和动态规划的关系</h4>
<p>解决一个问题，可能有很多尝试方法<br>
可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式<br>
一个问题可能有若干种动态规划的解法</p>
<h4 id="如何找到某个问题的动态规划方式"><a class="markdownIt-Anchor" href="#如何找到某个问题的动态规划方式">#</a> 如何找到某个问题的动态规划方式？</h4>
<p>1) 设计暴力递归：重要原则 + 4 种常见尝试<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020">模型</a>！重点！<br>
2) 分析有没有重复解：套路解决<br>
 3) 用记忆化搜索 -&gt; 用严格表结构实现动态规划：套路解决<br>
 4) 看看能否继续优化：套路解决</p>
<h4 id="面试中设计暴力递归过程的原则"><a class="markdownIt-Anchor" href="#面试中设计暴力递归过程的原则">#</a> 面试中设计暴力递归过程的原则</h4>
<p>1) 每一个可变参数的类型，一定不要比 int 类型更加复杂<br>
 2) 原则 1) 可以违反，让类型突破到一维线性结构，那必须是唯一 - 可变参数<br>
 3) 如果发现原则 1) 被违反，但不违反原则 2)，只需要做到记忆化搜索即可<br>
 4) 可变参数的个数，能少则少</p>
<h4 id="常见的4种尝试模型"><a class="markdownIt-Anchor" href="#常见的4种尝试模型">#</a> 常见的 4 种尝试模型</h4>
<p>1) 从左往右的尝试模型.<br>
2) 范围上的尝试模型<br>
 3) 多样本位置全对应的尝试模型<br>
 4) 寻找业务限制的尝试模型</p>
<hr>
<h3 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划">#</a> 动态规划</h3>
<blockquote>
<p><strong><mark>暴力递归到动态规划</mark></strong></p>
<ul>
<li>按照尝试方法暴力递归⬇️</li>
<li>记忆化搜索 (dp)⬇️
<ul>
<li>几个可变参数，就几维数组 (或其他)</li>
<li>可变参数挨个可能的值，然后数组 (或其他) 大小确保下标对应可以取的所有值</li>
<li>一开始初始化，把数组里面的值都设为什么，如果比如说 - 1 已经我们递归函数里面用了那就换一个我们递归函数不可能返回的等等等</li>
<li>在一开始或者 near the start (可能有直接返回一个数，比如说一个可变参数是负数直接返回 - 1 什么的，因为我们数组下标不可以是负数所以只能是直接返回一个 - 1 代表不可行) 写一个 if statement, 就是 dp [那个可变的参数在这一层当前值对应合适的下标][那个可变的参数在这一层当前值对应合适的下标][…]!=-1 或其他，就直接 return dp [那个可变的参数在这一层当前值对应合适的下标][那个可变的参数在这一层当前值对应合适的下标][…] 就行了</li>
<li>把这个作为参数传进递归函数，在 return XXX 的地方换成 dp [那个可变的参数当前值对应合适的下标][那个可变的参数当前值对应合适的下标][…]=XXX</li>
</ul>
</li>
<li>严格表结构动态规划 (dp)⬇️
<ul>
<li>知道最终元素 (下标), 这个也就是我们当初暴力递归函数里面的可变参数的传进去的值 (从主函数里面的调用的时候)</li>
<li>根据我们递归函数里面的 base case 标出不用算直接可以获取答案的下标的那些元素</li>
<li>看依赖，就是我们递归函数的主体部分，每一个下标元素是跟哪一个下标的元素有依赖的等等等</li>
<li>(按照上面发现的) 定出严格表到底是从哪些格子推倒哪些格子，最终来到重点位置</li>
<li>这个顺序定了，具体怎么求，递归代码里面 copy 过来，然后像记忆化搜索 (dp) 方式里面说的那些部分可以改成按照下标从 dp 里面拿值或者设值就可以了</li>
<li>然后最后返回数组中的一个格子的值，选择的格子一般都是我们那个最终元素 (下标), 不过看情况，有些可能会有什么开始的位置等等等，这个都是看你数据存的是什么和到底什么情况等等等–&gt; 想要的究竟是什么</li>
</ul>
</li>
<li>严格表结构精版本动态规划 (dp)</li>
</ul>
<p><strong>逻辑和业务其实只有在暴力递归尝试阶段已经完成了，之后都是用固定结构一步一步优化</strong></p>
</blockquote>
<h4 id="机器人走路问题"><a class="markdownIt-Anchor" href="#机器人走路问题">#</a> 机器人走路问题</h4>
<p>给你标号为 1、2、3、……、N 的 N 个位置，机器人初始停在 S 位置上，走 K 步后停在 E 位置上的走法有多少种。注：机器人在 1 位置上时只能向右走，在 N 位置上时只能向左走，其它位置既可向右又可向左。</p>
<p><strong>暴力递归方式:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319213019821.png" alt="image-20220319213019821"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319212847514.png" alt="image-20220319212847514"></p>
<blockquote>
<p>暴力递归时间复杂度在最坏情况是 2<sup>k</sup>, 因为每一层可以左走或者右走，相当于一整个二叉树的可能，然后走 k 层相当于走二叉树的几层深度</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319214252169.png" alt="image-20220319214252169" style="zoom:67%;" />
</blockquote>
<p>有个问题:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319205920589.png" alt=""></p>
<blockquote>
<p>可以看出暴力递归我们遇到一样的还是会再去把那一个展开再次执行，要是我们可以使用某种办法保存住那一块的信息，岂不是就不需要重新算了，发现是一样的直接用就行</p>
</blockquote>
<blockquote>
<p>这里是<strong>无后效性</strong>。无后效性是指对于递归中的某个子过程，其上级的决策对该级的后续决策没有任何影响</p>
<p>比如说上面 <code>f(2,2)</code>  不管是 <code>f(3,1)</code>  还是 <code>f(3,3)</code>  调用的 (不管他的父级怎么样), 返回的结果都是一样的话，就是无后效性</p>
<p><strong><mark>无后效性最适合动态规划</mark></strong></p>
</blockquote>
<p><strong>记忆化搜索做法:</strong></p>
<blockquote>
<p><strong>首先我们知道我们有两个可变参数，那么就是一个二维表 (数组，可以用别的结构)</strong>, 而数组大小就是每一个可变参数的最大是多少</p>
<p>而我们例子中</p>
<ul>
<li>首先我们的当前位置是可变的，而这个的当前位置只能在 1 到 N, 所以我们干脆准备 N+1 个格子，就认为 0 是永远无法到达的</li>
<li>然后就是我们剩余步数 K, 值只会是 0 到 K, 也就是 K+1 大小的格子就够了</li>
</ul>
<p><strong>然后我们需要把这个二维数组所有数改为 - 1, 传过去</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319212157920.png" alt="image-20220319212157920"></p>
<p>此时这个传过去的 dp 就相当于是缓存结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319214014188.png" alt=""></p>
<blockquote>
<p>此时我们之前的问题就不会发生了，所有重复的状态都不会一层一层让他完全运行的，而是看缓存里面要是有他的值，就直接用那个值就行了，<strong><mark> 就是记得在所有你本来暴力递归你需要 return 的时候 (代表一层的答案) 的代码地方你都需要在 return 之间把那一层的答案赋值到当层可变参数作为 dp 数组下标的那个元素的值就行了 (就是看所有的 return 语句等然后再前面加上赋值操作等等等)</mark></strong></p>
</blockquote>
<blockquote>
<p>这种加了缓存的 dp 方法，这个 dp 数组是 K*N 的规模的，且在计算的时候，里面每一个元素最多只会计算一次，以后再遇到他都是返回的形式，对于每一个格子来说，如果邻近的格子是有东西的，他是 O (1) 的求解过程</p>
<p>所以时间复杂度就是 O (K*N)</p>
</blockquote>
<p><strong>严格表结构动态规划 (dp) 做法:</strong></p>
<p>例子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215048330.png" alt="image-20220319215048330" style="zoom:80%;" />
<p>我们看递归里面:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215112289.png" alt="image-20220319215112289"></p>
<p>这个就是说只有我们 k 步数剩余 0 的时候，如果等于了最后位置那么就是 1, 不然就是 0</p>
<blockquote>
<p>这不就直接代表我们可以直接让 row 为 0 的，也就是代表剩余步数为 0 的那一行直接赋上值</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215325020.png" alt="image-20220319215325020" style="zoom:80%;" />
<p>目的就是看哪些能直接出答案的位置都给写好了</p>
<p>接着看递归:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215559696.png" alt="image-20220319215559696" style="zoom: 67%;" />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215641481.png" alt="image-20220319215641481"></p>
<p>我们可以看出我们每次 1 位置的都会依赖 2 位置的，注意依赖的是比自己那一层少一个步数的 2 位置</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319215903597.png" alt="image-20220319215903597" style="zoom:80%;" />
<p>同理，接着看递归</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319220022464.png" alt="image-20220319220022464" style="zoom:80%;" />
<p><strong>同理，其他在中间的值，就是依赖左上角的值和右上角的值做累加</strong></p>
<blockquote>
<p>然后我们知道上面的各种关系之后，在这个问题里，我们可以直接按照那些边角的值，一个一个确认接下来的值，直接就可以把数组填满了 (其实填到我们那个标记着⭐️号的那个元素也就是我们开始位置，也就是我们最终答案，也就是从这个开始位置到那个结束位置走 K 步一共能有几个走法.</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319220732280.png" alt="image-20220319220732280" style="zoom:80%;" />
<blockquote>
<p>此时这个数组的每一个格子就相当于我们当初递归每一次每一层产生的结果.</p>
</blockquote>
<blockquote>
<p>注意这种严格表结构动态规划 (dp) 做法时间复杂度也是 O (K*N) 的</p>
</blockquote>
<hr>
<h4 id="换钱的最小货币数量"><a class="markdownIt-Anchor" href="#换钱的最小货币数量">#</a> 换钱的最小货币数量</h4>
<p><strong>题目</strong>：给定数组 arr，arr 中所有的值都为正数且可重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim 代表要找的钱数，求取出最少个货币然后等于这个 aim 值。</p>
<p><strong>举例</strong>：arr=[2,7,3,5,3]，aim=10, 那么答案就是 7 和 3 两张货币，数量最小是 2.</p>
<p><strong>暴力递归试法</strong>：从左到右</p>
<p><strong>暴力递归代码</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319231403245.png" alt="image-20220319231403245"></p>
<p>此处返回 0 和返回 - 1 的含义不一样，返回 0 代表找到一个可能性 (就是几个元素加在一起等于 aim, 虽然不一样是最小数量的答案).</p>
<p>而返回 - 1 代表找不到，要么我们选这条路值超了，要么选这条路已经到头了还无法凑够，等等等</p>
<blockquote>
<p>从左到右貌似都是</p>
<ul>
<li>带上当前元素然后处理下一个</li>
<li>不带上当前元素然后处理下一个</li>
</ul>
<p>然后就是各种 base case 等等等返回值的处理，然后最后选择貌似也都是 Math.min/Math.max 因为我们这里每一层都回调两次，然后这两次的返回结果中选一个想要的，一般是最大或者最小的</p>
<p>注意传的参数也一般都是那种还可以剩下多少什么什么的，等等等这里就是还可以剩下的多少的值等等等，然后你在回调的时候就把那个可变参数变化好才行</p>
</blockquote>
<p><strong>记忆化搜索动态规划写法</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319233714709.png" alt="image-20220319233714709"></p>
<p>然后其他就是一样的操作 (省略掉了), 就是注意我们 rest 可能是负数，而我们没法有负数下标的数组，所以我们可以留下一开始的如果 rest&lt;0, 那就直接返回 - 1, 这个留着就代表这个路行不通的意思就行</p>
<p><strong>严格表结构动态规划 (dp) 做法:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319234323904.png" alt="image-20220319234323904"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220319234256085.png" alt="image-20220319234256085"></p>
<blockquote>
<p>注意我们双维数组是按照什么顺序挨个填，是从上到下还是从下到上，是从左到右还是从右到左</p>
</blockquote>
<blockquote>
<p><strong><mark>可以直接把之前的递归函数里面的逻辑给拿过来，然后适当的用，也就是回调自己的地方用 dp 数组里面对应的下标的元素替代，然后原来那个递归函数里面的 return 语句替换成当前 dp 数组以及当前 dp 的下标来代表当前的值，也就是我们这次不是 return 返回代表这一层的返回值，而是给对应的位置的元素赋值成这一层的结果，就是注意我们数组下标可能越界的问题就行</mark></strong></p>
</blockquote>
<hr>
<h4 id="两个聪明人拿牌问题递归到动态规划"><a class="markdownIt-Anchor" href="#两个聪明人拿牌问题递归到动态规划">#</a> 两个聪明人拿牌问题递归到动态规划</h4>
<p>范围上的模型</p>
<blockquote>
<p>这里学到了</p>
<ul>
<li>
<p>有些递归可变参数是两个下标，然后因为这两个下标一个是左边的一个是右边的，且左边下标不会超过右边下标</p>
<p>这就相当于让我们 dp 二维表 (如果是的话) 的下半三角变成不可用，因为那里的下标根本不符合我们定义的可变参数</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220320162734710.png" alt="image-20220320162734710"></p>
<ul>
<li>有的题可能会需要两个 dp 数组等等等 (因为两个递归函数，然后他们互相递归调用)</li>
<li>如果递归函数 a 调用递归函数 b, 之后为了分析依赖关系建为表决定好哪个值依靠哪个之前的值以及按什么顺序把一个个格子得出来时，会需要让给 a 的 dp 依赖 b 的 dp 某个下标的值以及需要让给 b 的 dp 依赖 a 的 dp 某个下标的值，总之就是举个简单的例子，然后慢慢看，其实不难的，就挨个赋值一个先一个后什么的</li>
</ul>
</blockquote>
<h5 id="暴力递归-2"><a class="markdownIt-Anchor" href="#暴力递归-2">#</a> 暴力递归</h5>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">win1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> nu11<span class="token operator">|</span><span class="token class-name">I</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token class-name">Math</span> <span class="token punctuation">.</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>， <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr <span class="token number">.1</span>ength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//先手</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span> <span class="token function">max</span><span class="token punctuation">(</span>
    arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token operator">+</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">)</span>，arr<span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token class-name">R</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 后手</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span> <span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>  <span class="token comment">//arr[i]</span>
                     ，<span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//arr[j]</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="动规"><a class="markdownIt-Anchor" href="#动规">#</a> 动规</h5>
<p>f 作为一张表缓存</p>
<p>s 作为一张表缓存</p>
<p>L&gt;R 时，数据无效，即数组左下半区无效</p>
<p>/pic:mw://2c14ddb958445ac6716418d6047774b8</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">win2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//进行过滤</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> nu11<span class="token operator">|</span><span class="token class-name">I</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// if(L==R)&#123;</span>
            <span class="token comment">//	return arr[L];</span>
            <span class="token comment">//&#125;</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//if (i=j) &#123;</span>
    		<span class="token comment">//return 0;</span>
    		<span class="token comment">//&#125;</span>
            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>inti<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token class-name">R</span> <span class="token operator">=</span>i<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token operator">&amp;&amp;</span><span class="token class-name">R</span><span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">//f[row][col] = ?;</span>
            
             <span class="token comment">//return Math. max(arr[L]+ s(arr, L + 1, R)，arr[R] + s(arr, L, R - 1));</span>
            f<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span> <span class="token punctuation">.</span> <span class="token function">max</span><span class="token punctuation">(</span>
            	arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token class-name">L</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token class-name">R</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            	arr<span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">R</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment">//return Math .min(f(arr, i + 1, j)  //arr[i]  ，f(arr, i, j - 1));  //arr[j]</span>
             s<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>
            	f<span class="token punctuation">[</span><span class="token class-name">L</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// arr[i]</span>
            	f<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">R</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// arr[j]</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">L</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token class-name">R</span><span class="token operator">++</span><span class="token punctuation">;</span>
    	<span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token comment">//return Math . max(f(arr,0, arr.length - 1)， s(arr, 0, arr .1ength - 1));</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                   <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="马走棋盘问题"><a class="markdownIt-Anchor" href="#马走棋盘问题">#</a> 马走棋盘问题</h4>
<p>马从（0，0）出发，到达指定的（x，y）位置，必须走 k 步数，一共有多少种方法？</p>
<p>（马只能走日）</p>
<p>对于每个点，到达他的位置有 8 个位置（不越界的前提下）</p>
<blockquote>
<p>这里学到了 dp 可以是三维的甚至更多… 都差不多</p>
<p><strong>突然发现这种有几种方式，或者所有方式最少最多最小最大什么什么的这种本来就需要获取到所有方式才可以决定的都是需要暴力递归，然后改成动态规划</strong></p>
</blockquote>
<h5 id="暴力递归-3"><a class="markdownIt-Anchor" href="#暴力递归-3">#</a> 暴力递归</h5>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> х<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>х<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>x_ <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> х<span class="token operator">></span> <span class="token number">9</span> <span class="token operator">||</span>  у<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> у<span class="token operator">></span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">//有步数要走，x，y也是棋盘上的位置</span>
  <span class="token keyword">return</span>
   f	<span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>х<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>у<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> у<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="改动态规划"><a class="markdownIt-Anchor" href="#改动态规划">#</a> 改动态规划</h5>
<p>因为是后一步依赖前一步，所以先准备第一步的数据，逐步往前，直到最后一步。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ways2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// O~k</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// dp[..][..][0] = 0</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> level <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> level<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//x可能性</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span>y<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
      	 <span class="token comment">// 求 dp[i][j][level];  递归函数怎么求的。这里也怎么求</span>
      	 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">=</span>
   <span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>х<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>у<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x<span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">+</span><span class="token function">getValue</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> у<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span> ｜｜  x<span class="token operator">></span><span class="token number">9</span> ｜｜ y<span class="token operator">&lt;</span><span class="token number">0</span> ｜｜ y<span class="token operator">></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="bob活着"><a class="markdownIt-Anchor" href="#bob活着">#</a> bob 活着</h4>
<p>题目：<strong>给定范围横向 N，纵向 M，从（i，j）开始走 K 步（只能上下左右走，且概率相同）没有超过给定范围那么就是活着，如果在过程中超过了范围则死了，返回活着的概率。</strong></p>
<blockquote>
<p>在这个题里面，每一个点 bob 都可以走上下左右，然后可以走 k 步，那么总共的可能步数是 4<sup>k</sup>, 之后获得了总共的活着的次数，用那个次数 / 4<sup>k</sup> 等等等就可以获取答案了</p>
</blockquote>
<p><strong>递归实现</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">N</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token class-name">M</span> <span class="token operator">=</span> m<span class="token punctuation">;</span>
        <span class="token keyword">int</span> live <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 活着的情况</span>
        <span class="token keyword">int</span> all <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一共存在的情况</span>
        <span class="token keyword">int</span> gcb <span class="token operator">=</span> <span class="token function">gcb</span><span class="token punctuation">(</span>all<span class="token punctuation">,</span> live<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 求最大公约数</span>
        <span class="token keyword">return</span> live <span class="token operator">/</span> gcb <span class="token operator">+</span> <span class="token string">" / "</span> <span class="token operator">+</span> all <span class="token operator">/</span> gcb<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">gcb</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">gcb</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m <span class="token operator">%</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 计算活着的情况数</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">K</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token class-name">N</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">></span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">K</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">K</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token function">process</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">K</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token function">process</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">K</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token function">process</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">K</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>严格表结构</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">long</span> m<span class="token punctuation">,</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> m <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m <span class="token operator">%</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">bob2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">K</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">M</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">K</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//初始化数据</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> <span class="token class-name">M</span><span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> rest <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> rest <span class="token operator">&lt;=</span> <span class="token class-name">K</span><span class="token punctuation">;</span> rest<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> <span class="token class-name">M</span><span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                	<span class="token comment">//递归依赖</span>
                    dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rest <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rest <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">long</span> all <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">K</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> live <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> gcd <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>all<span class="token punctuation">,</span> live<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>live <span class="token operator">/</span> gcd<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>all <span class="token operator">/</span> gcd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="拿钞票问题递归到动态规划"><a class="markdownIt-Anchor" href="#拿钞票问题递归到动态规划">#</a> 拿钞票问题递归到动态规划</h4>
<p>一个数组，里面的元素代表钞票面额，每种钞票都可以无穷次的拿，数组中无重复值、均为正数</p>
<p>给一个目标值，求用数组中有多少种办法将目标值凑出来？</p>
<blockquote>
<ul>
<li>
<p>有重复的，我们使用从左到右模型，可变参数用的是当前要处理的元素的 index 和 rest (一般都差不多)</p>
</li>
<li>
<p>注意每个元素可重复，所以我们直接把递归放到 for 循环里面，让他循环合理的次数就行，然后在每次循环都是普通的该怎么调用怎么调用，注意！！！</p>
<p><strong>for 循环开始和结束值</strong>只要设置好，那么只要在里面简单的递归调用下一个位置的元素就就行了，比如说下面这个例子里面</p>
<ul>
<li>一开始是 0, 所以相当于是调用给下一个元素而且不包括当前元素 (这个直接多给你弄好了，就不需要你弄两个递归什么的了，意思都一样，for 循环嘛！)</li>
<li>然后是 1 (这个列子里面) 代表当前下标的元素用了一次，然后调用下一个下标的元素</li>
<li>然后是 2 (这个列子里面) 代表当前下标的元素用了两次，然后调用下一个下标的元素</li>
<li>…</li>
<li>然后是 N (这个列子里面，当然这个 N 的数量应该按照另外一个可变参数等等等获取到一个合理的数量，这里就是 <code>zhang * arr[index] &lt;= rest</code>  很合理，zhang 数 (for 循环最终值) 就应该是这样决定的) 代表当前下标的元素用了 N 次，然后调用下一个下标的元素</li>
</ul>
</li>
<li>
<p>注意！</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> rest <span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1</span> <span class="token operator">:</span><span class="token number">0</span> <span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这一块，我们还需要在里面测一下 rest 是不是等于 0 了，这是为了考虑数组最后一个元素，因为在数组最后一个元素的 index 的那一次递归的时候，他接着调用，就会调用 index+1, 此时他调用的递归的 index 就会是 arr.length, 我们需要在这里也要考虑 rest 是不是剩余 0 了，也就是考虑了数组最后一个值</p>
</li>
</ul>
<p>==_<em>从左到右或者类似的都需要考虑这个_最后一个元素</em>，以及各种可能会出界等等等的问题！！！__==</p>
<ul>
<li>这里还介绍了如果递归函数里面有枚举行为，该怎么用 dp 优化，我们可以把那个枚举的循环直接放到我们那个 dp 表结构的多重循环里面，不过这样稍微时间复杂度有点高</li>
</ul>
<p><strong>不过我们可以再次优化，仔细观查每一个格子的依赖，看看有没有依赖于其他的格子，这个例子里面就发现一个列子如果同一行有数据了，我们可以更方便获取到那个格子的 value, 我们可以再次优化让他省掉那个循环，让 dp 表结构方法边的更快</strong></p>
<p>== 注意只要之后在填表的时候，如果有枚举行为，就观察方式看看邻近的位置能不能替代枚举行为，只跟观察有关，** 跟原题没关！！！**==</p>
<ul>
<li>注意 dp 方式，一定一定一定要
<ul>
<li>保证可变参数越少越好 (dp 数组维度也可以减少)</li>
<li>保证可变参数最好只是一个整数什么的 (别整一个数组或者链表等等等，太多可能性了，dp 表很难表示)</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>暴力递归</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// arr中都是正数且无重复值，返回组成aim的方法数</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ways</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> aim<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span>nu1l<span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token operator">||</span>aim<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> aim<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
    <span class="token comment">//可以自由使用arr[index... ]所有的面值，每一种面值都可以使用任意张，</span>
    <span class="token comment">//组成rest，有多少种方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> rest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token keyword">return</span> rest <span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1</span> <span class="token operator">:</span><span class="token number">0</span> <span class="token punctuation">;</span> 
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> ways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> zhang <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rest <span class="token punctuation">;</span>zhang<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ways <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rest <span class="token operator">-</span> <span class="token punctuation">(</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ways<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有重复过程，所以有必要优化<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/11c9eb1dd30a40c384bdcb3af327476e.png" alt=""></p>
<p><strong>记忆 dp</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ways2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> aim<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> nu1l <span class="token operator">||</span> arr <span class="token number">.1</span>ength <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span> aim <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr <span class="token number">.1</span>ength<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//一开始所有的过程，都没有计算呢</span>
        <span class="token comment">// dp[..][..]</span>
        <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     	   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token number">.1</span>ength<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        		dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token function">process2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span>，aim，dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//如果index和rest的参数组合，是没算过的，dp[index][rest]:== -1</span>
<span class="token comment">//如果index和rest的参数组合，是算过的，dp[index][rest]> -1</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> rest<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>dp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token keyword">return</span> dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> arr<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token operator">=</span>rest <span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1</span> <span class="token operator">:</span><span class="token number">0</span> <span class="token punctuation">;</span>
        	<span class="token comment">//return rest ==0?1 :0 ;</span>
            <span class="token keyword">return</span> dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    
        <span class="token keyword">int</span> ways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> zhang <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rest <span class="token punctuation">;</span>zhang<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	ways <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rest <span class="token operator">-</span> <span class="token punctuation">(</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dp <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token comment">// 进行缓存</span>
    dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token operator">=</span>ways<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ways<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>动态规划</strong></p>
<p>由下到上进行计算，每一行从左往右</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ways2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> aim<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> nu1l <span class="token operator">||</span> arr <span class="token number">.1</span>ength <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">||</span> aim <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//一开始所有的过程，都没有计算呢</span>
        <span class="token comment">// dp[..][..]= -1</span>
    <span class="token comment">//if(index == arr.1ength) &#123;</span>
      <span class="token comment">//	return rest ==0?1 :0 ;</span>
    <span class="token comment">//&#125;</span>
    dp<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//dp[N][1...aim]=0;</span>
 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> rest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> rest <span class="token operator">&lt;=</span> aim<span class="token punctuation">;</span> rest<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token comment">//dp[index][rest] = ?;</span>
            
            <span class="token keyword">int</span> ways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> zhang <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rest <span class="token punctuation">;</span>zhang<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            	ways <span class="token operator">+=</span> dp<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rest <span class="token operator">-</span> <span class="token punctuation">(</span>zhang <span class="token operator">*</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>        
            dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> ways<span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这种时间复杂度是 O (N*aim<sup>2</sup>) 的</p>
</blockquote>
<p>因为有枚举行为，可以进行优化</p>
<p><strong>比如，f（3，100） 其实是依赖 f（3，97）的</strong></p>
<p>–&gt; f (3,100) 和 f (3,97) 都在一行上，都是面值代表是 3, 然后我们的 f (3,100) 其实就是下一行 (多少多少面值) 的 a 值 + b 值 + c 值等等等，但是我们已经算出 f (3,97) 的话我们知道 f (3,97) 的值是 b 值 + c 值等等等算出来的，所以我们只需要 a 值 + f (3,97) 的值就可以获取到 f (3,100) 的值，压根不需要重新让一个一个加到头了</p>
<blockquote>
<p>tip: 到了 dp 之后就不需要想原本的逻辑，就按照我们那种改法都改成 dp 表结构之后，然后再从依赖关系出发看看还能有什么优化等等等</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/6010d8285a1541e6b143ec6373d04564.png" alt=""></p>
<blockquote>
<p><strong>所以可以更进一步优化</strong>:</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ways2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> aim<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> nu1l <span class="token operator">||</span> arr <span class="token number">.1</span>ength <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span> aim <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//一开始所有的过程，都没有计算呢</span>
        <span class="token comment">// dp[..][..]= -1</span>
    <span class="token comment">//if(index == arr.1ength) &#123;</span>
      <span class="token comment">//	return rest ==0?1 :0 ;</span>
    <span class="token comment">//&#125;</span>
    dp<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//dp[N][1...aim]=0;</span>
 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> rest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> rest <span class="token operator">&lt;=</span> aim<span class="token punctuation">;</span> rest<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token comment">//dp[index][rest] = ?;</span>
            dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>rest<span class="token operator">-</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>rest<span class="token operator">-</span><span class="token punctuation">]</span>
            <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>aim<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="有序表"><a class="markdownIt-Anchor" href="#有序表">#</a> 有序表</h3>
<p>跟哈希表很像，只不过能保证 key 有序，所有操作，增删改查都是 **O (logN)** 级别的</p>
<p><strong>可以实现有序表的结构</strong>:</p>
<ul>
<li>红黑树</li>
<li>AVL 树</li>
<li>Self Balancing Tree</li>
</ul>
<p>上面都是 BST,balancing search tree, 他们实现的有序表时间复杂度都差不多，只是常数的区别</p>
<ul>
<li>Skip List (跳表)</li>
</ul>
<h4 id="balancing-search-tree"><a class="markdownIt-Anchor" href="#balancing-search-tree">#</a> Balancing Search Tree</h4>
<p>首先搜索二叉树是一般没有重复元素的，不过要是想有或者想让每个节点多保存某种信息什么的完全可以，就是在节点类里面加属性呗，<strong> 相当于就算是有重复值我们也可以做压缩，所以其实就可以默认我们 BST 是没有重复的</strong></p>
<h5 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树">#</a> <a href="/jump/super-jump/word?word=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a> / AVL 树</h5>
<h6 id="平衡性"><a class="markdownIt-Anchor" href="#平衡性">#</a> 平衡性</h6>
<p>经典的<a href="/jump/super-jump/word?word=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a>结构：在满足搜索<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>的前提条件下，对于一棵<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>中的任意子树，其左子树和其右子树的高度相差不超过 1。</p>
<h5 id="典型搜索二叉树avl树-红黑树-sbt树的原理"><a class="markdownIt-Anchor" href="#典型搜索二叉树avl树-红黑树-sbt树的原理">#</a> 典型搜索<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a> ——AVL 树、<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>、SBT 树的原理</h5>
<h6 id="avl树"><a class="markdownIt-Anchor" href="#avl树">#</a> AVL 树</h6>
<p>AVL 树是一种具有严苛平衡性的搜索<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>。什么叫做严苛平衡性呢？那就是<strong>所有子树的左子树和右子树的高度相差不超过 1</strong>。弊端是，每次发现因为插入、删除操作破坏了这种严苛的平衡性之后，都需要作出相应的调整以使其恢复平衡，调整较为频繁。</p>
<h6 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树">#</a> <a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></h6>
<p><a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>是每个节点都带有颜色属性的搜索<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>，颜色或红色或黑色。在搜索<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>强制一般要求以外，对于任何有效的<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>我们增加了如下的额外要求:</p>
<ul>
<li>性质 1. 节点是红色或黑色。</li>
<li>性质 2. 根节点是黑色。</li>
<li>性质 3 每个叶节点（NIL 节点，空节点）是黑色的。</li>
<li>性质 4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>性质 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>这些约束强制了<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的关键性质: <strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树<strong>大致上是平衡</strong>的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>要知道为什么这些特性确保了这个结果，注意到<strong>性质 4 导致了路径不能有两个毗连的红色节点</strong>就足够了。<strong>最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点</strong>。因为根据性质 5 所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<h6 id="sbt树"><a class="markdownIt-Anchor" href="#sbt树">#</a> SBT 树</h6>
<p>它是由中国广东中山纪念中学的陈启峰发明的。陈启峰于 2006 年底完成论文《Size Balanced Tree》，并在 2007 年的全国青少年信息学奥林匹克竞赛冬令营中发表。<strong>相比<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>、AVL 树等自平衡二叉查找树，SBT 更易于实现</strong>。<strong>据陈启峰在论文中称，SBT 是 “目前为止速度最快的高级二叉搜索树”</strong>。<strong>SBT 能在 O (log n) 的时间内完成所有二叉搜索树 (BST) 的相关操作</strong>，而与普通二叉搜索树相比，SBT 仅仅加入了简洁的核心操作 Maintain。由于 SBT 赖以保持平衡的是 size 域而不是其他 “无用” 的域，它可以很方便地实现动态顺序统计中的 select 和 rank 操作。</p>
<p><strong>SBT 树的性质</strong>是：对于数中任意结点，以该结点为根节点的子树的结点个数不能比以该结点的叔叔结点为根节点的子树的结点个数大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/80689086.jpg" alt=""></p>
<blockquote>
<p>由于<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的实现较为复杂，因此现在工程中大多使用 SBT 树作为<a href="/jump/super-jump/word?word=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a>的实现。</p>
</blockquote>
<h5 id="旋转rebalance"><a class="markdownIt-Anchor" href="#旋转rebalance">#</a> 旋转 ——Rebalance</h5>
<p>左旋：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/19584301.jpg" alt=""></p>
<p>右旋：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/83418620.jpg" alt=""></p>
<p>每种<a href="/jump/super-jump/word?word=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a>都有自己的一套在插入、删除等操作改变树结构而破坏既定平衡性时的应对措施（但都是左旋操作和右旋操作的组合），以 AVL 数为例（有四种平衡调整操作，其中的数字只是结点代号而非结点数值）：</p>
<ul>
<li>
<p>LL 调整：2 号结点的左孩子的左孩子导致整个树不平衡，2 号结点右旋一次</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-2/54714872.jpg" alt=""></p>
</li>
<li>
<p>RR 调整：3 号结点的右孩子的右孩子导致树不平衡，3 号结点左旋一次：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/15398152.jpg" alt=""></p>
</li>
<li>
<p>LR 调整：先左后右</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/65541652.jpg" alt=""></p>
</li>
<li>
<p>RL 调整：先右后左：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/65095113.jpg" alt=""></p>
</li>
</ul>
<blockquote>
<p><a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的调整也是类似的，只不过调整方案更多。面试中一般不会让你手写<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>（若有兴趣可参见文末附录），但我们一定能说清这些查找<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>的性质，以及调整平衡的基本操作，再就是这些结构的使用。</p>
</blockquote>
<h5 id="java中红黑树的使用"><a class="markdownIt-Anchor" href="#java中红黑树的使用">#</a> Java 中<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的使用</h5>
<p>Java 中<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>的实现有 TreeSet 和 TreeMap，前者结点存储的是单一数据，而后者存储的是 `` 的形式。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeMap</span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">"jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token string">"tony"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"alice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">"jerry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">//红黑树中最右边的结点</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">lastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//红黑树最左边的结点</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果有13这个key，那么返回这条记录，否则返回树中比13大的key中最小的那一个</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">ceilingEntry</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果有21这个key，那么返回这条记录，否则返回树中比21小的key中最大的那一个</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">floorEntry</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//比11大的key中，最小的那一个</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//比25小的key中，最大的那一个</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">.</span><span class="token function">lowerKey</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//遍历红黑树，是按key有序遍历的</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token keyword">record</span> <span class="token operator">:</span> treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age:"</span><span class="token operator">+</span><span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">",name:"</span><span class="token operator">+</span><span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TreeMap 的优势是 key 在其中是有序组织的，因此增加、删除、查找 key 的时间复杂度均为 log (2,N)。</p>
<h5 id="案例"><a class="markdownIt-Anchor" href="#案例">#</a> 案例</h5>
<h6 id="the-skyline-problem"><a class="markdownIt-Anchor" href="#the-skyline-problem">#</a> The Skyline Problem</h6>
<p>水平面上有 <em>N</em> 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 (start, end, height)，分别代表其在 x 轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 <em>N</em> 座大楼的外轮廓线。</p>
<p>外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。</p>
<p>给出三座大楼：</p>
<pre class="line-numbers language-none"><code class="language-none">[
  [1, 3, 3],
  [2, 4, 4],
  [5, 6, 1]
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/52795432.jpg" alt=""></p>
<p>外轮廓线为：</p>
<pre class="line-numbers language-none"><code class="language-none">[
  [1, 2, 3],
  [2, 4, 4],
  [5, 6, 1]
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>解析</strong>：</p>
<p>1. 将一座楼的表示 [start,end,height] 拆分成左右两个边界（边界包含：所处下标、边界高度、是楼的左边界还是右边界），比如 [1,3,3] 就可以拆分成 [1,3,true] 和 [3,3,false] 的形式（true 代表左边界、false 代表右边界）。</p>
<p>2. 将每座楼都拆分成两个边界，然后对边界按照边界所处的下标进行<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。比如 [[1,3,3],[2,4,4],[5,6,1] 拆分之后为 [[1,3,true],[3,3,false],[2,4,true],[,4,4,false],[5,1,true],[6,1,false]]，<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>后为 [[1,3,true],[2,4,true],[3,3,false],[4,4,false],[5,1,true],[6,1,false]]</p>
<p>3. 将边界<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>后，遍历每个边界的高度并依次加入到一棵 TreeMap<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91"> 红黑树</a>中（记为 countOfH），以该高度出现的次数作为键值（第一次添加的高度键值为 1），如果遍历过程中有重复的边界高度添加，要判断它是左边界还是右边界，前者直接将该高度在<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>中的键值加 1，后者则减 1。以步骤 2 中<a href="/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>后的边界数组为例，首先判断 countOfH 是否添加过边界 [1,3,true] 的高度 3，发现没有，于是 put (3,1)；接着对 [2,4,true]，put [4,1]；然后尝试添加 [3,3,false] 的 3，发现 countOfH 中添加过 3，而 [3,3,false] 是右边界，因此将 countOfH.get (3) 的次数减 1，当 countOfH 中的记录的键值为 0 时直接移除，于是移除高度为 3 的这一条记录；……</p>
<p>对于遍历过程经过的每一个边界，我们还需要一棵 TreeMap<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91"> 红黑树</a>（记为 maxHOfPos）来记录对我们后续求外轮廓线有用的信息，也就是每个边界所处下标的最大建筑高度：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/51682269.jpg" alt=""></p>
<p>这里有个细节要注意一下，那就是如果添加某个边界之后，countOfH 树为空了，那么该边界所处下标的建筑高度要记为 0，表示一片相邻建筑的结束，比如上图中下标为 4 和 6 的边界。这也是为了后续求外轮廓线提供判断的依据。</p>
<p>4. 遍历 maxHOfPos 中的记录，构造整个外轮廓线数组：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/6717017.jpg" alt=""></p>
<p>起初没有遍历边界时，记 start=0,height=0，接着遍历边界，如果边界高度 curHeight!=height 如上图中的 1-&gt;2：height=0,curHeight=3，那么记 start=1,height=3 表示第一条组外轮廓线的 start 和 height，接下来就是确定它的 end 了。确定了一条轮廓线的 start 和 height 之后会有两种情况：下一组轮廓线和这一组是挨着的（如上图 2-&gt;3）、下一组轮廓线和这一组是相隔的（如上图中 3-&gt;4）。因此在遍历到边界 [index:2,H:4] 时，发现 curHeight=4 != height=3，于是可以确定轮廓线 start:1,heigth:3 的 end:2。确定一条轮廓线后就要更新一下 start=2,heigth=4 表示下一组轮廓线的起始下标和高度，接着遍历到边界 [index:3,H:4]，发现 curHeight=4=height 于是跳过；接着遍历到边界 [index:4,H:0]，发现 curHeight=0，根据步骤 3 中的逻辑可知一片相邻的建筑到此结束了，因此轮廓线 start:2,height:4 的 end=4。</p>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>lintcode</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T131_The_SkylineProblem</span> <span class="token punctuation">&#123;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Border</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> isLeft<span class="token punctuation">;</span>
 
        <span class="token keyword">public</span> <span class="token class-name">Border</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isLeft<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> index<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>isLeft <span class="token operator">=</span> isLeft<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/profile/992988"</span> data<span class="token operator">-</span>card<span class="token operator">-</span>uid<span class="token operator">=</span><span class="token string">"992988"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">""</span> target<span class="token operator">=</span><span class="token string">"_blank"</span> from<span class="token operator">-</span>niu<span class="token operator">=</span><span class="token string">"default"</span> data<span class="token operator">-</span>card<span class="token operator">-</span>index<span class="token operator">=</span><span class="token string">"8"</span><span class="token operator">></span><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Border</span> border<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">!=</span> border<span class="token punctuation">.</span>index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">-</span> border<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isLeft <span class="token operator">!=</span> border<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isLeft <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">/**
     * @param buildings: A list of lists of integers
     * @return: Find the outline of those buildings
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token operator">></span> <span class="token function">buildingOutline</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buildings<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//1、split one building to two borders and sort by border's index</span>
        <span class="token class-name">Border</span><span class="token punctuation">[</span><span class="token punctuation">]</span> borders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Border</span><span class="token punctuation">[</span>buildings<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buildings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oneBuilding <span class="token operator">=</span> buildings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            borders<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Border</span><span class="token punctuation">(</span>oneBuilding<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> oneBuilding<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            borders<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Border</span><span class="token punctuation">(</span>oneBuilding<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> oneBuilding<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>borders<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//2、traversal borders and record the max height of each index</span>
 
        <span class="token comment">//key->height   value->the count of the height</span>
        <span class="token class-name">TreeMap</span> countOfH <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//key->index    value->the max height of the index</span>
        <span class="token class-name">TreeMap</span> maxHOfPos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> borders<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> height <span class="token operator">=</span> borders<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>countOfH<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                countOfH<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">int</span> count <span class="token operator">=</span> countOfH<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>borders<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    countOfH<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    countOfH<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>countOfH<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        countOfH<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>countOfH<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                maxHOfPos<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>borders<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">//lastKey() return the maxHeight in countOfH RedBlackTree->log(2,N)</span>
                maxHOfPos<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>borders<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">,</span> countOfH<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
 
        <span class="token comment">//3、draw the buildings outline according to the maxHOfPos</span>
        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> entry <span class="token operator">:</span> maxHOfPos<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> curPosition <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> curMaxHeight <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>height <span class="token operator">!=</span> curMaxHeight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">//if the height don't be reset to 0，the curPosition is the end</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>height <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">List</span> <span class="token keyword">record</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//end</span>
                    <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token comment">//reset the height and start</span>
                height <span class="token operator">=</span> curMaxHeight<span class="token punctuation">;</span>
                start <span class="token operator">=</span> curPosition<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buildings <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
                <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T131_The_SkylineProblem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buildingOutline</span><span class="token punctuation">(</span>buildings<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="跳表"><a class="markdownIt-Anchor" href="#跳表">#</a> 跳表</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/17338172.jpg" alt=""></p>
<p>跳表有着和<a href="/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>、SBT 树相同的功能，都能实现在 O (log (2,N)) 内实现对数据的增删改查操作。但跳表不是以<a href="/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>为原型的，其设计细节如下：</p>
<p>记该结构为 SkipList，该结构中可以包含有很多结点（SkipListNode），每个结点代表一个被添加到该结构的数据项。当实例化 SkipList 时，该对象就会自带一个 SkipListNode（不代表任何数据项的头结点）。</p>
<h6 id="添加数据"><a class="markdownIt-Anchor" href="#添加数据">#</a> 添加数据</h6>
<p>当你向其中添加数据之前，首先会抛硬币，将第一次出现正面朝上时硬币被抛出的次数作为该数据的层数（level，<strong>最小为 1</strong>），接着将数据和其层数封装成一个 SkipListNode 添加到 SkipList 中。结构初始化时，其头结点的层数为 0，但每次添加数据后都会更新头结点的层数为所添数据中层数最大的。比如实例化一个 SkipList 后向其中添加一条层数为 3 的数据 7：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/88337246.jpg" alt=""></p>
<p>这时如果再添加一条层数为 2 的数据 5 呢？首先游标 curNode 会从 head 的最高层出发往右走，走到数据项为 7 的结点，发现 7&gt;5，于是又退回来走向下一层：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/7563790.jpg" alt=""></p>
<p>接着再尝试往右走，还是发现 7&gt;5，于是还是准备走向下一层，但此时发现 curNode 所在层数 2 是数据项 5 的最高层，于是先建出数据项 5 的第二层，curNode 再走向下一层：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-4/70351383.jpg" alt=""></p>
<p>同样的，curNode 尝试往右走，但发现 7&gt;5，curNode 所在层为 1，但数据 5 的第一层还没建，于是建出，curNode 再往下走。当 curNode 走到 null 时，建出数据 5 根部的 null：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/36580124.jpg" alt=""></p>
<p>至此层数为 2 的数据项 5 的添加操作完毕。</p>
<p>那如果添加一个层数较高的数据项该如何处理呢？以添加层数为 4 的数据 10 为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/17645162.jpg" alt=""></p>
<p>添加操作对应的代码示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span>
 
<span class="token comment">/**
 * A stored structure.Its add,delete,update,find operation are log(2,N)
 *
 * @author zhenganwen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SkipList</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">SkipListNode</span> head<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxLevel<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> PROBABILITY <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipListNode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/**
         * the 0th level of each SkipListNode is null
         */</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maxLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SkipListNode</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> value<span class="token punctuation">;</span>
        <span class="token comment">/**
         * nextNodes represent the all levels of a SkipListNode the element on
         * one index represent the successor SkipListNode on the indexth level
         */</span>
        <span class="token class-name">ArrayList</span> nextNodes<span class="token punctuation">;</span>
 
        <span class="token keyword">public</span> <span class="token class-name">SkipListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nextNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">/**
     * put a new data into the structure->log(2,N)
     *
     * @param newValue
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">contains</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 
            <span class="token comment">// generate the level</span>
            <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PROBABILITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                level<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// update max level</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> maxLevel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">int</span> increment <span class="token operator">=</span> level <span class="token operator">-</span> maxLevel<span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>increment<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                maxLevel <span class="token operator">=</span> level<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// encapsulate value</span>
            <span class="token class-name">SkipListNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipListNode</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// build all the levels of new node</span>
            <span class="token class-name">SkipListNode</span> cur <span class="token operator">=</span> <span class="token function">findInsertionOfTopLevel</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>level <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    newNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    newNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
                level<span class="token operator">--</span><span class="token punctuation">;</span>
                cur <span class="token operator">=</span> <span class="token function">findNextInsertion</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            newNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">/**
     * find the insertion point of the newNode's top level from head's maxLevel
     * by going right or down
     *
     * @param newValue newNode's value
     * @param level    newNode's top level
     * &lt;a href="/profile/547241" data-card-uid="547241" class="" target="_blank" from-niu="default" data-card-index="9">@return */</span>
    <span class="token keyword">private</span> <span class="token class-name">SkipListNode</span> <span class="token function">findInsertionOfTopLevel</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> curLevel <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxLevel<span class="token punctuation">;</span>
        <span class="token class-name">SkipListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curLevel <span class="token operator">>=</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span>
                    <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">&lt;</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// go right</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// go down</span>
                curLevel<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">/**
     * find the next insertion from cur node by going right on the level
     *
     * @param cur
     * @param newValue
     * @param level
     * &lt;/a>&lt;a href="/profile/547241" data-card-uid="547241" class="" target="_blank" from-niu="default" data-card-index="10">@return */</span>
    <span class="token keyword">private</span> <span class="token class-name">SkipListNode</span> <span class="token function">findNextInsertion</span><span class="token punctuation">(</span><span class="token class-name">SkipListNode</span> cur<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">,</span>
                                           <span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span>
                <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">&lt;</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token comment">/**
     * check whether a value exists->log(2,N)
     *
     * @param value
     * &lt;/a>&lt;a href="/profile/547241" data-card-uid="547241" class="" target="_blank" from-niu="default" data-card-index="11">@return */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">SkipListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">int</span> curLevel <span class="token operator">=</span> maxLevel<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curLevel <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    curLevel<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                curLevel<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
 
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SkipList</span> skipList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//mark a break point here to check the memory structure of skipList</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>skipList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="查找数据"><a class="markdownIt-Anchor" href="#查找数据">#</a> 查找数据</h6>
<p>查找数据项的操作和添加数据项的步骤类似，也是游标 curNode 从 head 的最高层出发，每次先尝试向右走来到 nextNode，如果 nextNode 封装的数据大于查找的目标 target 或 nextNode 为空，那么 curNode 回退并向下走；如果 nextNode 封装的数据小于 target，那么 curNode 继续向右走，直到 curNode 走到的结点数据与 target 相同表示找到了，否则 curNode 走到了某一结点的根部 null，那么说明结构中不存在该数据。-&gt;contains ()</p>
<h6 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据">#</a> 删除数据</h6>
<p>了解添加数据的过程之后，删除数据其实就是将逻辑倒过来：解除该数据结点的前后引用关系。下图是我在写好上述 add () 方法后，向其中放入 1、2、3、4、5 后形成的结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/53408449.jpg" alt=""></p>
<p>如果此时删除数据 3：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/12149688.jpg" alt=""></p>
<p>首先应该从 head 的最高层出发，通过向右或向下找到数据 3 的最高层（如图 2-&gt;3-&gt;5-&gt;6-&gt;7），将该层移除整体结构并处理好该层上，其前后结点的关系。同样的逻辑，将数据 3 剩下的层移除。</p>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
     * delete skipListNode by the value
     *
     * @param value
     */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//if exists</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">contains</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//find the node and its level</span>
        <span class="token class-name">SkipListNode</span> deletedNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">int</span> deletedLevels <span class="token operator">=</span> maxLevel<span class="token punctuation">;</span>
        <span class="token comment">//because exists,so must can find</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>deletedLevels <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    deletedNode <span class="token operator">=</span> deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    deletedNode <span class="token operator">=</span> deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    deletedLevels<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                deletedLevels<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//release the node and adjust the reference</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>deletedLevels <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">SkipListNode</span> pre <span class="token operator">=</span> <span class="token function">findInsertionOfTopLevel</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> deletedLevels<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                pre<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">,</span> deletedNode<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                pre<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>deletedLevels<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            deletedLevels<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
 
        size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">SkipList</span> skipList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//mark a break point here to check the memory structure of skipList</span>
    skipList<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>skipList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="遍历数据"><a class="markdownIt-Anchor" href="#遍历数据">#</a> 遍历数据</h6>
<p>需要遍历跳表中的数据时，我们可以根据每个数据的层数至少为 1 的特点（每个结点的第一层引用的是比该结点数据大的结点中数据最小的结点）。</p>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SkipListIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">SkipListNode</span> cur<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">SkipListIterator</span><span class="token punctuation">(</span><span class="token class-name">SkipList</span> skipList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> skipList<span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> 
    <span class="token annotation punctuation">@Override</span> 
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> 
    <span class="token annotation punctuation">@Override</span> 
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>nextNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
	<span class="token annotation punctuation">@Override</span> 
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">SkipListIterator</span> iterator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipListIterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token string">"[ "</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        res <span class="token operator">+=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    res <span class="token operator">+=</span> <span class="token string">"]"</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">SkipList</span> skipList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>skipList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    skipList<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>skipList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="刷题以及技巧"><a class="markdownIt-Anchor" href="#刷题以及技巧">#</a> 刷题以及技巧</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目">#</a> 题目</h3>
<h4 id="绳子覆盖"><a class="markdownIt-Anchor" href="#绳子覆盖">#</a> 绳子覆盖</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220321124246052.png" alt="image-20220321124246052"></p>
<p><strong>解法</strong>:</p>
<blockquote>
<p>贪心 + 二分</p>
</blockquote>
<ul>
<li>
<p>把数组中每一个点都作为绳子的右端，有多少点就有多少种方式，之后答案肯定在这其中</p>
</li>
<li>
<p>贪心策略，把绳子右端放到点的位置上，而不要放没点的位置上</p>
</li>
<li>
<p>比如说数组 [2,4,8,9], 绳子长度为 5, 首先先让绳子右端是 2, 然后 2-5 等于 - 3, 说明左端可以是有大于等于 - 3 的数，就找最近大于等于 - 3 的，发现就是 2, 所以 2 作为右端只会覆盖一个点</p>
</li>
<li>
<p>接着右端是 4,4-5 等于 - 1, 在左边找最近的大于等于 - 1 的，发现是 2, 所以可以覆盖两个点</p>
</li>
<li>
<p>接着右端是 8,8-5 等于 3, 在左边找最近的大于等于 3 的，发现是 4, 所以可以覆盖两个点</p>
</li>
<li>
<p>再有序数组中找最 (左 / 右) 位置的大于等于的可以用二分查找</p>
</li>
<li>
<p>我们遍历 N 个点，然后每个点做了二分，所以时间复杂度是 O (nlogn)</p>
</li>
</ul>
<p><strong>更好的解法</strong>:</p>
<blockquote>
<p>滑动窗口</p>
</blockquote>
<ul>
<li>Left 跟 Right</li>
<li>Right 动，到时要保证窗口不要大于 L, 然后也要保证 R 位置的元素减去 Left 位置的元素不会超过 L</li>
<li>R 可以走就继续走，不可以走就让 Left 位置走，so on…</li>
</ul>
<p>时间复杂度就是 O (N)</p>
<hr>
<h4 id="小虎买苹果"><a class="markdownIt-Anchor" href="#小虎买苹果">#</a> 小虎买苹果</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322135744165.png" alt="image-20220322135744165"></p>
<p><strong>普通解法</strong>:</p>
<ul>
<li>首先让 N/8 获得最多能用几个乘 8 个的袋子，然后接着让 N-(N/8), 看看能不能让乘 6 个的袋子搞定</li>
<li>如果不行我们就减少乘 8 个的袋子，变成 N/8-1, 然后看剩下的让乘 6 个的袋子搞定</li>
<li>so on…</li>
<li>到哪个行了我们直接返回</li>
</ul>
<blockquote>
<p>注意其实我们不需要一直让乘 8 个的袋子 - 1-1… 然后试剩下的行不行</p>
</blockquote>
<ul>
<li>我们只需要测到一个 point, 我们减去用乘 8 个的袋子的苹果数量，还剩下的需要让乘 6 个的袋子苹果数量如果超过了 LCM (6,8) 就可以直接返回找不到了，因为如果剩余的数正好是 LCM (6,8) 说明这个数既可以被 8 的倍数搞定也可以被 6 的倍数搞定，但是这里是超过了 LCM (6,8), 说明现在 6 只能搞定 LCM (6,8), 但是超出的部分肯定搞定不了，因为我们之前的尝试中，先让 8 尝试所以 8 一定会尝试然后让剩下的数让 6 处理，之所以 6 处理不了才会到这一步.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322141435344.png" alt="image-20220322141435344"></p>
<p><strong>最优解</strong>:</p>
<blockquote>
<p>打表法</p>
</blockquote>
<ul>
<li>如果输入输出都是 int, 可以直接弄一个很傻的结局方法然后接着拿很多个输入参数来测，打印每一个的输出，接着看输出看有什么规律，直接按照规律写代码</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322142215520.png" alt="image-20220322142215520"></p>
<hr>
<h4 id="幂次方吃草"><a class="markdownIt-Anchor" href="#幂次方吃草">#</a> 幂次方吃草</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/869f4dbd097643a79a45a549f3da4480.png" alt=""></p>
<p><strong>一般思路</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">winner</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token string">"羊羊"</span> <span class="token operator">:</span> <span class="token string">"牛牛"</span><span class="token punctuation">;</span> <span class="token comment">//这些按照我们自己看的决定的答案</span>
		<span class="token keyword">int</span> eatTest <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//先从1份草开始试</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>eatTest <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">winner</span><span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">-</span> eatTest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"羊羊"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>
				<span class="token keyword">return</span> <span class="token string">"牛牛"</span><span class="token punctuation">;</span>
			eatTest <span class="token operator">*=</span> <span class="token number">4</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token string">"羊羊"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>老师代码</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322143453899.png" alt="image-20220322143453899"></p>
<p><strong>打表代码</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/dda1123aafad40769063c4e6502059bb.png" alt=""></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">win</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token operator">==</span><span class="token number">2</span><span class="token operator">?</span><span class="token string">"羊羊"</span><span class="token operator">:</span><span class="token string">"牛牛"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322144157524.png" alt="image-20220322144157524"></p>
<hr>
<h4 id="牛牛颜料"><a class="markdownIt-Anchor" href="#牛牛颜料">#</a> 牛牛颜料</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322144338362.png" alt="image-20220322144338362"></p>
<blockquote>
<p>老师做法反过来了，就是 R 左边不能有 G</p>
</blockquote>
<p><strong>暴力解法</strong>:</p>
<ul>
<li>
<p>我们分两个区域，一开始左边是空右边是数组 [0,…,s.length-1]</p>
<p>此时我们直接把右边区域所有的 G 变成 R</p>
</li>
<li>
<p>然后左边区域 ++ 变成数组 [0,1], 右边区域–变成数组 [1,…,s.length-1]</p>
<p>此时我们直接把左边区域所有的 G 变成 R</p>
<p>此时我们直接把右边区域所有的 R 变成 G</p>
</li>
<li>
<p>so on… 挨个试每次试都记录需要改变几个颜料，然后用一个变量存最小次数的就行了</p>
<p>…</p>
</li>
<li>
<p>然后左边区域 ++ 变成数组 [0,s.length-1], 右边区域–变成空</p>
</li>
</ul>
<p>​	此时我们直接把左边区域所有的 R 变成 G</p>
<blockquote>
<p>这样我们就暴力测出了所有让 R 左边不能有 G 的方法，期间我们用变量存下了那个改变颜料最小次数的数量，这个之后就是答案</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322150118342.png" alt="image-20220322150118342"></p>
<p>时间复杂度为 O (N<sup>2</sup>)</p>
<p><strong>优化解法</strong>:</p>
<blockquote>
<p>申请辅助结构，把每次查询的东西生成好，这样之后每次查询就不需要遍历，直接查询拿到值就可以获取到想要的值就可以了</p>
</blockquote>
<blockquote>
<p>此时老师改过来了，G 左边不能有 R</p>
</blockquote>
<ul>
<li>首先遍历数组，看 0 到那个下标一共有几个 R</li>
</ul>
<p>比如说:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322150718841.png" alt="image-20220322150718841" style="zoom:50%;" />
<ul>
<li>有了这个数组之后，想要查询任何一个位置，0 到那个位置的 R 数量都可以给你，这样你就不要一个一个遍历重复的去找有几个等等等</li>
<li>我们可以同样从后面遍历，代表当前位置到 s.length-1 位置上一共有多少 G</li>
</ul>
<p>比如说:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322151035324.png" alt="image-20220322151035324" style="zoom:50%;" />
<ul>
<li>有了这个数组之后，想要查询任何一个位置，那个位置到 s.length-1 的 G 数量都可以给你，这样你就不要一个一个遍历重复的去找有几个等等等</li>
</ul>
<p>因为我们在上面暴力做法，我们左边区域和区域都有元素时，我们同时需要左边到那个位置的 R 数量和右边到那个位置的 G 数量，我们可以从数组直接获取到那个数 (O (1)), 然后直接用，不需要遍历去找 (O (N)), 还可能是重复操作</p>
<hr>
<h4 id="矩阵最大正方形边长边框"><a class="markdownIt-Anchor" href="#矩阵最大正方形边长边框">#</a> 矩阵最大正方形边长边框</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322151828123.png" alt=""></p>
<p>对于任何一个 nxn 的矩阵</p>
<ul>
<li>一共有 O (n<sup>4</sup>) 规模的<strong>长方形</strong>子矩阵，常数项很小，因为可能会有重复的</li>
<li>一共有 O (n<sup>3</sup>) 规模的<strong>正方形</strong>子矩阵，常数项很小，因为可能会有重复的</li>
</ul>
<p><strong>暴力解法</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322153146184.png" alt="image-20220322153146184"></p>
<p><strong>优化解法</strong>:</p>
<blockquote>
<p>预处理–&gt; 想办法存一些信息关于检测是不是都是 1, 这样就不需要那四个 for 循环了，直接从存信息的里面取</p>
</blockquote>
<ul>
<li>生成一个矩阵跟原本矩阵一样大</li>
<li>这个新的矩阵 right,right 的每一个点存的是包括当前的点，以及他当前行右方的所有点，<strong> 一共有多少个<mark>连续</mark>的 1</strong></li>
</ul>
<p><strong><mark>如果我们从左边开始还是要遍历，为什么不直接从右边开始往左，有一个加一个，等等等这样就不需要遍历了</mark></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322153850919.png" alt="image-20220322153850919"></p>
<ul>
<li>有了这个矩阵，之后我们接着再生成一个矩阵名为 down,down 的每一个点存的是包括当前的点，以及他当前列下方的所有点，<strong> 一共有多少个<mark>连续</mark>的 1</strong></li>
</ul>
<p><strong><mark>得出的方式跟 right 一样，注意此时我们需要一列一列的做，或者一行一行也可以，但一定是从下往上填 (跟 right 从右往左填同理)</mark></strong></p>
<ul>
<li>有了这两个矩阵之后，比如说在我们选定了一个作为正方形左上角的点比如说 (4,5), 然后里面那个 for 关于边长的遍历到了 3</li>
</ul>
<p>我们此时就可以:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322155246078.png" alt="image-20220322155246078"></p>
<p>原本需要四个 for 循环挨个遍历才能知道的事 (常数蛮大的 O (N)), 此时就是取数据变成了 O (1)</p>
<blockquote>
<p>所以不用预处理方式 O (N<sup>4</sup>), 用来预处理 O (N<sup>3</sup>)</p>
</blockquote>
<hr>
<h4 id="利用等概率实现另外一个等概率"><a class="markdownIt-Anchor" href="#利用等概率实现另外一个等概率">#</a> 利用等概率实现另外一个等概率</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322155518581.png" alt="image-20220322155518581"></p>
<p><strong>第一个问题</strong>:</p>
<ul>
<li>
<p>先让 f 等概率返回 1 到 5</p>
<ul>
<li>如果是 1 或者 2, 设置为 0</li>
<li>如果是 3 或者 4, 设置为 1</li>
<li>如果是 5, 重新就算</li>
</ul>
<p>这个实现了等概率返回 0 和 1 的函数</p>
</li>
<li>
<p>现在就想二进制，<strong> 三个二进制为代表 0 到 7 的数</strong>，我们可以用这个函数随机生成三个 0 或者 1 的数，这样就能做到 0 到 7 的数等概率，我们可以</p>
<ul>
<li>如果结果是 0 到 6 就加 1,<strong> 这就做到了 1 到 7 等概率</strong></li>
<li>如果结果是 7, 就重新做那三个二进制位的数</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322162459551.png" alt="image-20220322162459551"></p>
<p>同样的问题，不同的数–&gt; 只给等概率产生 13 到 21 的，生成等概率产出 30 到 59 的</p>
<ul>
<li>先把 13 到 21 的函数做成产出等概率的 0 或者是 1
<ul>
<li>13-16 代表 0</li>
<li>17-20 代表 1</li>
<li><strong>21 就重做不要 (这个不是必须的，要是总共偶数个，那其实直接就是 0 或者 1 等概率产出了)</strong></li>
</ul>
</li>
<li>30 到 59 等概率其实就是<strong> 0 到 29 等概率 (只不过最后加上 30)(这种题都这么想！)</strong></li>
<li>看 0 到 29 需要几个二进制位 (5 个), 接着拿那个 0 到 1 的概率的产出 5 个二进制，如果这个产生的数字
<ul>
<li>是 0-29, 直接加上 30, 返回</li>
<li>大于 20, 重做，一直做到是 0-29 区间的</li>
</ul>
</li>
</ul>
<p><strong>第三个问题</strong>:</p>
<ul>
<li>直接让 p 函数运行两次
<ul>
<li>如果是 00, 重做</li>
<li>如果是 11, 重做</li>
<li>如果是 01 (得到这个的概率就是 p*(1-p)), 代表 0, 返回</li>
<li>如果是 10 (得到这个的概率就是 (1-p)*p), 代表 1, 返回</li>
</ul>
</li>
</ul>
<p>做到了 0 到 1 等概率</p>
<hr>
<h4 id="形成多少个二叉树结构"><a class="markdownIt-Anchor" href="#形成多少个二叉树结构">#</a> 形成多少个二叉树结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220322172206141.png" alt="image-20220322172206141"></p>
<p>只说结构，不关心值</p>
<ul>
<li>如果大于两个节点</li>
<li>一个头节点然后
<ul>
<li>没有左节点，N-1 个右节点</li>
<li>1 个左节点，N-2 个右节点</li>
<li>2 个左节点，N-3 个右节点</li>
<li>…</li>
<li>i 个左节点，N-i-1 个右节点  (可以说左树的每一种都是可以是跟右树的组合–&gt; <code>f(i)*f(N-i-1)</code> )</li>
<li>…</li>
<li>N-1 个左节点，没有个右节点</li>
</ul>
</li>
<li>所有可能的结果加一起就是方法数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323142906066.png" alt="image-20220323142906066"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323143359428.png" alt="image-20220323143359428"></p>
<hr>
<h4 id="完整括号字符串"><a class="markdownIt-Anchor" href="#完整括号字符串">#</a> 完整括号字符串</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323143450393.png" alt="image-20220323143450393"></p>
<p>先检查一个字符串是不是完整的</p>
<ul>
<li>从左到右遍历括号字符串，有一个变量是 count</li>
<li>遇到左括号 count++, 遇到右括号 count–</li>
<li>如果在期间任何一个时候 count 变成小于 0 了，那直接代表这个不是完整的，因为我们是<strong>从左往右</strong>的，要是 count 期间任何时候变成负数了，就说明是走过的一块右括号更多，这肯定不完整</li>
<li><strong>如果满足了上面一点</strong>，那么遍历完后，count 必须等于 0, 才能说明这个字符串是完整的</li>
</ul>
<p>对于这个问题</p>
<ul>
<li>我们同样像上面说的一样遍历等等等，再有一个变量叫 ans</li>
<li>如果期间遇到 count 是 - 1, 我们让 ans++, 代表我们填了一个括号让这个右括号有一个左括号，count 变回 0</li>
<li>遍历完的时候，我们 ans 存的就是此时需要添加的左括号，我们看遍历完的 count 如果不是 0 (比如说 5), 那就代表有 5 个多的左括号 (也就代表我们需要再添加 5 个左括号才行), 我们直接让 ans 此时的数加上 count 也就是我们需要添加的所有的括号数量.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323145727366.png" alt="image-20220323145727366"></p>
<hr>
<h4 id="去重数字对"><a class="markdownIt-Anchor" href="#去重数字对">#</a> 去重数字对</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323145808079.png" alt="image-20220323145808079"></p>
<ul>
<li>把所有数放进 hashset 里面去重</li>
<li>然后 hashset 每一个数都去检查当前这个数加上差值的那个数在不在 hashset 里面 (注<strong>意！只看自己数加上那个差值的，不要也看减去的，会重复的！(只看一个就行)</strong>)</li>
<li>如果在那就形成一对，如果不在就没有这一对，看 hashset 下一个元素</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323150307409.png" alt="image-20220323150307409"></p>
<hr>
<h4 id="magic操作"><a class="markdownIt-Anchor" href="#magic操作">#</a> magic 操作</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323150347533.png" alt="image-20220323150347533"></p>
<p>解法:</p>
<blockquote>
<p>业务问题需要看情况，分析各种情况，看些个 pattern 什么的，再加上小贪心</p>
</blockquote>
<ul>
<li>
<p>如果两个集合平均值一样，那不管从哪个集合拿哪个元素 (小于，等于，大于平均值的数) 都不会让两个集合的平均值增加</p>
</li>
<li>
<p>如果两个集合平均值一个大一个小</p>
<ul>
<li>那不管从小的平均值集合拿哪个元素 (小于，等于，大于平均值的数) 到大的平均值集合都不会让两个集合的平均值增加</li>
<li><strong>不过可以从大的平均值集合拿 <code>小于自己平均值但是大于小的平均值的元素</code> 到小的平均值集合可以做到会让两个集合的平均值增加</strong></li>
</ul>
</li>
<li>
<p>不过要是大的平均值有多个 <code>小于自己平均值但是大于小的平均值的元素</code> 该挑哪个？</p>
</li>
</ul>
<blockquote>
<p>我们选那个最小的符合的数，<strong><mark> 小贪心</mark></strong>，因为这个数是可以选的数中对于我们大的平均值的集合最大的拖后腿，所以<strong>把他移到更小平均值的集合可以最大幅度提升我们当前集合的平均值，以及让我们小的集合有最少的平均值的提升</strong></p>
</blockquote>
<ul>
<li>这么做可以让更多在大平均的集合里面的元素符合条件 (可能原本不符合), 现在因为大平均的集合增长了很多，小平均的结合增长了但是没有那么多，那么可能现在更多元素是符合 <code>小于自己平均值但是大于小的平均值的元素</code> 的条件了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323160147849.png" alt="image-20220323160147849"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323160232733.png" alt="image-20220323160232733"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323160257364.png" alt="image-20220323160257364"></p>
<p>时间复杂度就是 O (NlogN), 那个排序的操作</p>
<hr>
<h4 id="合法括号序列的深度"><a class="markdownIt-Anchor" href="#合法括号序列的深度">#</a> 合法括号序列的深度</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323162148514.png" alt="image-20220323162148514"></p>
<ul>
<li>跟之前说道的，用 count, 在遍历期间 count 变成的最大值就是最大深度</li>
</ul>
<hr>
<h4 id="最长合法括号子串"><a class="markdownIt-Anchor" href="#最长合法括号子串">#</a> 最长合法括号子串</h4>
<ul>
<li>我们可以对于每一个括号字符都存一个对应的数，这个数代表当前字符作为结尾，最长的合法括号子串是什么</li>
<li>可以用 dp</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323162743871.png" alt="image-20220323162743871" style="zoom:67%;" />
<ul>
<li>如果是一个左括号，不可能作为结尾，所以直接把所有的左括号位置的在 dp 表中设置为 0’</li>
<li><strong>对于一个右括号，如果他的下标是 i,dp [i] 的值可以靠 dp [i-1] 的值得到，比如说 dp [i-1] 是 4, 代表那个 i-1 位置的右括号作为结尾最长的合法括号子串长度是 4, 我们接着就需要 i-1-4 (那个 i-1 位置的右括号作为结尾最长的合法括号子串之前那个括号) 位置的括号，然后检查是不是左括号</strong>
<ul>
<li><strong>如果是的话那么 dp [i] 的值起码是 6, 不是肯定是 6, 这是因为 i-1-4 位置 (假设我们叫他 p 位置) 考虑进来了，我们还需要 dp [p-1] 位置的值加到 6, 才是我们当前 dp [i] 的值 (<mark>只需要截这一块一次，不需要考虑什么 dp [p-1-dp [p-1] 位置的值] 的值，因为 dp [p-1] 的值就是最长的结论</mark>)</strong></li>
<li><strong>如果不是左括号，那么 dp [i] 的值肯定是 0</strong></li>
</ul>
</li>
<li>dp 表中最大值就是答案，这个可以边设 dp 的时候边得，不需要都得出来之后又遍历什么的获取这个值</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323170035160.png" alt="image-20220323170035160"></p>
<hr>
<h4 id="将一个栈里面的数据排序"><a class="markdownIt-Anchor" href="#将一个栈里面的数据排序">#</a> 将一个栈里面的数据排序</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323170221722.png" alt="image-20220323170221722"></p>
<ul>
<li>比如说原始栈为 A, 辅助栈为 B</li>
<li>先从 A 弹出一个，放进 B 里面</li>
<li>再弹出一个
<ul>
<li>如果比 B 栈顶小，直接放到 B 栈顶</li>
<li>如果比 B 栈顶大，把 B 栈顶一个一个弹出来放到栈 A, 直到栈 B 为空或者遇到比当前数大的栈顶，我们才把这个数放到栈 B 栈顶</li>
</ul>
</li>
<li>接着再从栈 A 弹出 (可能有上面栈 B 里面放回来的), 重复上面操作</li>
<li>so on… 直到栈 A 为空</li>
<li>此时栈 B 就是从底到顶是从大到小的顺序，我们再从 B 一个一个弹出放到栈 A, 此时栈 A 就是从底到顶是从小到大的顺序</li>
</ul>
<hr>
<h4 id="根节点到叶节点最大权值"><a class="markdownIt-Anchor" href="#根节点到叶节点最大权值">#</a> 根节点到叶节点最大权值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323185019981.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323185009388.png" alt="image-20220323185009388"></p>
<hr>
<h4 id="matrix查找元素"><a class="markdownIt-Anchor" href="#matrix查找元素">#</a> matrix 查找元素</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323185459339.png" alt="image-20220323185459339"></p>
<p>列子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323185610555.png" alt="image-20220323185610555" style="zoom:67%;" />
<p>做法:</p>
<blockquote>
<p>从右上角开始找</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323185940890.png" alt="image-20220323185940890"></p>
<p>如果一个数找到越界了 (发现需要走左边检查但是当前在第 0 列走不了_或者是_发现需要走下边检查但是当前在最后一行走不了), 还是没有，那就不存在</p>
<blockquote>
<p>如果 matrix 是 n*m 大小</p>
<ul>
<li>我们如果暴力解法就是 O (n*m)</li>
<li>我们如果上面这个解法就是 O (n+m)–&gt; 最多走一行加一列</li>
</ul>
</blockquote>
<hr>
<h4 id="matrix找到含有最多1的那一行"><a class="markdownIt-Anchor" href="#matrix找到含有最多1的那一行">#</a> matrix 找到含有最多 1 的那一行</h4>
<p>每一行 0 肯定是会在 1 的左边，让你找到 matrix 里面含有最多 1 的那一行</p>
<p>列子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323190602034.png" alt="image-20220323190602034" style="zoom:67%;" />
<p>这个列子，第 2,3 行数的 1 最多，所以返回 2,3</p>
<ul>
<li>
<p>从右上角开始，把这个右上角所在的行数放进一个 list 里面去，一个变量 ans 为 0</p>
</li>
<li>
<p>如果左边有 1, 就一直走走到没有 1 的话就停，期间记录一共有几个 1 存到 ans</p>
</li>
<li>
<p>如果走完了，或者没有 1, 此时再往下</p>
<ul>
<li>如果是 0 就不要记录 (我们之前存的已经目前来说是最好的)</li>
<li>如果是 1, 就看左边有没有 1
<ul>
<li>如果有就一直走走到没有 1 的话就停，期间让 ans++ 就行，这个明显更长所以直接把 list 里面的清空把自己放进去，然后 ans 也是存他这一行的 1 的有多少</li>
<li>如果没有 1, 代表当前的这一行跟之前的那一行长度一样，直接把当前行数存进 list (不要清空 list 什么的！)</li>
</ul>
</li>
</ul>
<p>继续往下走…</p>
</li>
<li>
<p>最后走完了，list 里面存的那个就是答案</p>
</li>
</ul>
<p>比如说，另外一个列子</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323191509273.png" alt="image-20220323191509273" style="zoom:80%;" />
<hr>
<h4 id="打包机器洗衣机问题"><a class="markdownIt-Anchor" href="#打包机器洗衣机问题">#</a> 打包机器 (洗衣机问题)</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323193918917.png" alt="image-20220323193918917"></p>
<blockquote>
<p>解法：业务问题加贪心</p>
</blockquote>
<ul>
<li>
<p>如果知道一共有多少个衣服，然后有几个机器，我们就知道每一个机器应该是多少衣服</p>
</li>
<li>
<p>对于一个机器来说，我们可以得出他左边机器所有的衣服有多少 (也可以知道缺 / 多少), 然后也可以得出他右边机器所有的衣服有多少 (也可以知道缺 / 多少)</p>
</li>
<li>
<p>如果对于那一个机器来说</p>
<ul>
<li>
<p>如果左右两边都是负 (指的是都缺衣服), 那么 **<mark> 至少</mark><strong>需要</strong>左边缺的数量 + 右边缺的数量这么多轮 **</p>
</li>
<li>
<p>如果左右两边都是正 (指的是都多衣服，需要往外抛), 那么 **<mark> 至少</mark><strong>需要</strong> Math.max (左边多的数量，右边多的数量) 这么多轮，这是因为两边都可以同时往我们当前这个机器丢衣服 **</p>
</li>
<li>
<p>左右一个正一个负，那么 **<mark> 至少</mark><strong>需要</strong> Math.max (左边多 / 缺绝对值，右边缺 / 多绝对值), 这是因为我们可以多的那一边给我们当前机器给衣服，同时我们这个机器把衣服给到缺衣服的那一边，一边结束了不代表另外一边也结束了，还要继续把衣服给当前机器或者从当前机器拿衣服 **</p>
</li>
<li>
<p>如果左边 / 右边没有机器，说明当前是在第一台或者最后一台机器，那就认为那一边没有多的或少的</p>
</li>
</ul>
</li>
<li>
<p>我们可以对每一台机器都像上面操作，获取每一个机器对他来说至少要做出多少个操作存入数组 (或者变量保存最大值等等等)</p>
</li>
<li>
<p><strong>其实答案就是数组最大值，那个最大值代表了那一台机器需要至少操作才可以，因为这个是最大值，代表所有的机器至少需要那些操作才能真正达到最后每一个机器都有同样的衣服</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323203059319.png" alt="image-20220323203059319"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323203125877.png" alt="image-20220323203125877"></p>
<blockquote>
<p>这里那个 leftSum 是边遍历边存上之前元素的累加和，也就是当前元素左边所有的元素的累加和</p>
</blockquote>
<hr>
<h4 id="zigzag打印矩阵"><a class="markdownIt-Anchor" href="#zigzag打印矩阵">#</a> zigzag 打印矩阵</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323203626579.png" alt=""></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323211953201.png" alt="image-20220323211953201" style="zoom:67%;" />
<ul>
<li>两个位置一个 A 一个 B, 一开始在 (0,0), 打印</li>
<li>然后 A 的 col+1,B 的 row+1, 看现在这两个点形成的斜线，挨个按照你想要的顺序打印 (要么 A 打印到 B, 要么 B 打印到 A)</li>
<li>如果 A 无法再往右就往下，如果 B 无法再往下就往右，然后看新生成的斜线，挨个按照你想要的顺序打印 (要么 A 打印到 B, 要么 B 打印到 A)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323213122253.png" alt="image-20220323213122253"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323212438488.png" alt="image-20220323212438488"></p>
<hr>
<h4 id="螺旋打印矩阵"><a class="markdownIt-Anchor" href="#螺旋打印矩阵">#</a> 螺旋打印矩阵</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323203832362.png" alt="image-20220323203832362"></p>
<ul>
<li>我们只关心两个位置，一个左上角，一个右下角，只需要让这个两个位置形成的这一圈按照正确顺序打印就行了</li>
<li>这个打印完让他们的斜位置成为新的左上角新的右下角，然后再管这个新形成的这一圈就行了</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323204241864.png" alt="image-20220323204241864" style="zoom:50%;" />
<ul>
<li>如果左上位置和右下位置错过去了 (行或者列<strong>错过去了</strong>), 就停止</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323204339308.png" alt="image-20220323204339308" style="zoom:67%;" />
<blockquote>
<p>上面停止不是因为到了同一个列，而是因为错开了，我们左上角的 row 比右下角的 row 要大，这就是错开了 (或者就是我们左上角的 column 比右下角的 column 要大)</p>
</blockquote>
<blockquote>
<p><strong><mark>如果我们没有错开</mark>，然后左上角位置和右下角位置在同一行 / 同一列 (甚至重叠), 都需要打印出来</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323204752025.png" alt="image-20220323204752025" style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323204713364.png" alt="image-20220323204713364" style="zoom:67%;" />
<hr>
<h4 id="矩阵中顺时针转动90度"><a class="markdownIt-Anchor" href="#矩阵中顺时针转动90度">#</a> 矩阵中顺时针转动 90 度</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323205835323.png" alt="image-20220323205835323"></p>
<blockquote>
<p>跟上一题同理，先把外面一圈弄好，再弄里面的一圈，再弄那里面的一圈，so on…</p>
</blockquote>
<ul>
<li>对于每一圈，我们分组，我们先把四个角分为一组
<ul>
<li>然后左上角占右上角的位置</li>
<li>右上角占右下角的位置</li>
<li>右下角占左下角的位置</li>
<li>左下角占左上角的位置</li>
</ul>
</li>
<li>然后再让那四个角往上 / 下 / 左 / 右 (就是同一个圈上的) 走一步，那四个元素，同样操作，so on…</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323210848564.png" alt="image-20220323210848564" style="zoom:67%;" />
<p><code>分成的组数(一共有多少组)其实=当前圈右下角的col-当前圈左上角的col</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323211627763.png" alt="image-20220323211627763"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220323211614936.png" alt="image-20220323211614936"></p>
<hr>
<h4 id="拼接sm"><a class="markdownIt-Anchor" href="#拼接sm">#</a> 拼接 sm</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220324005838089.png" alt=""></p>
<ul>
<li>这个数可以被化解成他的质数因子的和，比如说 20=2*2*5</li>
<li>现在的问题就是以下哪个最优
<ul>
<li>我们先搞出两个然后再给这个 * 5 (也就是两个搞出五份来) 然后再 * 2 (也就是两个搞出五份来等于 10 个再搞出两份来), 还是</li>
<li>我们先搞出两个然后再给这个 * 2 (也就是两个搞出两份来) 然后再 * 5 (也就是两个搞出两份来等于 4 个再搞出五份来), 还是</li>
<li>我们先搞出五个然后再给这个 * 2 (也就是两个搞出两份来) 然后再 * 2 (也就是五个搞出两份来等于 10 个再搞出两份来)</li>
</ul>
</li>
</ul>
<p>所以，可以这么写，就是顺序不知道怎么样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325160429065.png" alt="image-20220325160429065"></p>
<blockquote>
<p>我们还需要质数只能是用操作 2, 要是操作 1 的话好像是多了就不行了，永远就不会达到</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=22&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV13g41157hK?p=22&amp;spm_id_from=pageDriver</a> [1:00:00 部分左右]</p>
</blockquote>
<p>这样答案反正就是这些   <code>质数因子加在一起-质数因子的数量</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325160829213.png" alt="image-20220325160829213"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325160840683.png" alt="image-20220325160840683"></p>
<hr>
<h4 id="字符串数组找出现最多的前k个"><a class="markdownIt-Anchor" href="#字符串数组找出现最多的前k个">#</a> 字符串数组找出现最多的前 k 个</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325161110309.png" alt="image-20220325161110309"></p>
<ul>
<li>用一个 map, 遍历字符串数组然后存每一个字符串以及出现的次数</li>
<li>接着把 map 里面东西按照每一个出现次数放进大根堆，之后 k 值有多少，你就取出多少就行</li>
</ul>
<p>或者</p>
<ul>
<li>用小根堆也可以，不过我们要确保小跟堆大小只有 k 个，必须加的元素要比此时小根堆的堆顶元素要大的时候才可以把堆顶 poll 了然后这个元素加进去 (让系统自己帮你调整现在的小根堆，或者自己弄的结构那么自己调整)</li>
</ul>
<blockquote>
<p>用小根堆的好处就是可以快速知道当前元素门槛有多低</p>
<p>而且事件复杂度是 O (k), 而不是像大根堆是 O (N)(N 是字符串类型有多少个不一样的字符串)</p>
</blockquote>
<hr>
<h4 id="如何创建一个动态的结构随时维持次数最多的前k个"><a class="markdownIt-Anchor" href="#如何创建一个动态的结构随时维持次数最多的前k个">#</a> 如何创建一个动态的结构，随时维持次数最多的前 k 个</h4>
<p>需要一个数据结构，我们想要保存一个字符串次数最多的前 k 个，但是允许我们这个字符串次数随时都会变换，所以是很动态的.</p>
<p>就好比候选人选举，他们的得票一直是在变的，我们如何随时都可以获取到当前获票最多的前 k 个</p>
<p>两个方法:</p>
<ol>
<li>add 方法，加一个字符串</li>
<li>printTopK 方法，打印前 k 个次数最多的字符串</li>
</ol>
<blockquote>
<p>这里我们就不能用原本的方式了，因为要是用户加了一个字符串，我们上面做法就是让 map 里面数据加加，然后对于所有数据再次做大根堆 / 小跟堆？这样肯定不行，很浪费时间！</p>
</blockquote>
<blockquote>
<p>我们希望上面两个方法代价不高</p>
</blockquote>
<p>解法:</p>
<blockquote>
<p>要我们手动写一个堆结构，不能用系统给的堆结构，因为无法对系统堆结构已经加到里面的元素进行更改等等等，就算要改的话他也是扫描全局找到那个被改的然后才能改，代价很高，但是我们自己的结构可以知道哪个被改了，然后对于那个做 heapify/heap insert 操作修正那个堆</p>
</blockquote>
<blockquote>
<p>注意我们假设如果出现次数一样的字符串选谁都可以，比如说十个字符串出现三次而且都是出现最多次的，而我们只需要打印前 5 个，那这 10 个里面随便 5 个都行的话就可以用这个方法</p>
</blockquote>
<ul>
<li>
<p>一个 hashmap 用来存字符串以及出现次数，一个按出现次数统计的小根堆 (以及 heapSize 代表大小，比如说这个例子里面大小为 3), 一个 hashmap 用来存一个字符串和他在堆上的位置 (指针)–&gt; 如果字符串没在堆上，要么那个字符串不在这个 hashmap 里面，要么存的对应的位置为 - 1</p>
</li>
<li>
<p>当加一个字符串时，就检查在不在第一个 hashmap 里面</p>
<ul>
<li>
<p>如果没在就加进去，然后检查此时堆有没有满 (一开始是空的), 没满就放进堆里面，然后把当前字符串和对应堆上的位置存到堆位置 hashmap 里面去</p>
</li>
<li>
<p>如果在就更新 hashmap 里面出现次数，然后看这个数在不在堆里面，如果在就做从 0 位置开始做 heapify (考虑这次这个数的增加了), 当然，堆里面位置换了，堆 map 也要更新所有元素在堆里面换成的新位置</p>
</li>
<li>
<p>如果这个加的字符串不在 hashmap 里面，然后堆当然也没有，此时堆也满了，就看能不能干过堆顶，干不过就只是把他记录到堆位置 hashmap 然后它对应的位置为 - 1</p>
</li>
<li>
<p>如果这个加的字符串已经 hashmap 里面，就更新值，然后发现堆满了而且这个字符串没在堆上，就拿当前这个更新后的值跟堆顶比较，如果更大加把堆顶去掉把这个放进去，做 heapify, 此时这个原本的堆顶在堆位置 map 更新他位置为 - 1, 然后其他的元素因为做了 heapify 都需要检查一下看一下有没有变换位置更换到正确位置</p>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325165511881.png" alt="image-20220325165511881"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325165615033.png" alt="image-20220325165615033"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325171525223.png" alt="image-20220325171525223"></p>
<blockquote>
<p>那个 index 指的是 heapSize, 之后换名了换成 heapSize</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325171804743.png" alt="image-20220325171804743"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325172215467.png" alt="image-20220325172215467"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325172317475.png" alt="image-20220325172317475"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325172330412.png" alt="image-20220325172330412"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325172339669.png" alt="image-20220325172339669"></p>
<blockquote>
<p>swap 的时候注意把堆位置里面数据改变！</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325172435703.png" alt="image-20220325172435703"></p>
<p>打印直接打印堆里面的数据就行了</p>
<blockquote>
<p>这个堆位置的 hashmap 其实就是快速确认一个字符串在不在堆上用的，如果不在就是 - 1, 如果在就可以快速查出来他的位置，查出来他的位置要是这个是更新了，比如说加了一定的值，就可以对他做 heapify/heap insert 操作，维持堆结构，这也就是为什么我们使用自定义的堆结构</p>
</blockquote>
<hr>
<h4 id="栈最小值"><a class="markdownIt-Anchor" href="#栈最小值">#</a> 栈最小值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325174347219.png" alt="image-20220325174347219"></p>
<ul>
<li>一个 data 栈用来存数据，一个 min 栈存最小值</li>
<li>当一个数据进来，我们把 data 栈中此时最小的值压入 min 栈中 (可以重复压入，这是为了之后 data 栈出栈，我们的 min 栈也会跟着出栈，保留此时最小值)</li>
</ul>
<blockquote>
<p>弹出的时候两个栈同步弹出就行了！！！min 栈保留的栈顶一定是当前 data 栈里面所有数据最小的</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325174652534.png" alt="image-20220325174652534"></p>
<hr>
<h4 id="用队列实现栈结构以及用栈实现队列结构"><a class="markdownIt-Anchor" href="#用队列实现栈结构以及用栈实现队列结构">#</a> 用队列实现栈结构以及用栈实现队列结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325174837878.png" alt="image-20220325174837878"></p>
<h5 id="用栈实现队列"><a class="markdownIt-Anchor" href="#用栈实现队列">#</a> 用栈实现队列</h5>
<ul>
<li>两个栈，一个叫 push 栈，一个叫 pop 栈</li>
</ul>
<blockquote>
<p>两个原则</p>
<ol>
<li><strong>push 栈要是倒东西 (pop), 需要一次倒完</strong></li>
<li><strong>pop 栈如果已经有东西，push 栈一定不要往里面倒数据，只有没数据的时候我们才可以让 push 栈里面数据一下全部倒完倒到 pop 栈里面去</strong></li>
</ol>
</blockquote>
<ul>
<li>我们把用户传进来的数据都压在 push 栈</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325175158068.png" alt="image-20220325175158068" style="zoom:50%;" />
<ul>
<li>如果想弹出的时候只需要把 push 栈一个一个弹出放入到 pop 栈里面去就行了</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325175212325.png" alt="image-20220325175212325" style="zoom:50%;" />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325175439348.png" alt="image-20220325175439348"></p>
<blockquote>
<p>可以发现很多方法都会尝试看能不能把数据从 push 栈倒到 pop 栈备用，因为我们取数据毕竟都是从 pop 栈取数据，但是加数据是加到 push 栈里面去，所以有时我们数据都在 push 栈不在 pop 栈，也有可能 pop 栈有数据，所以我们需要 pop 数据都被取完了我们 push 栈数据才能进，<em>* 而不是直接加进去，因为顺序会被打乱！！！</em>*</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325175522387.png" alt="image-20220325175522387"></p>
<h5 id="队列实现栈"><a class="markdownIt-Anchor" href="#队列实现栈">#</a> 队列实现栈</h5>
<ul>
<li>两个队列结构 A 和 B</li>
<li>用户放数据都放到队列 A 里面去</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325180201906.png" alt="image-20220325180201906" style="zoom:67%;" />
<ul>
<li>当用户想要取数据，我们把队列 A 里面除了最后一个数据的数据全都按顺序放到队列 B, 此时队列 A 有的数据就是如果用栈的话，可以获得的栈顶数据，就把那个数据弹出</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325180226808.png" alt="image-20220325180226808" style="zoom:67%;" />
<ul>
<li>此时队列 B 就相当于是我们的之前的 A, 要是相加数据直接往栈 B 加，如果想取就把除了最后一个元素其他所有的元素都放进队列 A 里面去，此时队列 B 有的数据就是如果用栈的话，可以获得的栈顶数据，就把那个数据弹出</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325180338801.png" alt="image-20220325180338801" style="zoom:67%;" />
<blockquote>
<p>太绝太绝 绝绝子</p>
</blockquote>
<hr>
<h4 id="动态规划的空间压缩技巧"><a class="markdownIt-Anchor" href="#动态规划的空间压缩技巧">#</a> 动态规划的空间压缩技巧</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325181120268.png" alt="image-20220325181120268"></p>
<ul>
<li>比如说一个 dp 表二维的，我们只想要一个格子的值作为答案，我们可能只需要一个数组就能做到得出答案</li>
<li>比如说:</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325181752051.png" alt="image-20220325181752051" style="zoom:67%;" />
<p>f 依赖 a 所以可以得出 f 换掉 a 的位置，g 依赖 f 和 b (我们此时都有) 所以可以得出 g 换掉 b 的位置，so on…</p>
<p>一个一个边，然后一行一行边，最后变成最后一行，我们就有对应的答案的格子</p>
<blockquote>
<p>空间从 2 维变成 1 维，省空间的做法，时间还是一样的</p>
</blockquote>
<blockquote>
<p>注意！！！我们具体该从哪一行开始，从左到右还是从右到左，以及各种具体的操作都是要看你具体的 dp 每一个格子是怎么依赖的，<strong><mark>我们还可以使用变量等用来记住之前一行中可能会需要用到的值</mark></strong></p>
</blockquote>
<p>就是比如说我们有 4*100 万的数组，我们可以设置为每一列作为我们数组大小，然后进行 100 万次，不过具体的还是需要看怎么依赖等等</p>
<blockquote>
<p>甚至不需要是同一行同一列的，我们只看依赖的顺序，先把先被依赖的加进去，然后按照别的对这些依赖一个一个更新…</p>
<p>甚至三维等等等都可以压缩成二维…</p>
</blockquote>
<hr>
<h4 id="装水"><a class="markdownIt-Anchor" href="#装水">#</a> 装水</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220325194433809.png" alt="image-20220325194433809"></p>
<ul>
<li>跟洗衣机问题很像，我们只关心每个位置自己上方可以留下多少水</li>
</ul>
<p>举列：当前 i 位置是 5, 左边最大值 10, 右边最大值 20</p>
<ul>
<li>
<p>那么当前位置肯定会停 5 个水，因为超过 10 的话肯定都会从左边溜走了</p>
</li>
<li>
<p>所以我们需要 <code>Math.min(数组0到i-1位置最大值,数组i+1到结尾位置最大值)-nums[i]</code>  这个就是对于当前数来说是至少能装的水</p>
<ul>
<li>如果这个结果负数，那么当前数就是 0, 能存 0 个水</li>
</ul>
<p>所以最终是 <code>Math.max(Math.min(数组0到i-1位置最大值,数组i+1到结尾位置最大值)-nums[i],0)</code></p>
</li>
<li>
<p>所以只要给每一个位置的都算出这个，让他们加一起就是答案</p>
</li>
<li>
<p>时间复杂度 O (n)</p>
</li>
</ul>
<p>你可能会想用两个辅助数组分别存每一个位置他左边到他的最大值，以及他到他右边的最大值</p>
<blockquote>
<p>但是我们甚至可以想一个不用这两个辅助数组，空间复杂度 O (1) 也可以，时间复杂度还是 O (n)</p>
</blockquote>
<p>列子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327141522977.png" alt="image-20220327141522977" style="zoom:67%;" />
<ul>
<li>首先一个变量 all 一开始 0,leftSum 代表左边我们遍历过的最大值，rightSum 代表右边我们遍历过的最大值，一个 left 变量一个 right 变量</li>
<li>0 位置和 8 位置自己肯定留不下水，因为有一边是没高度的，水一定会流走，所以都不看. leftSum=10,rightSum=7,left 指向 1 开始的位置，right 指向 7 结束的位置</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327142500977.png" alt="image-20220327142500977"></p>
<ul>
<li>
<p>此时我们其实可以直接让 R 位置的结算获取最大值，因为就算我们 leftSum 并不是对于他来说是最大值，但是 rightSum 就是对于他来说是右边的最大值<strong>而且这个已经比 leftSum 要小了</strong>，我们需要的就是那个更小的那个，所以，可以直接获取 R 位置的水量也就是 7-3 等于 4 (存进 all 变量去), 然后 R–</p>
</li>
<li>
<p>然后 R 就是 6 位置的 11 了，此时我们也可以对这个位置结算水的数量，也就是 0 (因为 7-11 等于负数), 然后 R–, 注意这个比此时这个<strong> rightSum 要大，所以 rightSum=11</strong></p>
</li>
<li>
<p>然后接下来 L 位置的可以结算了，因为此时对于他来说 leftSum 就是他左边的最大值，然后这个比 rightSum 要小，虽然这个 rightSum 并不一定对于这个位置来说是他右边的最大值 (其实确实不是，他右边 12 才是最大值) 但是我们的 leftSum 已经比 rightSum 要小了，所以可以直接用 leftSum 算就行了，也就是 10-8 等于 2,L++, 然后 8 并没有比此时 leftSum 的 10 大，所以不更新 leftSum 的值</p>
</li>
<li>
<p>就是这样就是检查此时 rightSum 跟 leftSum 哪个更小</p>
<ul>
<li>leftSum 更小，那就用 leftSum 获取 L 位置的水 (存进 all 变量里面去), 然后 L++, 检查 L 位置的元素是不是比 leftSum 更大，更大的话要更新</li>
<li>rightSum 更小，那就用 rightSum 获取 R 位置的水 (存进 all 变量里面去), 然后 R–, 检查 R 位置的元素是不是比 rightSum 更大，更大的话要更新</li>
</ul>
</li>
<li>
<p>之后所有元素都结束之后 (L&gt;R 的时候), 我们 all 变量存的就是答案</p>
</li>
</ul>
<blockquote>
<p>O (n) 时间复杂度，O (1) 空间复杂度</p>
</blockquote>
<hr>
<h4 id="砍数组最大的左右部分的最大值的差值"><a class="markdownIt-Anchor" href="#砍数组最大的左右部分的最大值的差值">#</a> 砍数组，最大的左右部分的最大值的差值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327143225913.png" alt=""></p>
<ul>
<li>
<p>首先找到这个数组的全局最大值</p>
<ul>
<li>
<p>要是这个最大值是在左部分，那他就是左部分的 max, 接下来就是决定该怎么划分可以让右部分的最大值尽量小，我们知道右边部分肯定会包含 n-1 位置的数，让他最大值最小的方式就是让他只包含 n-1 位置的数即可–&gt; 所以就是</p>
<p><code>全局最大值-arr[n-1]</code></p>
<blockquote>
<p>你可能会想，不对啊，要是我门比如说 n-2 位置的数比 n-1 位置的数要小，那不就代表我们可以获得绝对值差值更大的吗</p>
<p><strong>但是我们要的是左右部分最大值，要是 n-2 位置的数比 n-1 位置的数要小，那么最大值还是选的 n-1 位置的数</strong></p>
<p>你可能会想，那要是 n-2 位置的数比 n-1 位置的数要大，那就可以让有部分最大值是这个数了吗</p>
<p><strong>但是我们为什么要这么做，我们想要差值最大的，你这给了个更大的数，岂不是让我们差值更小了吗</strong></p>
<p>我们这个情况只包含 n-1 位置是有部分不管多长，<mark> 肯定是包含 n-1 位置的</mark>，然后我们看上面就知道只是包含 n-1 位置的右部分才是最符合我们想要的数，下面关于全局最大在左部分也是同理.</p>
</blockquote>
</li>
<li>
<p>要是这个最大值是在右部分，那他就是右部分的 max, 接下来就是决定该怎么划分可以让左部分的最大值尽量小，我们知道左边部分肯定会包含 0 位置的数，让他最大值最小的方式就是让他只包含 0 位置的数即可–&gt; 所以就是</p>
<p><code>全局最大值-arr[0]</code></p>
</li>
<li>
<p>所以答案就是 <code>Math.max(全局最大值-arr[n-1],全局最大值-arr[0])</code></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="旋转字符串"><a class="markdownIt-Anchor" href="#旋转字符串">#</a> 旋转字符串</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327154305966.png" alt="image-20220327154305966"></p>
<ul>
<li>判断两个长度是不是一样，不一样直接返回</li>
<li><strong>只有长度一样</strong>，那么我们让 a 变成 a+a (就是他自己两个字符串相连), 然后只需要看 b 是不是这个新 a 的子串就行了 (KMP 算法)</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327154631659.png" alt="image-20220327154631659" style="zoom:67%;" />
<blockquote>
<p>这个新 a 任意长度为 b.length (这个列子里面为 5) 的子串都是原来字符串的旋转词</p>
<p><strong>所以要是 b 是这个的子串就代表 b 是原来 a 的旋转词嘛</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327154843626.png" alt="image-20220327154843626"></p>
<hr>
<h4 id="咖啡问题"><a class="markdownIt-Anchor" href="#咖啡问题">#</a> 咖啡问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327155105133.png" alt="image-20220327155105133"></p>
<ul>
<li>有个小根堆，存的是每一个咖啡机的时间单位以及在什么时候可用，排序是两个数相加谁小谁排在上面，所以堆顶就是所有机器谁现在泡完结束时间小的排在上面</li>
<li>对于每一个人都从堆顶拿一个，然后让第一个数加上第二个数 (结果就是这个人可以喝咖啡机的时间), 再把更新了第一个数的整体放回小根堆，下一个人…</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327164753259.png" alt=""></p>
<ul>
<li>
<p>这么做我们就可以获得对于每一个人来说什么时候可以得到咖啡 (以及喝掉) 的时候，也就代表我们可以获取到所有时间点有需要洗的需求了，<strong> 所以现在问题就是我们有一堆需要洗杯子的时间点，我们该怎么洗才能最快最短的让这些都洗完</strong></p>
<p>我们有两种选择</p>
<ol>
<li>洗咖啡杯的机器洗</li>
<li>自动挥发</li>
</ol>
</li>
<li>
<p>所以这个就是个从左到右尝试的模型</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327171026565.png" alt="image-20220327171026565"></p>
<blockquote>
<p>可以改动态规划</p>
</blockquote>
<hr>
<h4 id="相乘为4"><a class="markdownIt-Anchor" href="#相乘为4">#</a> 相乘为 4</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327172030147.png" alt="image-20220327172030147"></p>
<ul>
<li>
<p>首先遍历，看有几个 (a 个) 奇数，有几个偶数但是只有一个 2 因子 (b 个), 以及有几个偶数但是包含 4 因子的数 (c 个)</p>
</li>
<li>
<p>如果 b==0</p>
<ul>
<li>我们可以这么摆 奇 4 奇 4 奇 4… 这样交叉着摆就是最可以确保任何两个相邻的数相乘都会是 4 的倍数</li>
<li>如果奇数为 0 a==0 说明只有包含 4 因子的偶数，那么随便摆</li>
<li>所以奇数只有一个的时候 a==1 我们有 4 因子的偶数至少需要有 1 个及以上便足够 c&gt;=1 (如果没有的话就返回 false)</li>
<li>如果奇数大于 1 的时候 a&gt;1 我们至少需要每两个奇数之间都要有一个 4 因子的偶数 c&gt;=a-1 (如果没有这么多的话就返回 false)</li>
</ul>
</li>
<li>
<p>如果 b!=0</p>
<ul>
<li>我们可以把所有这些只有一个 2 因子的偶数都放在一起，这样他们之间互相任意两个都可以相乘然后变成 4 的倍数</li>
<li>如果奇数是 0 a==0 我们把所有只有一个 2 因子的偶数都放在一起，然后剩下的都是有一个 4 因子的偶数随便放甚至没有都行 c&gt;=0</li>
<li>如果奇数是 1 a==1 我们把所有只有一个 2 因子的偶数都放在一起，然后紧跟着必须是一个有一个 4 因子的偶数然后才能是奇数 (2222222…4 奇 (4)) c&gt;=1</li>
<li>如果奇数大于 1 a&gt;1 我们把所有只有一个 2 因子的偶数都放在一起，然后紧跟着必须是一个有一个 4 因子的偶数然后才能是奇数 (2222222…4 奇 4 奇 4…) c&gt;=a</li>
</ul>
<p><strong>所以同一化简为 c 要 &gt;=a 即可，如果不符合，那么直接返回 false</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327173712401.png" alt="image-20220327173712401"></p>
</li>
</ul>
<p>还有就是 edge case, 比如说只有一个 2 因子的数，那就必须需要一个 4 因子的数一块才行</p>
<blockquote>
<p>这种题就是分类，然后对于每一种可能就想需要什么，什么要求等等等，然后看看符不符合要求，不符合直接返回 false</p>
</blockquote>
<hr>
<h4 id="递归式从on简化成ologn的方法"><a class="markdownIt-Anchor" href="#递归式从on简化成ologn的方法">#</a> 递归式从 O (N) 简化成 O (logn) 的方法</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=24">https://www.bilibili.com/video/BV13g41157hK?p=24</a></p>
<p>从头开始，数学有点差… 比较懵逼</p>
</blockquote>
<blockquote>
<p>要求是严格递归才可以！！！</p>
<p><strong>如果你递归函数里面处了 base case 有什么 if (目前什么情况) 回调自己传某种参数 else 回调自己传另外一种参数</strong></p>
<p><strong>这样的递归函数不是严格递归的，他是按照你某个数据实际情况的，这种不行</strong></p>
</blockquote>
<p>严格递归就需要像 fibonacci 这种，比如说 f (n)=f (n-1)+f (n-2) 这种， <code>f(n-1)+f(n+2)</code>  这部分对于所有层都是固定的，那就是严格函数，所以就算是 f (n)=2f (n-1)+3f (n-2)-1000f (n-3)+0f (n-4)-200f (n-5) 这种，只要右边对于每一层都是一样的那么就没问题，还是严格地故意，可以用这个简化的方法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327175558779.png" alt="image-20220327175558779" style="zoom:50%;" />
<p>我们可以算出 a,b,c,d 的值</p>
<p>然后就可以用这些值算之后想要的值，就更快了</p>
<h5 id="斐波那契数列快速幂解"><a class="markdownIt-Anchor" href="#斐波那契数列快速幂解">#</a> 斐波那契数列快速幂解</h5>
<p>暴力解复杂度为</p>
<p>O(2^N)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/41477af44b504336a1ae4c954f9e65ab.png" alt=""></p>
<p>快速求 10^75.</p>
<p>75 转为 2 进制 1001011</p>
<p>int res=0；</p>
<p>intemp=10</p>
<p>t 每次和自己相乘，10^1 10^2. 10^4. 10^8. 10^16……</p>
<p>然后判断对应二进制位是否为 1 ，如果为 1 ，res= res * t</p>
<p>对于矩阵，每次也是 M^1 M^2 ……</p>
<p>对应二进制位为 1 乘进 res 中</p>
<h6 id="剑指-offer-10-i-斐波那契数列"><a class="markdownIt-Anchor" href="#剑指-offer-10-i-斐波那契数列">#</a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h6>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>base<span class="token operator">=</span><span class="token punctuation">&#123;</span>
            <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token function">matrixPower</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">matrixPower</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> temp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token comment">// 如果对应二进制位为1 则乘进去</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
                    ret <span class="token operator">=</span> <span class="token function">muliMatrix</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                m <span class="token operator">=</span> <span class="token function">muliMatrix</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                temp<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">muliMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="值得记忆"><a class="markdownIt-Anchor" href="#值得记忆">#</a> 值得记忆</h6>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//当二进制不为0时</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     <span class="token comment">// 如果对应二进制位为1 则乘进去</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
         ret <span class="token operator">=</span> <span class="token function">muliMatrix</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">&#125;</span>
     <span class="token comment">//如果二进制位为0，则自乘</span>
     m <span class="token operator">=</span> <span class="token function">muliMatrix</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 右移</span>
     temp<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="背包问题的变种"><a class="markdownIt-Anchor" href="#背包问题的变种">#</a> 背包问题的变种</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327183423724.png" alt="image-20220327183423724"></p>
<ul>
<li>dp [i][j],i 为体积数组中哪一个下标，j 为 0 到 w 的体积</li>
<li>所以这个 dp 最后一行 (我们这里是从上往下方式，也就是从下往上依赖), 最后的累加就是答案</li>
</ul>
<hr>
<h4 id="牛牛找工作"><a class="markdownIt-Anchor" href="#牛牛找工作">#</a> 牛牛找工作</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327190419112.png" alt="image-20220327190419112"></p>
<ul>
<li>用有序表，难度小的排在前面，难度一样的话报酬更高的排前面</li>
<li>然后对于每一组难度一样的，只留下报酬高的，让报酬低的走开</li>
<li>然后现在看哪个难度增加了但是报酬没有增加的直接走开，剩下的保留</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327191139998.png" alt="image-20220327191139998" style="zoom:67%;" />
<p><strong>现在我们就创造了难度递增并且报酬也是递增的有序表</strong></p>
<blockquote>
<p><strong>接下来对于每一个小伙伴，就选对于他能力来说最高能接受的难度的工作，其实那个就是对于他来说是报酬最高的</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327191401801.png" alt="image-20220327191401801"></p>
<hr>
<h4 id="符合人们日常书写"><a class="markdownIt-Anchor" href="#符合人们日常书写">#</a> 符合人们日常书写</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327191451595.png" alt="image-20220327191451595"></p>
<p>比如说，一般都是 7, 而不是 07, 等等等</p>
<p>所以，三点</p>
<ul>
<li>数字之外只能有减号</li>
<li>如果有减号，必须是在开头，必须是一次，必须之后必须是数字，而且那个数字不能是 0</li>
<li>如果开头第一个是 0, 后面必须没有数字</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327191819854.png" alt="image-20220327191819854"></p>
<p>如果可以转的话，我们就可以:</p>
<blockquote>
<p>不管原来是不是负数，我们都用一个负数来接收答案</p>
</blockquote>
<p>这是因为：负数的表达值范围比正数的表达值范围大一个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327192137457.png" alt="image-20220327192137457"></p>
<p>要是我们接收的数字是 - 2147483647, 那么用我们用正数接收，那么就会越界</p>
<p>虽然接收正数的最大值没关系，但是接收负数的最大值会多一个接收不了，所以干脆都用负数接收 (就是一个一个接收), 然后接收完再看要是负数直接就返回，如果是正数那么就变成正数返回</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327192522011.png" alt="image-20220327192522011"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327192906392.png" alt="image-20220327192906392"></p>
<hr>
<h4 id="目录显示"><a class="markdownIt-Anchor" href="#目录显示">#</a> 目录显示</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327193559223.png" alt="image-20220327193559223"></p>
<blockquote>
<p>使用前缀树</p>
</blockquote>
<ul>
<li>组织成一个前缀树 (先建立一个空节点，然后遍历字符创建前缀树)</li>
<li>深度优先遍历解决
<ul>
<li>第一层的直接打印</li>
<li>第二层的打印两个空格然后打印那个字符</li>
<li>第四层的打印四个空格然后打印那个字符</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327193755504.png" alt="image-20220327193755504"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327194252772.png" alt="image-20220327194252772"></p>
<ul>
<li>这里可以看出每一个节点本身还把那个字符存上了，其实不用，一般都是存在那个 nextMap 属性就行了</li>
<li>还有那个 nextMap 是有序表，这是因为你想排序那些字符的比如说 a/b 和 a/c, 用有序表就可以先打印 a 下面的 b 然后才是那个 a 下面的 c (属于同一个头层) 的所有同一级的所有按照顺序排</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327194653701.png" alt="image-20220327194653701"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327194910151.png" alt="image-20220327194910151"></p>
<hr>
<h4 id="二叉树变成双向链表"><a class="markdownIt-Anchor" href="#二叉树变成双向链表">#</a> 二叉树变成双向链表</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327195256234.png" alt="image-20220327195256234"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327195241512.png" alt="image-20220327195241512"></p>
<blockquote>
<p>二叉树 dp 递归套路</p>
</blockquote>
<ul>
<li>
<p>对于我们二叉树一个节点 x 来说，我们只需要他左树和右树头节点和尾节点，这样我们可以</p>
<ul>
<li>x.last (left)= 左树尾节点</li>
<li>左树尾节点.next (right)=x</li>
<li>x.next (right)= 右树头节点</li>
<li>右树头节点.last (left)=x</li>
</ul>
<p>返回以 x 代表的整颗树的尾节点也就是搜索二叉树最左的节点 (最小值的那个) 和 x 代表的整颗树的头节点也就是搜索二叉树最右的节点 (最大值的那个)</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327195748355.png" alt="image-20220327195748355"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327200157024.png" alt=""></p>
<p>最后答案就是整个的树的头节点 (start), 也就是整个树最小的值的那个节点</p>
<hr>
<h4 id="在一个二叉树中找最大搜索二叉树的节点个数"><a class="markdownIt-Anchor" href="#在一个二叉树中找最大搜索二叉树的节点个数">#</a> 在一个二叉树中找最大搜索二叉树的节点个数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220327200842963.png" alt=""></p>
<blockquote>
<p>子树就是选定一个头节点之后，下面所有节点都包括才算子树</p>
</blockquote>
<p>左右树都需要</p>
<ul>
<li>最大搜索子树的头节点</li>
<li>isBST</li>
<li>最小值</li>
<li>最大值</li>
<li>最大搜索树的节点个数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403192144397.png" alt="image-20220403192144397"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403192740271.png" alt="image-20220403192740271"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403192939667.png" alt="image-20220403192939667"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403193056110.png" alt="image-20220403193056110"></p>
<p>然后就是看当前节点和他的左右在一起是不是 bst, 如果是就要设置 isBST 然后设置最大搜索子树的头节点以及最大搜索树的节点个数的值</p>
<hr>
<h4 id="招聘信息和打分系统"><a class="markdownIt-Anchor" href="#招聘信息和打分系统">#</a> 招聘信息和打分系统</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403194527385.png" alt="image-20220403194527385"></p>
<blockquote>
<p>就是找连续子数组最大值的和</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403225713682.png" alt="image-20220403225713682"></p>
<hr>
<h4 id="整形矩阵的子矩阵最大累加和"><a class="markdownIt-Anchor" href="#整形矩阵的子矩阵最大累加和">#</a> 整形矩阵的子矩阵最大累加和</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403230917887.png" alt="image-20220403230917887"></p>
<p>列子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403231103780.png" alt="image-20220403231103780"></p>
<p>方法:</p>
<ul>
<li>在 0 到 0 行上，哪个子矩阵累加和是最大的</li>
<li>在 0 到 1 行上，哪个子矩阵累加和是最大的</li>
<li>在 0 到 2 行上，哪个子矩阵累加和是最大的</li>
<li>在 1 到 1 行上，哪个子矩阵累加和是最大的</li>
<li>在 1 到 2 行上，哪个子矩阵累加和是最大的</li>
<li>在 2 到 2 行上，哪个子矩阵累加和是最大的</li>
</ul>
<blockquote>
<p>如果还有其他行就各种等等等…</p>
</blockquote>
<p>然后对于上面说的每一个，比如说 0 到 0 行，我们就可以用上面说的方式直接找到对于 0 到 0 的答案</p>
<p><strong>但是如果是 0 到 1, 我们需要让 0 行跟 1 行每一列的数字跟同列数字相加，然后再对结果做上面说的一个数组找出最大的，找出的 max 就是 0 到 1 行对应的子矩阵最大累加和</strong></p>
<blockquote>
<p>压缩数组技巧</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403231629960.png" alt="image-20220403231629960"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403232004798.png" alt="image-20220403232004798"></p>
<blockquote>
<p>时间复杂度: O (N<sup>2</sup>*M)</p>
</blockquote>
<hr>
<h4 id="路灯问题"><a class="markdownIt-Anchor" href="#路灯问题">#</a> 路灯问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404100615050.png" alt="image-20220404100615050"></p>
<blockquote>
<p>也可以遍历那个字符串，对于每一块为.(路) 的区域计算有多少.(路), 然后对于每一块除 3 向上取整</p>
</blockquote>
<p>或者如果我们在 i 位置</p>
<ul>
<li>如果 i 位置是 X (墙), 那就不给灯跳到下一个</li>
<li>如果 i 位置是.(路), 那就看 i+1 位置的，如果
<ul>
<li>i+1 位置是 X (墙), 那就把灯给到 i 位置的</li>
<li>i+1 位置是.(路), 那就把灯给到 i+1 位置的 —&gt; 贪心</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404102050826.png" alt="image-20220404102050826"></p>
<hr>
<h4 id="二叉树前序数组和中序数组找后序数组"><a class="markdownIt-Anchor" href="#二叉树前序数组和中序数组找后序数组">#</a> 二叉树前序数组和中序数组找后序数组</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404102212625.png" alt="image-20220404102212625"></p>
<ul>
<li>一开始先序遍历第一个一定是后序遍历最后一个</li>
<li>然后在中序数组找到那个元素，此时中序数组左边的所有就是对于这个元素来说整个的左树</li>
<li>这个找到的区域前序数组也可以找到对应的，后序也会有</li>
<li>反正想法就是对于每一个区域来说找到一定区域的答案，然后递归等等等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404102624667.png" alt="image-20220404102624667"></p>
<blockquote>
<p>可以用 hashmap 做预处理，就不用每次遍历去找中序数组那个元素所在位置了</p>
</blockquote>
<blockquote>
<p>复杂度就是 O (N), 数组每一个元素都只经过一次</p>
</blockquote>
<hr>
<h4 id="数字打印出成中文的样子"><a class="markdownIt-Anchor" href="#数字打印出成中文的样子">#</a> 数字打印出成中文的样子</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404103742469.png" alt="image-20220404103742469"></p>
<p>英文版本:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404103912632.png" alt="image-20220404103912632"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404104019413.png" alt="image-20220404104019413"></p>
<blockquote>
<p>从小范围扩到大范围的问题</p>
</blockquote>
<hr>
<h4 id="完全二叉树的节点个数"><a class="markdownIt-Anchor" href="#完全二叉树的节点个数">#</a> 完全二叉树的节点个数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404104810804.png" alt="image-20220404104810804"></p>
<ul>
<li>遍历到左树最底层获取层数，然后看头节点的最左最低节点层数跟我们的左树一不一样
<ul>
<li>如果一样，那么左树就是满的，可以获得左树的节点个数然后看右节点开始的右树看有多少个…</li>
<li>如果不一样，那么右树肯定是比左树少一层且满的，可以获得右树的节点个数然后看左节点开始的左树看有多少个…</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404105221440.png" alt="image-20220404105221440"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404105358509.png" alt="image-20220404105358509"></p>
<blockquote>
<p>时间复杂度为 O (h<sup>2</sup>), 相当于对于一个高度的每一个节点都需要过一次高度</p>
<ul>
<li>头节点需要过 h-1 个节点</li>
<li>头的左 / 右节点需要过 h-2 个节点</li>
<li>头的左 / 右节点的左 / 右节点需要过 h-3 个节点</li>
<li>…</li>
</ul>
<p>这个算法也可以说是 O ((logN)<sup>2</sup>)</p>
</blockquote>
<hr>
<h4 id="最长递增的子序列"><a class="markdownIt-Anchor" href="#最长递增的子序列">#</a> 最长递增的子序列</h4>
<p>O(N<sup>2</sup>) 答案:</p>
<ul>
<li>有一个 dp 数组存每一个 arr [i] 结尾的递增子序列的最长长度</li>
<li>然后遍历原数组，对于每一个数组就去遍历左边找比他小的，然后如果有多个比他小的，就用那个比他小的且 dp 数组里面长度比其他比他小的还要大的那个，然后这个元素对应下标位置的 dp 元素就是那个比他小的 dp 数组中的值 + 1</li>
<li>最后遍历完，dp 数组最大的就是答案</li>
</ul>
<p>O (NlogN) 答案:</p>
<ul>
<li>dp 加上 binary search, 参考上面 leetcode98 题</li>
</ul>
<hr>
<h4 id="神器的数列"><a class="markdownIt-Anchor" href="#神器的数列">#</a> 神器的数列</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404112734905.png" alt="image-20220404112734905"></p>
<p>三种方式</p>
<ol>
<li>获取到那个整个数，然后模 3</li>
<li>把每一位数字视为一个数相加然后结果模 3</li>
<li>1+2+3+… 一直加到那个 n 值的结果模 3 也可以！</li>
</ol>
<hr>
<h4 id="找到1-n未出现整数"><a class="markdownIt-Anchor" href="#找到1-n未出现整数">#</a> 找到 1-n 未出现整数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404113444996.png" alt="image-20220404113444996"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404113749661.png" alt="image-20220404113749661"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404113834236.png" alt="image-20220404113834236"></p>
<p>一定会有终止的时候，因为上面数字就是 1 到 N 之间</p>
<hr>
<h4 id="土豪女主播"><a class="markdownIt-Anchor" href="#土豪女主播">#</a> 土豪女主播</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404113946858.png" alt="image-20220404113946858"></p>
<p>你可能会想出这么一个递归:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404114316592.png" alt="image-20220404114316592"></p>
<blockquote>
<p>但是上面这个没法结束，因为:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404114406337.png" alt="image-20220404114406337" style="zoom:67%;" />
<p>主要是那个减 2, 可能回到之前已经试过的</p>
<p>我们可以多加 basecase, 来确保返回</p>
</blockquote>
<p>这么考虑 base case, 可以想对于这个业务的可能性，</p>
<p><strong>一般想偶数奇数等等等可能性很不错</strong></p>
<ul>
<li>一开始的数是偶数，end 也是偶数，所以我们要是使用 + 2 的方式，就一直加 2 加 2 加 2… 是肯定能到的，我们可以先算出来这种方式一共需要多少个币，这个平凡解就可以作为我们的 base case, 因为我们想要的是币最少的方式，所以要是另外方法要是比这个平凡解要高我们也不需要，basecase 直接返回，而要是这个是比我们的平凡解要低，就需要</li>
<li>这样我们就可以人为的加 base case (限制), 来确保递归可以退出</li>
</ul>
<p>然后对于我们这个问题还可以有针对于这个问题的限制，比如说</p>
<ul>
<li>我们一开始 6, 结束值是 10, 我们不需要两倍于结束值，因为没必要啊，我们只需要 2*6-2 就行了，对于所有列子来说我们都不需要把当前数变成结束值的两倍然后慢慢 - 2 变成结束值</li>
<li>这个比较针对于问题，主要看你问题然后想出有什么限制等等等</li>
</ul>
<p>最终答案:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404115612407.png" alt="image-20220404115612407"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404120009647.png" alt="image-20220404120009647"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404115822858.png" alt="image-20220404115822858"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404115836489.png" alt="image-20220404115836489"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404115945322.png" alt="image-20220404115945322"></p>
<hr>
<h4 id="cc直播运营"><a class="markdownIt-Anchor" href="#cc直播运营">#</a> CC 直播运营</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404120157067.png" alt="image-20220404120157067"></p>
<p>可以从结尾开始</p>
<ul>
<li>从结尾节点开始，每一个节点都有一个 map (有序表) 来存 key 作为目前节点到结尾节点一共几天以及 value 是钱数</li>
<li>结尾节点之后，再做任何有 arc 指向结尾节点的节点，更新他们对应的各自的 map 的 key 和 value</li>
<li>每一个节点的 map 里面可能有多个记录比如说这个节点有多个 outgoing edges to other edges, 都要把对应的存上，注意我们还想要确保 map 里面存的 key 要是更大，那么 value 就一定更大，不符合的都删掉，然后接着去找下一个节点…</li>
<li>之后把每个节点的 map 的每个记录放到一个大 map 里面去，确保 map 里面存的 key 要是更大，那么 value 就一定更大，不符合的都删掉，之后这个 map 就可以查到任何一个天数内获得的最大收益</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404133216308.png" alt="image-20220404133216308"></p>
<p>如果一个一节的 map 只有很垃的，请不要删，还是留着，因为:</p>
<p>后面连着的说不定有很好的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404133722940.png" alt="image-20220404133722940"></p>
<blockquote>
<p>所以每一个节点都要保持一个 map, 而不是同用一个 map, 可能会提前把最符合答案得必须需要的一个节点的信息给清掉了</p>
</blockquote>
<hr>
<h4 id="逻辑决定布尔值"><a class="markdownIt-Anchor" href="#逻辑决定布尔值">#</a> 逻辑决定布尔值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404134515611.png" alt=""></p>
<ul>
<li>假设每一个符号都是他是最后结算的
<ul>
<li>如果这个符号是 &amp; 然后想要 True, 所以如果左边一共 a 种方法获得 true 右边有 b 种获得 true, 那么这整个就可以有 a*b 种方法是 true</li>
<li>等等…</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404140001133.png" alt="image-20220404140001133"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404140008554.png" alt="image-20220404140008554"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404140837456.png" alt="image-20220404140837456"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404141739483.png" alt="image-20220404141739483"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404141749252.png" alt="image-20220404141749252"></p>
<p>可以改 dp (也就是两个二维表，一个 desired 是为 true 的一个是 desired 为 false 的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404141933831.png" alt="image-20220404141933831"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404142303860.png" alt="image-20220404142303860"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404142325086.png" alt="image-20220404142325086"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404142133163.png" alt="image-20220404142133163"></p>
<hr>
<h4 id="最长不重复子串"><a class="markdownIt-Anchor" href="#最长不重复子串">#</a> 最长不重复子串</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404142945657.png" alt="image-20220404142945657"></p>
<p>对于一个 i 位置的来说，有两个瓶颈</p>
<ol>
<li>i-1 位置的推出来的那个最长没有重复子串的长度</li>
<li>之前的根自己一样字符的位置 + 1 到自己的长度</li>
</ol>
<p>这两个哪个离当前 i 位置的元素最近，我们就用哪个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404144430258.png" alt="image-20220404144430258"></p>
<hr>
<h4 id="编辑距离"><a class="markdownIt-Anchor" href="#编辑距离">#</a> 编辑距离</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404144615554.png" alt="image-20220404144615554"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=27&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV13g41157hK?p=27&amp;spm_id_from=pageDriver</a>  1:38:00 处</p>
<hr>
<h4 id="删掉字符获得最小最小字典序的字符串"><a class="markdownIt-Anchor" href="#删掉字符获得最小最小字典序的字符串">#</a> 删掉字符获得最小最小字典序的字符串</h4>
<ul>
<li>创造每一个字符的词频表 (出现几次)</li>
<li>然后再遍历，每遍历一个都让对应字符词频 - 1, 直到有一个字符词频为 0</li>
<li>此时我们遍历过的这一块就代表我们这一块区域的右边不再有那个词频变成 0 的字符了，所以我们必须在这一块挑选一个字符才可以最后让每种字符都有</li>
<li>我们选这一块区域的最小词频的字符，然后让那个选中的字符的左边去掉，然后右边去重新每一个去找各自的词频</li>
<li>每一次挑选一个字符，之后把这些字符拼在一起就是答案</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=27&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV13g41157hK?p=27&amp;spm_id_from=pageDriver</a>  2:01:14 处</p>
<blockquote>
<p>复杂度 O (k*N),k 为不同字符的个数</p>
</blockquote>
<hr>
<h4 id="子序列"><a class="markdownIt-Anchor" href="#子序列">#</a> 子序列</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404162411317.png" alt="image-20220404162411317"></p>
<p>需要两个函数 g 和 f</p>
<ul>
<li>g 函数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404162744593.png" alt="image-20220404162744593"></p>
<ul>
<li>f 函数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404162930411.png" alt="image-20220404162930411"></p>
<hr>
<h4 id="排序后的相邻两数最大差值"><a class="markdownIt-Anchor" href="#排序后的相邻两数最大差值">#</a> 排序后的相邻两数最大差值</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404163740877.png" alt="image-20220404163740877"></p>
<ul>
<li>如果 n 个数我们就准备 n+1 个桶，堆数组里面的数字划分到每一个桶里面去</li>
<li>最左边和最右边的桶一定会有元素装着最小和最大的元素</li>
<li>我们肯定会有空桶，所以答案就是不同桶之间的最大值 - 最小值就是答案，不可能发生在一个桶里面</li>
<li>所以我们每个桶其实可以用数组存，两个数组分别存每个桶的最小值和每个桶的最大值，之后只要算每个桶的最小值 (除了第一个桶) 和他之前有数的桶的最大值里面最大的那个差值就是答案</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220404164753828.png" alt="image-20220404164753828"></p>
<blockquote>
<p>其实加的那个桶 (N+1 个桶，而不是 N 个桶是因为) 就是相当于加了个平凡解，加了这个就直接排除掉所有答案会在一个同一个桶内的可能性，从而排除掉很多不可能的可能性所以直接优化很多</p>
</blockquote>
<p><strong><mark>可能性的取舍</mark></strong></p>
<hr>
<h4 id="区分数组获取区间数字的xor都等于0"><a class="markdownIt-Anchor" href="#区分数组获取区间数字的xor都等于0">#</a> 区分数组获取区间数字的 xor 都等于 0</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220408195351169.png" alt="image-20220408195351169"></p>
<p>子数组问题，先想每个位置<strong>结尾</strong>的情况下怎么怎么样</p>
<p>我们看可以用 dp 数组，我们 dp [i] 代表 0 到 i 位置这一块最多能有几个区域 xor 为 0, 后面的都不管</p>
<p>从左到右，如果 i 位置</p>
<ul>
<li>不是最优划分的情况下属于异或为 0 的区域的最后一个元素，就比如说现在是 1234, 然后 i 位置的是 4, 那这个就不是，以为它本身就是自己 4, 本身不是异或为 0 的区域。这个情况的话，其实有这个元素没有这个元素都一样，直接取 dp [i-1] 的值就行了</li>
<li>是最优划分的情况下属于异或为 0 的区域的最后一个元素
<ul>
<li>使用一个 map 记录每一个前缀 xor 和以及对应的最近的下标，这个用来快速找到当前 i 位置作为一个区域的最后一个位置的这个区域的第一个下标</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们这里要使用假设答案法</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220421141059537.png" alt="image-20220421141059537"></p>
<hr>
<h4 id="m面值的硬币的拼成的方法"><a class="markdownIt-Anchor" href="#m面值的硬币的拼成的方法">#</a> m 面值的硬币的拼成的方法</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220409000820641.png" alt="image-20220409000820641"></p>
<ul>
<li>可以想象是两个数组一个数组是所有普通币另外一个纪念币，然后一个 m</li>
<li>比如说 m 是 10, 那么我们需要知道多少种方法让
<ul>
<li>普通币拼成 0 的方法总数，纪念币拼成 10 的方法总数，他们相乘</li>
<li>普通币拼成 1 的方法总数，纪念币拼成 9 的方法总数，他们相乘</li>
<li>普通币拼成 2 的方法总数，纪念币拼成 8 的方法总数，他们相乘</li>
<li>…</li>
<li>普通币拼成 10 的方法总数，纪念币拼成 0 的方法总数，他们相乘</li>
<li>最后把所有结果相加就是答案</li>
</ul>
</li>
</ul>
<blockquote>
<p>其实就是两个 dp 二维数组</p>
<p>第一个对于任意枚</p>
<ul>
<li>
<p>如果那个数组有三个元素，我们 m 是 10 的话，我们想要有一个 3x11 的二位数组</p>
</li>
<li>
<p><strong>dp [i][j] 代表从 0 到 i 在数组里面位置的元素随便用凑到这个 j 这个数</strong></p>
</li>
<li>
<p>一开始我们可以对于 dp [0/1/2][0] 都初始化为 1, 因为所有货币想要凑到 0 块钱就是不用当前货币就是 0 种方法</p>
</li>
<li>
<p>然后 dp [0][allcolumns] 可以做简单的数学填充好</p>
</li>
<li>
<p>之后下面的 rows 他的值是 <code>dp[i][j]=dp[i-1][j](当前i位置的币一个不用拼成j)+dp[i-1][j-arr[i]*k](当前i位置的币用k个(k&gt;=0,所以可能会是0,1,2,3,...)</code> , 剩下的值让 0 到 i-1 位置的处理，当然和这个 <code>j-arr[i]*k</code>  要 &gt;=0)</p>
</li>
<li>
<p>因为 k 可以是 0, 所以可以直接简化为:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429123446206.png" alt="image-20220429123446206"></p>
</li>
<li>
<p>当然别忘了，可以做优化！！！</p>
<p><strong>每次有枚举行为，我们可以通过观察看哪些地方有重复的，想办法取消重复的</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429124126292.png" alt="image-20220429124126292"></p>
</li>
</ul>
<p>第二个对于只能使用一枚的硬币更简单，压根没有枚举行为，直接用或者不用就行了</p>
</blockquote>
<p>用了这个两个 dp 表，用他们的最后一个 row 按照上面拼答案就可以了</p>
<hr>
<h4 id="两个数组找最大"><a class="markdownIt-Anchor" href="#两个数组找最大">#</a> 两个数组找最大</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429121914408.png" alt="image-20220429121914408"></p>
<blockquote>
<p><strong>这里老师再找第 k 小的数字</strong></p>
</blockquote>
<p>使用 binary search (不是最优解) (这个好像要是有重复数字就不对了)</p>
<ul>
<li>一个数组里面做二分，之后一个数，然后拿这个数去另外一个数组里面去找二分看对不对，如果不对接着做二分，然后再另外一个数组找…</li>
<li>如果上面没找到，就反过来，在另外一个数组做二分找一个数，然后去之前那个找…</li>
<li><code>logN*logM</code>  时间复杂度</li>
</ul>
<p>最优解</p>
<ul>
<li>首先要找到上中位数 (比如说数组长度为 8, 上中位数就是 3 位置的数)</li>
</ul>
<p>如果两个数组都是偶数个</p>
<p>​	那么如果 A 的上中位数 ==B 的上中位数，那么直接返回，那个就是他们在一起的上中位数</p>
<p>​	如果不等，那么就对于 这两个部分递归找各自的中上位数进行比较…</p>
<blockquote>
<p>子问题的上中位数就是总问题的上中位数</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429130253577.png" alt="image-20220429130253577"></p>
<p>如果都是奇数个</p>
<p>​	也是比较中上位数，如果一样直接返回</p>
<p>​	如果不一样:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429130800466.png" alt="image-20220429130800466"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=31&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV13g41157hK?p=31&amp;spm_id_from=pageDriver</a> 开头看之后的</p>
<hr>
<h4 id="摩天大楼"><a class="markdownIt-Anchor" href="#摩天大楼">#</a> 摩天大楼</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220429234401892.png" alt="image-20220429234401892"></p>
<p>无非就是把数据归整成一个对象，然后把他们放进两个有序表，一个有序表代表存着当前最高高度以及出现几次，另外一个表靠着刚才这个表来算出当前点以及他对应的最高位置是什么.</p>
<p>目的就是为了找出每一个点和他对应的此时最高高度是多少，有了这个之后</p>
<hr>
<h4 id="累加和为k的最长子数组长度"><a class="markdownIt-Anchor" href="#累加和为k的最长子数组长度">#</a> 累加和为 k 的最长子数组长度</h4>
<p>滑动窗口，L 和 R</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509145327834.png" alt="image-20220509145327834"></p>
<blockquote>
<p>其实就是单调性，看一个数组从哪个开头可以不用试</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509145829714.png" alt="image-20220509145829714"></p>
<p><strong>不过要是这个数组要是有 0 有负数怎么办？？？</strong></p>
<p>先遍历数组，弄一个前缀和数组，然后创建一个 map 保存前缀和与坐标，有相同前缀和只保存最前面那个。定义 max 保存长度，然后再遍历前缀和数组，每个前缀和元素减去 k，</p>
<p><strong>如果这个有正有 0 有负的的数组累加和小于或者等于 k 的最长数组长度怎么办？？？</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509150343554.png" alt="image-20220509150343554"></p>
<blockquote>
<p>这个需要我们之前说过的，可能性的取舍，把不可能的排除掉，(用桶的那个方式)</p>
</blockquote>
<p>两个数组，第一个数组代表从 i 位置到结尾所能形成的最小的累加和，另外一个数组对应着每一个 i 位置到结尾所能形成的最小的累加和结束的右边界。让我们相当于让数组变成很多很多的子数组，然后我们可以按照每一个子数组进行操作看看相加有没有大于 k, 没有就继续加直到加到超过了 k (更新答案).</p>
<blockquote>
<p>但是精髓还不是这里，这样我们任意形成 O (N<sup>2</sup>) 的解法，因为可能 0 位置开始一直扩扩扩，发现不行就要从 1 位置开始一直扩扩扩，… 是不是可以优化！！！我们可以使用窗口，窗口不回退，比如说 0 位置开始不对，我们可以一直保持一个 sum, 然后可以直接 sum-arr [0], 就相当于从 1 位置开始继续了，然后继续测之前测到的右边界后面的…</p>
</blockquote>
<p>这么做代表我们只关心我们可不可以让窗口边的更长，而不是当前位置开头到底对不对</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509153325769.png" alt="image-20220509153325769"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509153335934.png" alt="image-20220509153335934"></p>
<hr>
<h4 id="铜板问题"><a class="markdownIt-Anchor" href="#铜板问题">#</a> 铜板问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509155223438.png" alt="image-20220509155223438"></p>
<p>Nim 博弈问题</p>
<p>把所有数字异或起来，如果非 0 那么先手赢，如果是 0 后手赢</p>
<p>如果一开始异或不是 0, 那么先手就会每一步都让结果变成异或为 0 让后手操作，这样后手怎么拿都会让结果不再是 0, 那么就相当于是最后先手胜利</p>
<p>如果一开始异或是 0, 那么此时这个先手就相当于是之前的后手了</p>
<hr>
<h4 id="伪进制"><a class="markdownIt-Anchor" href="#伪进制">#</a> 伪进制</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509162242120.png" alt="image-20220509162242120"></p>
<p>使用 26__伪__进制可以解决问题</p>
<hr>
<h4 id="蛇蛇"><a class="markdownIt-Anchor" href="#蛇蛇">#</a> 蛇蛇</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509162943792.png" alt="image-20220509162943792"></p>
<p>就是尝试！！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509163500420.png" alt="image-20220509163500420"></p>
<blockquote>
<p>因为不一定是到头，而是每一个点都有可能，所以要在外层 double for</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509163839429.png" alt="image-20220509163839429"></p>
<p>然后在定义好那个方法就行，回调，把需要的信息组织好就行了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509164944699.png" alt="image-20220509164944699"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509165202953.png" alt="image-20220509165202953"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509165854276.png" alt="image-20220509165854276"></p>
<blockquote>
<p>很喜欢这种想法，我们只关心获取到，然后之后不停更新我们需要的数据，之后直接用就行，而不是担心获取然后用等等等</p>
</blockquote>
<p>改动态规划 (记忆法)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509172658829.png" alt="image-20220509172658829"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509172810406.png" alt="image-20220509172810406"></p>
<p>然后之后的…(省略掉，跟上面一样)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509172948669.png" alt="image-20220509172948669"></p>
<hr>
<h4 id="dp的空间压缩技巧"><a class="markdownIt-Anchor" href="#dp的空间压缩技巧">#</a> dp 的空间压缩技巧</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509180539230.png" alt="image-20220509180539230"></p>
<p>dp [i][j],i 是第一个字符串的所有字符，j 是第二个字符串的所有字符</p>
<p>dp [i][j] 代表第一个字符串 i 位置的字符结尾并且第二个字符串 j 位置的字符结尾情况下，最长的公共子串是多长，<strong> 并且这个最长公共子串也必须要以这个第一字符串的 i 位置的字符以及第二字符串的 j 位置的字符结尾</strong></p>
<p>可以直接算出:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220509181904997.png" alt="image-20220509181904997"></p>
<p>其他的相等的其实就是他左上角的值 + 1</p>
<p>(上方图有些细节是填错的)</p>
<blockquote>
<p>最后答案就是整张表的最大值</p>
</blockquote>
<p>但是真的需要表吗，其实用几个变量也可以达到同样的效果，这个表只存在脑海里，我们可以从左上角，一个一个算出来，每个点都依赖与他的左上角，同时记录出现过的最大值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513143100775.png" alt="image-20220513143100775"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513144823132.png" alt="image-20220513144823132"></p>
<hr>
<h4 id="两个字符串最长公共子序列"><a class="markdownIt-Anchor" href="#两个字符串最长公共子序列">#</a> 两个字符串最长公共子序列</h4>
<p>跟上面一样也是二维表，dp [i][j] 代表 str1 [0…i] 和 str2 [0…j] 的字符串最长子序列长度是多长，但是不一定要以 str [i] 和 str [j] 结尾的，所以跟上面这个点不一样</p>
<blockquote>
<p>所以答案就是右下角的值</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513150203060.png" alt="image-20220513150203060"></p>
<p>看所有公共子序列的<strong>最后个字符</strong>是谁</p>
<ul>
<li>不 i 不 j 结尾，那么有没有这个都一样，那么就跟 dp [i-1][j-1] 一样</li>
<li>不 i 以 j 结尾，那么有没有这个 i 都一样，那么就跟 dp [i-1][j] 一样</li>
<li>以 i 不 j 结尾，那么有没有这个 j 都一样，那么就跟 dp [i][j-1] 一样</li>
<li>以 i 不以结尾，那么有没有这个都一样，那么就跟 dp [i][j]+1 一样</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513150456787.png" alt="image-20220513150456787"></p>
<blockquote>
<p>这四个当中取最大值就是我们 dp [i][j] 的值</p>
<p><strong>注意第四种可能性只有在 str1 [i]==str2 [j] 这个情况成立之下才可以使用，如果不成立就不参与比较</strong></p>
</blockquote>
<hr>
<h4 id="坐船"><a class="markdownIt-Anchor" href="#坐船">#</a> 坐船</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513150825541.png" alt="image-20220513150825541"></p>
<p>双指针:</p>
<ul>
<li>
<p>先排序数组 arr</p>
</li>
<li>
<p>我们关注 limit/2, 比如说这个 lmit 是 10, 那么 / 2 的值是 5, 我们关心小于等于 5 的最右位置</p>
<ul>
<li>如果这个位置是 - 1, 那么代表有多少数我们就需要多少个船</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513151621730.png" alt=""></p>
<ul>
<li>如果位置是越界 (大于数组长度，那就代表 n/2 条，任意两个都可以乘坐一条船)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513151633898.png" alt="image-20220513151633898"></p>
</li>
<li>
<p>要是有这个位置，我们就相当有两个组，一个边是小于等于 5 的，一边是大于 5 的</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513151731587.png" alt="image-20220513151731587"></p>
<ul>
<li>
<p>接着我们看 l 位置的元素加上 R 位置的元素有没有超过 limit</p>
<ul>
<li>如果大于说明这个 5, 跟他后面哪个数都搞定不了，让 l 往左走，一直走到可以搞定为止</li>
<li>走到对的位置后，我们就让 R 往右走，一直走到合适的为止</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513152102743.png" alt="image-20220513152102743"></p>
<p>接着这个 3 代表我们可以搞定这边 R 扩展的元素，也就是两个，那个 3 自己往左数两个，跟这个两个 7 对应，这么做一定是最优分配–&gt; 这里有个贪心，我们不要让 L 继续往左走因为只会变小，这个 3 就是为了解决这两个 7 的最好方式，L 此时左边的数应该是给 R 右边更大的数字，而不是针对于现在 R 经过的这些可能还不是最大的这些数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513152211816.png" alt="image-20220513152211816"></p>
</li>
</ul>
<p>然后就继续同样让 L 往左 R 往右，看能不能搞定剩下的，注意只能搞定两边都有足够长度，不然不要继续扩升.</p>
<p>然后结束了就对于我们当初走的时候给的标记来决定答案:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513152648051.png" alt="image-20220513152648051"></p>
<p>公式:</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513153008967.png" alt="image-20220513153008967"></p>
<p>注意: b/2 是向上取整 --&gt;<strong> <code>可以(b+1)/2做到跟向上取证的效果</code> </strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513153933961.png" alt="image-20220513153933961"></p>
<hr>
<h4 id="最长回文子序列-范围上的尝试"><a class="markdownIt-Anchor" href="#最长回文子序列-范围上的尝试">#</a> 最长回文子序列 (范围上的尝试)</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513154950593.png" alt="image-20220513154950593"></p>
<p>我们想要知道 str [i 到 j] 的范围上最长回文子序列是多少，i 和 j 所以二维表 dp</p>
<p>dp [i][j] 就是 str [i 到 j] 的范围上最长回文子序列是多少</p>
<p>所以 dp [0][字符串长度 - 1] 就是我们想要的答案</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513155603520.png" alt="image-20220513155603520"></p>
<blockquote>
<p>注意左下半角的区域没有用，怎么可能左边界比有边界大</p>
</blockquote>
<p><strong> <code>范围尝试的数据,对角线x=y的数据是最好填写的</code> </strong></p>
<ul>
<li>在这里，全是 1, 就是自己一个字符，所以长度当然都是 1</li>
<li>接着填倒数第二条贴脚线，此时就只有两个字符，如果不相等那么就是 1, 如果相等就是 2</li>
</ul>
<p>上面两个相当于 base case, 其它的:</p>
<ul>
<li>想可能性
<ul>
<li>形成的最长子序列不以 i 开头，不以 j 结尾–&gt; 代表 dp [i][j]=dp [i+1][j-1](想做是一个范围内)</li>
<li>形成的最长子序列以 i 开头，不以 j 结尾–&gt; 代表 dp [i][j]=dp [i][j-1]</li>
<li>形成的最长子序列不以 i 开头，以 j 结尾–&gt; 代表 dp [i][j]=dp [i+1][j]</li>
<li>形成的最长子序列以 i 开头，以 j 结尾 (这个情况必须是 i 位置字符 ==j 位置字符才会有)–&gt; 代表 dp [i][j]=dp [i+1][j-1]+2 (+2 代表 i 和 j 两个字符也加进来了)</li>
</ul>
</li>
<li>所以我们这个顺序填表</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513161016254.png" alt="image-20220513161016254"></p>
<p>因为每个格子依靠他的左边，下边和左下边，所以我们先把已经能算出的那些算出来，然后这些会被之后的需要…</p>
<hr>
<h4 id="添加字符变成回文"><a class="markdownIt-Anchor" href="#添加字符变成回文">#</a> 添加字符变成回文</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513161216860.png" alt="image-20220513161216860"></p>
<p>范围上尝试的模型</p>
<blockquote>
<p>str [i 到 j] 的范围上最少添几个，才可以让这个范围的变成回文串</p>
</blockquote>
<p>三种可能性</p>
<ul>
<li>搞定 i+1 到 j 位置的字符，然后再加一个搞定 i 位置的字符，所以 dp [i+1][j]+1</li>
<li>搞定 i 到 j-1 位置的字符，然后再加一个搞定 j 位置的字符，所以 dp [i][j-1]+1</li>
<li>如果 i 位置的和 j 位置的字符一样，<strong> 只有在一样的情况下</strong>，就看 dp [i+1][j-1]</li>
</ul>
<p>然后 dp [i][j] 就是三种或者两种 (如果 i 位置不等于 j) 最小值</p>
<p>有了这个最后的值后，我们可以从那个右上角的答案出发去找源自于哪里，从而对我们的原来字符串做添加变成回文</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513171117757.png" alt="image-20220513171117757"></p>
<p>然后接着… 逆着倒回去看从哪里来的，决定到底该加哪个，然后最后到达对角线结束</p>
<blockquote>
<p>这张表记录着所有的解，我们可以走其他路就是另外一个解 (虽然不是对于这个问题是正确答案，但是结果也是个回文)</p>
<p><strong>还原路径，当初怎么决策出来的现在怎么还原出去，一定能够得到一个路径的解</strong></p>
</blockquote>
<hr>
<h4 id="切割成回文子串的最小分割数"><a class="markdownIt-Anchor" href="#切割成回文子串的最小分割数">#</a> 切割成回文子串的最小分割数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513172543129.png" alt="image-20220513172543129"></p>
<p>f (i) 代表 i 开始以及以后所有的，最少需要切割几次</p>
<ul>
<li>一开始是 0 位置
<ul>
<li>我们可以让第一个字符自己就是一个回文，然后调用 f (1)</li>
<li>我们可以让前两个字符 (必须是回文才可以), 然后调用 f (2)</li>
<li>…</li>
<li>我们可以让前 x 个字符 (必须是回文才可以), 然后调用 f (x)</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220513173158233.png" alt="image-20220513173158233"></p>
<blockquote>
<p>所以这里是只有可能这三个，这三个选个最小的就是答案</p>
</blockquote>
<hr>
<h4 id="无序数组中找最小第k个数"><a class="markdownIt-Anchor" href="#无序数组中找最小第k个数">#</a> 无序数组中找最小第 k 个数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514161630178.png" alt="image-20220514161630178"></p>
<p>可以荷兰问题递归</p>
<ul>
<li>就是 partition, 随机选个数，左边都是小于的数，然后中间等于这个数，右边都是大于这个数</li>
<li>然后靠下标看我们的此时有没有包括住第 k 小的数，如果没有就递归左边 / 右边</li>
<li>parition 本身就是 O (N) 复杂度，现在就是看递归是要多久</li>
<li>用 master 公式，因为是随机选一个数作为 partiiton, 这个算法考虑递归是 O (N)</li>
</ul>
<blockquote>
<p>如果不是随机选数，最差情况可能是 O (N<sup>2</sup>), 笔试这么解没问题</p>
</blockquote>
<p>但是可以有更好，不需要选随机数就可以达到 O (N) 复杂度的算法</p>
<h5 id="bfprt"><a class="markdownIt-Anchor" href="#bfprt">#</a> BFPRT</h5>
<ul>
<li>不是随机选个数，而是有讲究的选一个数 (<strong>跟上面方式的唯一区别</strong>)</li>
<li>用这个数做 partition</li>
<li>如果中间区域没有就看下标情况去递归左边或者右边</li>
</ul>
<p>怎么有讲究的选一个数？</p>
<ol>
<li>
<p>一开始无序数组按照下标分组，每五个分一组，剩下如果不够五个的也分一组</p>
</li>
<li>
<p>每一组选一个中位数，放进一个 Marray 数组里面 (O (N) 的时间复杂度)</p>
</li>
<li>
<p>求 Marray 数组的中位数 (不是 medium, 而是中间那个元素，如果比如说是 4 个元素那就是第二个元素)</p>
<p>怎么求？</p>
<p><strong>就是调用我们整个算法的本身，只不过用一个数，这个数是 Marray 数组长度 / 2 在 Marray 数组 parition 然后递归去找，找出来的肯定是中位数，这个中位数就是我们要很讲究选的数</strong></p>
</li>
</ol>
<p>这样就不需要用概率随机选一个数，平均下来才达到整个算法 O (N), 而是可以直接有讲究的选一个数达到严格的 O (N)</p>
<blockquote>
<p>所有组的中位数的中位数，能确保原数组里面肯定有一些数是大于这个数的，所以不可能会出现最差情况</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514164441114.png" alt="image-20220514164441114"></p>
<p>整体严格 O (N) 时间复杂度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514164522892.png" alt="image-20220514164522892"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514164548109.png" alt="image-20220514164548109"></p>
<hr>
<h4 id="裂开的方法数"><a class="markdownIt-Anchor" href="#裂开的方法数">#</a> 裂开的方法数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514164748279.png" alt="image-20220514164748279"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514165040361.png" alt="image-20220514165040361"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514165017981.png" alt="image-20220514165017981"></p>
<p>改 dp:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514171215213.png" alt="image-20220514171215213"></p>
<p>斜率优化:</p>
<blockquote>
<p>试试看周围的格子是依赖哪些得出来的，然后找规律，这么做可以省掉枚举行为 (就是那第三个 for loop, 也就是一个格子需要多个格子 (所以 for loop) 去找那些格子做些计算算出当前的)</p>
</blockquote>
<p>上方的就是 (优化后):</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514172616103.png" alt="image-20220514172616103"></p>
<hr>
<h4 id="符合搜索二叉树的最大拓扑结构"><a class="markdownIt-Anchor" href="#符合搜索二叉树的最大拓扑结构">#</a> 符合搜索二叉树的最大拓扑结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514172636574.png" alt="image-20220514172636574"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1W3411W7yi?p=47">https://www.bilibili.com/video/BV1W3411W7yi?p=47</a> [1:00:10 左右]</p>
<hr>
<h4 id="改变数组排序完美洗牌问题"><a class="markdownIt-Anchor" href="#改变数组排序完美洗牌问题">#</a> 改变数组排序 (完美洗牌问题)</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514181603757.png" alt="image-20220514181603757"></p>
<blockquote>
<p>我们想要 O (1) 空间复杂度解决这个问题那就必须需要完美洗牌问题 (<strong>时间复杂度 O (NlogN)</strong>)</p>
</blockquote>
<p>我们可以用下表算出一个元素应该在哪个位置</p>
<p>我们可以使用下标循环推，就是一开始元素获取到正确位置怼过去，原本在那个位置的存住然后继续哪个位置的算推到他对应的位置，… 直到推完</p>
<p><strong>但是有个问题</strong>，可能形成环，但是中间有元素没处理</p>
<p>比如说:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514184429340.png" alt="image-20220514184429340"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514184449205.png" alt="image-20220514184449205"></p>
<p>不一定是一个大环，而是有可能是多个小环，而且<strong>每个小环一定不相交</strong></p>
<p>我们应该想选哪些点可以把所有的下标都推到正确的位置上去</p>
<p>所以，有点奇怪，出发点计算:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514184949044.png" alt="image-20220514184949044"></p>
<ul>
<li>只有 n 是 2,8,26, 或者…(符合 3<sup>k</sup>-1) 的时候</li>
<li>触发点就是 1,3,9,…, 一直到 3<sup>k</sup>-1</li>
</ul>
<p>这样我们就有了所有下标出发点，我们所有这些位置都玩一下下标循环推，最终答案啊就是正确的</p>
<ul>
<li>如果这个数组长度 n 是偶数不符合 3<sup>k</sup>-1 的时候</li>
</ul>
<p>需要了解一个算法原型，就是如果一个数组想要一部分区域移到另外一个区域，比如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514185526617.png" alt="image-20220514185526617"></p>
<p>我们可以左右指针，给左区域逆序，给右区域逆序，然后整个再逆序，最终结果就是想要的:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514185614353.png" alt="image-20220514185614353"></p>
<blockquote>
<p>额外空间复杂度 O (1)</p>
</blockquote>
<p>然后接着说我们的问题，我们可以找当前这个长度跟哪个符合 3<sup>k</sup>-1 的数字，比如说我们 N=14</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514185855509.png" alt="image-20220514185855509"></p>
<p>最近 14 且符合 3<sup>k</sup>-1 的数字是 8</p>
<p>那么我们可以先处理这一部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514185926956.png" alt="image-20220514185926956"></p>
<p>怎么做到？其实就是我们所说的上面的那个算法模型:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514190229331.png" alt="image-20220514190229331"></p>
<p>然后上面那个长度为 8 的按照我们之前说的方式搞定之后我们就可以搞剩下的这部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514190306576.png" alt="image-20220514190306576"></p>
<p>我们接着找此时长度 6 最近且符合 3<sup>k</sup>-1 的数字，也就是 2, 然后我们接着做…, 直到所有处理完就完事</p>
<blockquote>
<p>因为我们 N 处理的是偶数张牌，所以肯定就是偶数，肯定会最后被拆分成多个 3<sup>k</sup>-1 的区域处理完</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514190544836.png" alt="image-20220514190544836"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220514190603784.png" alt="image-20220514190603784"></p>
<blockquote>
<p>有些变形仔细想想就知道了，比如说可能会有奇数长度，我们可以一开始把一个数留着不参与之后处理完再处理这个一开始的数等等等</p>
</blockquote>
<hr>
<h4 id="正则匹配"><a class="markdownIt-Anchor" href="#正则匹配">#</a> 正则匹配</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220516102106355.png" alt="image-20220516102106355"></p>
<blockquote>
<p>注意 * 是 * 前面的那个字符 (pattern) 可以在 str 那个位置出现 0 个，1 个，多个，…</p>
</blockquote>
<p>从左到右的尝试模型 f (str,exp,si,ei)</p>
<ul>
<li>str 原字符串</li>
<li>exp 原 pattern 字符串</li>
<li>str [si… 到往后所有] 能不能被 exp [ei… 到往后所有] 配出来</li>
</ul>
<p>所以是两个字符串都是从左往右尝试的模型，所以可以就是一个二维表</p>
<p>普通尝试:</p>
<p>可以分为两个大情况</p>
<ul>
<li>如果 ei+1 位置不是 *, 那么 ei 位置一定要跟 si 位置一样，或者 ei 位置是个.</li>
<li>如果 ei+1 位置是 *, 那当前这个位置就要试 0 个，1 个，等等等 (取决于能跟 str 匹配多少长度前缀) 看看哪个符合</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517003023856.png" alt="image-20220517003023856"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517003630355.png" alt="image-20220517003630355"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517003619344.png" alt="image-20220517003619344"></p>
<blockquote>
<p>注意这个如果 ei+1 位置是 *, 我们就需要 while loop 测，只要当前字符能匹配或者有可能性匹配 (考虑到之后的字符，因为有那个 *), 那么我们就继续，直到我们测到确实可以匹配返回 false, 不然一直测测到头 si==s.length 了，那就是不匹配，返回 false, 接着处理下一段，直接把当前字符以及后面的紧跟的 * 看做是 0 个字符</p>
</blockquote>
<blockquote>
<p>那个 while 循环里面就是不停试如果这个 e 的字符和 e+1 的 * 看做是 0 个那个字符，那么剩下的 (从 e+2) 位置开始，可不可以产出匹配成功的结果，如果不行，那就把这个 e 的字符和 e+1 的 * 看做是 1 个那个字符 (就是抵消掉了一个 s 里面的那个字符), 看看剩下的 (从 e+2) 位置开始能不能匹配…</p>
</blockquote>
<blockquote>
<p>si++ 就代表目前看来已经再次解决掉了一个那个字符，注意只有在 while 循环那个条件成立才可以，这个也有他妙处，想想 s 是 wasd 然后 e 是.*, 循环会一直进行直到 si==s.length, 然后最后 return 那里然后 base case, 然后 true 了，也就是我们 s 字符串每一个字符都被我们 while 一个一个抵消掉了</p>
</blockquote>
<p>动态规划</p>
<blockquote>
<p>这里遇到了一个问题，就是初始数据不足，无法推出其他的数</p>
</blockquote>
<p><strong>我们可以回到原题意，把该填的地方都填了，剩下的才按照递归改动态规划</strong></p>
<p>这里，一个任一个字按照我们递归可能依赖左下角格子，和此 col+2 的 col 的所有次 row 到结尾 row 的数据，<strong> 所以我们需要至少右边有两列，然后最后一行也都有数据，之后其他的就可以依赖彼此一个一个被填</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517012925581.png" alt="image-20220517012925581"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517013319382.png" alt="image-20220517013319382"></p>
<blockquote>
<p>注意 dp 表中任何一个地方，按照我们的递归想法，如过那个位置的 e 的字符是 *, 所以不需要考虑那个位置的 e 的字符是 * 的可能性，因为我们递归的想法是我们不考虑当前 ei 位置是 * 字符，注意那个 isValid 函数和 ei+2, 我们不关心</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517013801550.png" alt="image-20220517013801550"></p>
<p>就算 dp 表需要会到那些东西，我们递归如果不考虑的话，那就不用担心，因为不会被依赖 (用到)</p>
</blockquote>
<p>这段填初始值的操作 https://www.bilibili.com/video/BV13g41157hK?p=37 [53:00 左右], 很细节</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517015247413.png" alt="image-20220517015247413"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517015329793.png" alt="image-20220517015329793"></p>
<hr>
<h4 id="子数组的最大异或和"><a class="markdownIt-Anchor" href="#子数组的最大异或和">#</a> 子数组的最大异或和</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220517015421474.png" alt="image-20220517015421474"></p>
<ul>
<li>暴力 (O (N<sup>3</sup>))-&gt; 三个 nested for 循环</li>
<li>稍微好一点 (数学加预处理)(O (N<sup>2</sup>)):</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518135617384.png" alt="image-20220518135617384"></p>
<ul>
<li>前缀树加贪心 (最优)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=37">https://www.bilibili.com/video/BV13g41157hK?p=37</a> [1:30:00 左右]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518142931661.png" alt="image-20220518142931661"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518143000387.png" alt="image-20220518143000387"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518143218804.png" alt="image-20220518143218804"></p>
<hr>
<h4 id="打爆气球"><a class="markdownIt-Anchor" href="#打爆气球">#</a> 打爆气球</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518143438321.png" alt="image-20220518143438321"></p>
<ul>
<li>这里就是不停尝试，看看哪个适合，我们尝试哪个气球先打爆，但是这样会很麻烦 (使用范围上尝试的模型), 因为需要很多参数，非常耗空间</li>
<li>我们改为了哪个气球最后被打爆这种尝试 -&gt;f (L,R),<strong> 潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆</strong> (这个就是潜台词，大问题定的，小问题遵守，这样可变参数可变少)</li>
</ul>
<p>比如说参数就是</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518145042760.png" alt="image-20220518145042760"></p>
<p>比如说我们选择 f (1,6)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518145102421.png" alt="image-20220518145102421"></p>
<p>我们尝试每个位置的气球最后打爆:</p>
<ul>
<li>
<p>1 位置的气球最后爆，调用 f (2,6)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆)</p>
<p>所以结果就是分数就是 f (2,6)+1*3*1, 因为我们选择当前 1 位置的气球最后打爆</p>
</li>
<li>
<p>6 位置的气球最后爆，调用 f (1,5)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆)</p>
<p>所以结果就是分数就是 f (1,5)+1*2*1, 因为我们选择当前 6 位置的气球最后打爆</p>
</li>
<li>
<p>2 位置的气球最后爆，调用 f (1,1) 和 f (3,6)(这个完全可以，以为满足了潜台词，潜台词就是 L-1 位置的气球一定没有爆，R+1 位置的气球一定没爆，这两个调用都符合)</p>
<p>所以结果就是分数就是 f (1,1)+f (3,6)+1*2*1, 因为我们选择当前 2 位置的气球最后打爆</p>
</li>
</ul>
<p>…(其他的都可以)</p>
<blockquote>
<p>气球最后爆的尝试方式就需要两个可变参数</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518150527082.png" alt="image-20220518150527082"></p>
<p>改 dp:</p>
<p>使用记忆法，这个经过测试发现无法斜率优化提升，所以记忆优化就行了</p>
<hr>
<h4 id="汉诺塔变形问题"><a class="markdownIt-Anchor" href="#汉诺塔变形问题">#</a> 汉诺塔变形问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518154543857.png" alt="image-20220518154543857"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=37">https://www.bilibili.com/video/BV13g41157hK?p=37</a> [2:10:00 左右]</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518175549130.png" alt="image-20220518175549130"></p>
<p>迭代方式:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518175805732.png" alt="image-20220518175805732"></p>
<hr>
<h4 id="分解字符串"><a class="markdownIt-Anchor" href="#分解字符串">#</a> 分解字符串</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220518143618010.png" alt="image-20220518143618010"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=38">https://www.bilibili.com/video/BV13g41157hK?p=38</a> 一开始</p>
<hr>
<h4 id="包含字符串的最短子串"><a class="markdownIt-Anchor" href="#包含字符串的最短子串">#</a> 包含字符串的最短子串</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519004255960.png" alt="image-20220519004255960"></p>
<p>滑动窗口</p>
<ul>
<li>欠债表，一开始记录缺哪些，有可能负数代表我们窗口有更多那个字符</li>
<li>all 变量，存着总共还欠几个</li>
<li>长度，每次达标更新这个变量</li>
</ul>
<p>如果欠债表出现有一些是 0, 有一些是负数，需要左边往右走，直到都是 0, 算是得到了一个符合的窗口，更新答案，右边继续扩</p>
<hr>
<h4 id="lfu"><a class="markdownIt-Anchor" href="#lfu">#</a> LFU</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519163749174.png" alt="image-20220519163749174"></p>
<p><strong>二维双向链表结构才能解决</strong></p>
<ul>
<li>我们有个桶，每个桶存那个词频出现的数据，比如说 A 出现一次我们把 A 和他的 value 包装成一个节点放进桶里面，之后要有其他节点也是词频 1 次，我们也存进去，只不过此时是双向链表结构</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519164657535.png" alt="image-20220519164657535"></p>
<blockquote>
<p>这个桶记录着当前存着的双向链表的头和尾</p>
</blockquote>
<ul>
<li>我们还有个 map,key 比如说可以是 “A”,value 是那个 A 和他的 value 包装成的节点，我们可以获取到那个节点，然后获取到真正的 value (<em>* 这种用 map 让你 value 指向其他的结构中的存在的地址等这种操作很重要的！！！</em>*)</li>
</ul>
<blockquote>
<p>比如上面我们可以用这个 map 找 B 的节点，hence 他的 value. 而不是需要去遍历那个双向链表</p>
</blockquote>
<p>这么做之后要是有比如说词频为 2 的，我们需要给那个建个桶，然后让这个桶跟我们的第一个桶本身之前双向链表连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519164954398.png" alt="image-20220519164954398"></p>
<blockquote>
<p>每个桶是双向链表结构，每个桶里面的节点也是双向链表结构.</p>
<p><strong>这么做的好处就是每次操作就是 O (1) 的，我们可以通过 map 快速获取到一个节点，然后检查当前有没有比他本身原来词频数大 1 的桶来装此时操作完的这个节点，如果没有就新建，如果有就加进去那里面的双向链表，还有如果当前存在的桶没有节点了，那就销毁。这些操作都是 O (1) 的</strong></p>
</blockquote>
<blockquote>
<p>如果想要总共存满了，想要 add 新的数据，那么需要替换掉词频最小的，要是词频都一样的话那就替换时间最早的. <strong>这不就是让当前头桶的_头_节点去除掉，然后把当前加的节点放进正确地方去吗</strong></p>
</blockquote>
<hr>
<h4 id="加油站"><a class="markdownIt-Anchor" href="#加油站">#</a> 加油站</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519165857311.png" alt="image-20220519165857311"></p>
<ul>
<li>首先把油数组减去距离数组，获取每一个点出发，自己的油减去距离下一站的距离到了那个站之后剩下的多少油，这个数组叫做纯能数组</li>
<li>这么做我们就可以把问题变成沿途累加和是否小于 0</li>
</ul>
<p>比如说我们获取到了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519170632415.png" alt="image-20220519170632415"></p>
<p>此时我们可以比如说</p>
<ul>
<li>0 号位置出发，一开始就是 - 1, 所以不可能</li>
<li>1 号位置出发，一开始就是 1, 到下一站 - 2, 去和的结果变成 - 1, 所以不可能</li>
<li>2 号位置出发，一开始就是 - 2, 所以不可能</li>
<li>3 号位置出发，一开始 2, 下一站 3, 下一站 2, 下一站 3, 下一站 1 回到了出发点，所以可以，这个为 true</li>
<li>4 号位置出发，一开始 1, 下一站 0, 下一站 1, 下一站 - 1, 所以不可能</li>
</ul>
<p>但是我们这么做每个节点都尝试出发，那就是 O (N<sup>2</sup>) 方法，如何做到 O (N)?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519171405623.png" alt="image-20220519171405623"></p>
<blockquote>
<p>一开始选一个可能成功的点出发 (所以必不能是负数，如果都是负数那就都不可能直接返回), 例子选择 H 作为出发点</p>
</blockquote>
<ul>
<li>联通区代表，左闭右开，一开始是 [H,I), 左闭右开是因为一开始此时 H 只能到得了 H (还没走 yet)</li>
<li>rest 表示通过了联通区后，我们还剩多少油</li>
<li>need 代表如果当前的节点要接到联通区的头上，需要至少多少油，现在一开始我们就在 H 所以我们并不需要就等于 0</li>
</ul>
<p>接着我们尝试往逆时针方向扩，此时和为 5-4=1, 可以扩，所以我们此时</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519172131980.png" alt="image-20220519172131980"></p>
<p>此时再扩发现不行了，1-2=-1, 是负数，所以 H 不是良好的出发点，我们需要来到 H 的逆时针方向，也就是 G 点，我们尝试让他变成联通区存的头，因为 G 点是 2, 所以 need 还是 0 (只要那个变成头的节点存的不是负数那么 need 就是 0),rest 值也变了，此时就变成了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519172701742.png" alt="image-20220519172701742"></p>
<blockquote>
<p>注意原本区域结尾什么的都还没变，我们还没扩到 A, 左闭右开！</p>
</blockquote>
<p>接着我们尝试尾巴让下扩，发现 ok,rest 还是正数</p>
<p>就各种扩等等等… 直到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519172857461.png" alt="image-20220519172857461"></p>
<p>此时尝试扩 C 发现不行就知道 G 不是良好出发点，我们需要再次让头部变成左边的，也就是 F 点.</p>
<p>但是 F 不满足接到联通区头部的要求，因为他是负数，直接标记 F 为不良好出发点，然后<strong> need 变成 2!!!</strong></p>
<p>这个代表以后的节点想接到联通区的头部要求增加了，以为他要连 F, 然后 F 是 - 2, 你新头部需要承担 F 的这个负的代价，继续往左边扩，发现 E 也是 - 1, 不符合，标记不良好，然后 need 变成 - 3, 继续… 来到 D,D 满足要求，此时 need3-3=0,rest 保持不变因为 D 已经把他那个 3 给支付掉了作为 F 和 E 的代价，所以无法给到尾部用来扩。此时头部更新好了，尾部继续扩…</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519173404098.png" alt="image-20220519173404098"></p>
<blockquote>
<p>这个例子中哦我们最后头来到了 D 然后尾尝试扩到 C 但是失败，我们扩头也会碰到 C, 这个情况的话，就不需要再继续验了，C 和 B 和 A 和 I 肯定都是不良好的出发节点</p>
</blockquote>
<p>证明:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1W3411W7yi?p=50">https://www.bilibili.com/video/BV1W3411W7yi?p=50</a> [18:00 左右]</p>
<p>上面例子是都是不良好出发点，另外一个例子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519174236976.png" alt="image-20220519174236976"></p>
<blockquote>
<p>这个例子我们发现 H 是良好出发点，可以转一圈</p>
</blockquote>
<p>我们接着就用他结束之后剩下的哪个 need 的值 (因为 H 是转了一圈的，良好出发点，所以 need 应该是 0), 我们接着就忘他左边去看，能不能接上那个 H 的头，只要他能接上头，那么那个也是个良好的出发点，最后联通区就是 [H,H)</p>
<p><strong>不用关心尾了，只要能接上头就是良好出发点，能接上头到哪里都行</strong></p>
<ul>
<li>G 是 - 1, 不行，need 变成 1</li>
<li>F 导致 need 变成 0, 可以</li>
<li>E 导致 need 变成 - 1, 不可以</li>
<li>D 导致 need 变成 - 2, 不可以</li>
<li>C 导致 need 变成 0, 可以</li>
<li>B 导致 need 变成 - 4, 不可以</li>
<li>A 导致 need 变成 - 1, 不可以</li>
</ul>
<blockquote>
<p>当然要是这期间遇上之前我们一开始再找良好出发点的时候已经被标记为不良好出发点那就不用管了，直接设置完事</p>
</blockquote>
<p>所以这个只是转了这个圈一圈，必然是 O (N)</p>
<p><strong>有点像窗口</strong></p>
<hr>
<h4 id="抽烟矩阵"><a class="markdownIt-Anchor" href="#抽烟矩阵">#</a> 抽烟矩阵</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519175431611.png" alt=""></p>
<h5 id="首先需要了解线段问题"><a class="markdownIt-Anchor" href="#首先需要了解线段问题">#</a> 首先需要了解线段问题</h5>
<ul>
<li>把开始位置排序</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519180220681.png" alt="image-20220519180220681"></p>
<ul>
<li>接着把数据放入有序表，<strong> 有序表按照结尾排序</strong>！！！
<ul>
<li>首先是 1 到 9, 需要把有序表所有小于或者等于 1 的数字丢出去 (没有扔，因为没有数), 然后放入 9,<strong> 此时有序表有一个数</strong>，就是处理 1 到 9 这个线段的答案，也就是 1</li>
<li>然后是 2 到 5, 需要把有序表所有小于或者等于 2 的数字丢出去 (没有扔，因为就一个 9), 然后放入 5,<strong> 此时有序表有两个数</strong>，就是处理 2 到 5 这个线段的答案，也就是 2</li>
<li>然后是 2 到 4, 需要把有序表所有小于或者等于 2 的数字丢出去 (没有扔，因为 9,5 都比 2 大), 然后放入 4,<strong> 此时有序表有三个数</strong>，就是处理 2 到 4 这个线段的答案，也就是 3</li>
<li>然后是 3 到 10, 需要把有序表所有小于或者等于 3 的数字丢出去 (没有扔，因为 9,5,4 都比 3 大), 然后放入 10,<strong> 此时有序表有四个数</strong>，就是处理 3 到 10 这个线段的答案，也就是 4 (<strong>最终答案</strong>)</li>
<li>然后是 6 到 8, 需要把有序表所有小于或者等于 6 的数字丢出去 (扔掉了 4 和 5), 然后放入 8,<strong> 此时有序表有三个数</strong>，就是处理 6 到 8 这个线段的答案，也就是 3</li>
</ul>
</li>
</ul>
<p>每个线段都有一个答案，最大的答案就是我们需要的答案</p>
<p>每个线段的答案的含义是我们重合区域必须以那个线段开头 (比如说 1 到 10 就是必须以 1 开头) 开头的情况下，我们目前处理完了的这些线段来说，最多盖几块</p>
<blockquote>
<p>如果有 N 个线段，处理每一个线段代价 O (logN)&lt;- 有序表的增删改查</p>
<p>所以解法总共是 O (NlogN)</p>
</blockquote>
<h5 id="矩阵问题继续解答"><a class="markdownIt-Anchor" href="#矩阵问题继续解答">#</a> 矩阵问题继续解答</h5>
<p>任何重叠的区域一定是某一个矩形的底</p>
<ul>
<li>所以我们可以首先把所有矩形按照矩形底边排序</li>
<li>先处理在最下面的矩形，往上一个一个处理</li>
<li>我们记录所有在当前矩形底部的一整个横线上</li>
<li>然后对于其他所有加的矩阵我们首先需要看谁的上边还没比到我们当前要加的低边高的矩阵，我们要把他们把那些从容器中都移出</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519182856618.png" alt="image-20220519182856618"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519182929664.png" alt="image-20220519182929664"></p>
<blockquote>
<p>这样对于每一个矩阵我们知道一共有多少个矩阵上面比当前矩阵底部高且比底部当前矩阵底部底</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220519183448781.png" alt="image-20220519183448781"></p>
<p>然后我们可以取出那些矩阵的 x 宽度，这些宽度相当于就是一个个线段，这样矩阵的问题被我们变成了一维线段问题，调用上面我们说的那个算法原型 (<strong>线段问题</strong>), 最后答案就出来了</p>
<hr>
<h3 id="技巧"><a class="markdownIt-Anchor" href="#技巧">#</a> 技巧</h3>
<ul>
<li>
<p>再有序数组中找最 (左 / 右) 位置的大于等于的可以用二分查找</p>
</li>
<li>
<p><strong>打表法</strong>：如果输入输出都是 int, 可以直接弄一个很傻的结局方法然后接着拿很多个输入参数来测，打印每一个的输出，接着看输出看有什么规律，直接按照规律写代码 (并不是所有的整数型题目都这样)</p>
</li>
<li>
<p><strong>预处理</strong>：研究代码，看哪一块是频繁的，比如说对于数组中每一个元素都要往前 O (N) 遍历找到什么什么信息什么的。完全可先遍历等等等用多余的数据结构 (<strong>可以是多个</strong>) 存下相关的信息，之后需要信息，<strong> 就不需要重复</strong>的进行那个可<strong>能会很耗时的操作</strong>，而是直接靠下标获取对应的想要的值就行了</p>
</li>
</ul>
<blockquote>
<p>注意这个装信息的数据结构，在填信息的时候尽量要如何快速地填信息，参考_矩阵最大正方形边长边框_问题的优化做法，多考虑，别什么都想遍历</p>
</blockquote>
<ul>
<li>
<p>注意开始，结束位置，该怎么走，往那边走 (遍历) 啥的</p>
</li>
<li>
<p>多想想如果怎么怎么样，等等等列出各种可能性</p>
</li>
<li>
<p>如果数量太多，先想对于一个来说怎么怎么样，列出各种可能性等等等</p>
</li>
<li>
<p>多考虑，遍历的时候可以算出当前位置左边有多少个位置，右边有多少位置的，不过要是想要知道当前位置左边所有的元素的加 (比方说) 或者当前位置右边所有的元素的加，我们就需要边遍历边拿一个变量存着！注意遍历方向等等。别想太复杂，能用变量存着就别想什么数组，只有那个信息是一个或几个变量很难存下的时候我们才用数组什么的</p>
</li>
<li>
<p>矩阵–&gt; 有时候想办法把外面一圈给搞定，再搞定里面的一圈，接着搞定那个的里面的一圈，so on… 直到错位或者…</p>
<blockquote>
<p>矩阵有时候不要局部想这一个怎么走怎么走，然后这个走几步那里走几步等等等，这很麻烦！！！</p>
<p>要想得整体一点点，可以把它分成一圈包着一圈，或者一条斜线跟着一条斜线，等等等 (<strong>具体看需求</strong>), 在这基础上我们还可以接着做分组然后各种操作啊等等等，反正当我们对于当前这一圈 / 一条斜线 (<strong>具体看需求</strong>) 做完操作了，我们接着处理下一圈 / 下一跳斜线，如果还有的合法的话</p>
</blockquote>
</li>
<li>
<p>Arrays.binarySearch (…) 和 Collections.binarySearch (…)</p>
</li>
</ul>
<p>如果查找的 value 包含在数组中，则返回搜索 value 的索引；否则返回 (-(<strong>插入点</strong>) - 1)。插入点 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，<strong>如果数组中的所有元素都小于指定的键，则为 a.length</strong>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。</p>
<p>即是，有可能返回的是 (负) 插入点的</p>
<blockquote>
<p>反正就是你<strong>确定</strong>当前数在<strong>有序</strong>数组中都比他大的，那么你就可以用这个找到那个<strong>第一个比他大的</strong>，这个返回的是个负数比如说 x, 然后 <code>-x-1</code>  才是那个第一个比你那个数大的那个数的下标。注意如果数组有你要找的数，那么肯定返回的就是你这个数在数组中的下标.</p>
</blockquote>
<ul>
<li>tail recursion–&gt; 就是你边回调自己边把这一层的结果传下去，最后到了最后一层我们这个最终结果他也有直接返回，然后会一层层返回回去，注意我们之前上面的那些层我们并没有存任何变量等等等我们只是 <code>return 自己(...,本层的结果);</code>  而不是像什么 <code>return 自己本层某种变量 +/-/*/...等等等操作  自己(...,本层的结果);</code> <strong> 所以这么做很省空间，O (1) 的空间</strong>！</li>
<li>大根堆小根堆，各有各的妙处，有时候可能用其中一个很明显，但说不定来外一个也可以 (依靠你检查大小不超过什么什么数等), 这么做我们还可以知道当前进堆最大门槛 / 最小门槛等等等，说不定还可以省空间，只用你规定的空间</li>
<li>所以有时候问你问题是需要只用队列 / 栈做什么什么事情，而正常做法应该是用栈 / 队列，我们可以考虑用两个栈实现队列或者两个队列实现栈，然后做相对应操作</li>
<li>多个区域，想一想哪个位置是必须包括的，包括了那些位置之后还需要包括其他的吗还是没有必要或者不符合我们的要求等</li>
<li>动态规划，如果不确定要定多大的空间，想需要空间最多的情况需要多少，要实在想不出来，直接就用很大很大一个空间可能也行，但是不好，因为浪费空间</li>
<li>树型 dp 时间复杂度就是 O (N), 这是如果我们那个套路每一层的常数操作</li>
<li>子数组最大的和的值</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/HarryQu1229/image-host/main/notes-img/image-20220403225713682.png" alt=""></p>
<blockquote>
<p>如果有多个子数组都有一样的和，那么这个就是针对于最长的那个子数组而取到的 max (其实都一样)</p>
</blockquote>
<p>这个就是假设答案法，就是你过一下然后想一下要用什么方式存下，然后去实现</p>
<blockquote>
<p>-&gt; 假设答案 -&gt; 分析答案性质 -&gt; 设置流程就能找到答案了</p>
</blockquote>
<ul>
<li>子矩阵问题先想子数组怎么办的，子数组问题解决了，就想办法尝试把子矩阵问题压缩成子数组问题</li>
<li>构建单调性，可以省略掉复杂度，比如说省掉枚举行为</li>
<li><strong>递归有时候不停，我们可以先找平凡解，然后 basecase 用那个平凡解作为限制来确保递归可以最终退出</strong></li>
<li>看到子数组或者子串的问题，先想每个位置<strong>结尾</strong>的情况下怎么怎么样</li>
<li>dp 范围上尝试，<strong> <code>范围尝试的数据,对角线x=y的数据是最好填写的</code> </strong>，然后一般范围上尝试的模型注意开头和结尾！！！<span class="spoiler" title="..."><span class="spoiler" title="..."><span class="spoiler" title="..."> 一般都靠开头和结尾怎么样去决定的，想可能性</span></span></span>！</li>
</ul>
<p><strong>范围上尝试就是在看 dp [i][j] 的所有 (i (开不) 开头 j (结不) 结尾) 的可能性分类下，能不能把整个域的问题给解决，这是最关键的，如果不行那就还尝试从左到右模型</strong></p>
<p>所以继续从左往右模型再加一个，从左往右模型就是从左到右 i 位置的要或者不要</p>
<blockquote>
<p>如果不清楚就挨个试试，可能性分类就是唯一一个 dp 里面需要动脑子的点</p>
</blockquote>
<ul>
<li>有时候改 dp, 你递归 base case 不明显或者…, 总之你 dp 表发现一个格子依赖这些格子，但是我们没有足够初始数据格子让其他格子挨个挨个依赖填好，所以我们需要回到题意，手动给那些最基本，最需要的那些格子给上值，这样我们就可以接着回到递归按照递归改 dp</li>
<li>这点适用于 followup 上面那点 (我们需要手动给 dp 初始值): 就算 dp 表需要会到那些东西，我们递归如果不考虑的话，那就不用担心那种可能性，因为不会被依赖 (用到),dp 表每个格子只是承载了，如果递归调用那个位置 (比如说二维 dp, 可变参数 i 和 j, 给到了我们原本递归函数), 我们可以得到什么结果，就是用这两个可变参数此时那个位置的值去调用递归函数的返回值 (或者…)!!!</li>
<li>递归定义很多潜台词，是为了之后分为小问题后，可以不用那么多的参数，小问题也需要严格遵守那些规则，否则递归可变参数太多了，很麻烦</li>
<li>很多二维的图形问题都需要转换成一维<strong>线段</strong>问题解决的</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Harry Qu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://harryqu1229.github.io/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/">https://harryqu1229.github.io/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/fundamental/">fundamental</a><a class="post-meta__tags" href="/tags/summary/">summary</a><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a><a class="post-meta__tags" href="/tags/data-structure/">data structure</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-621848f44e1c3724" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Design Patterns</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/25/nodejs/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/town.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Nodejs notes</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/02/23/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="Algorithm and Data Structure notes summary"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/car.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Algorithm and Data Structure notes summary</div></div></a></div><div><a href="/2022/02/23/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95/" title="Frontend Algorithm and Data Structure"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/house.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Frontend Algorithm and Data Structure</div></div></a></div><div><a href="/2022/02/25/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/" title="Algorithm and Data Structure interview summary notes"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/forest.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-25</div><div class="title">Algorithm and Data Structure interview summary notes</div></div></a></div><div><a href="/2022/02/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98js%E7%89%88%E6%9C%AC/" title="Frontend ByteDance Algorithm and Data Structure(javascript)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-27</div><div class="title">Frontend ByteDance Algorithm and Data Structure(javascript)</div></div></a></div><div><a href="/2022/02/25/%E7%AE%97%E6%B3%95%20-%20%E5%85%B6%E5%AE%83/" title="Algorithm and Data Structure - Other"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/car.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-25</div><div class="title">Algorithm and Data Structure - Other</div></div></a></div><div><a href="/2022/02/23/%E7%AE%97%E6%B3%95%20-%20%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="Algorithm and Data Structure - Disjoint-set data structure"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/code.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Algorithm and Data Structure - Disjoint-set data structure</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Disqus</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Harry Qu</div><div class="author-info__description">Software Engineering Student</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">158</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">57</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HarryQu1229"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.linkedin.com/in/harry-qu-a0a38220a" target="_blank" title="LinkedIn"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://github.com/HarryQu1229" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Harryqu666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="weixin://dl/chat?harry666ya" target="_blank" title="Wechat"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">be healthy, stay safe</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.</span> <span class="toc-text"> 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%A8%A1%E7%89%88"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 遍历模版</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.1.1.</span> <span class="toc-text"> 二叉树非递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text"> 中序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text"> 前序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F"><span class="toc-number">2.1.1.1.3.</span> <span class="toc-text"> 后序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">2.1.1.2.</span> <span class="toc-text"> 层次遍历非递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%A8%A1%E7%89%88"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 递归模版</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A5%97%E8%B7%AF%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.3.1.</span> <span class="toc-text"> 递归套路步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.2.</span> <span class="toc-text"> 图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE-2"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 边：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%94%9F%E6%88%90%E5%99%A8%E6%8E%A5%E5%8F%A3%E8%BF%99%E4%B8%AA%E8%A6%81%E6%8C%89%E9%9C%80%E6%B1%82%E4%BB%A5%E5%8F%8A%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%A5%E6%94%B9%E5%8F%98"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 图生成器 (接口，这个要按需求以及输入的来改变)：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 对数器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E9%9A%8F%E6%9C%BA%E7%9A%84%E6%95%B0%E7%BB%84%E5%8F%AF%E8%83%BD%E4%B8%BA%E6%AD%A3%E4%B9%9F%E5%8F%AF%E8%83%BD%E4%B8%BA%E8%B4%9F0"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 1）产生一个长度随机的数组（可能为正，也可能为负，0）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%9D%E5%AF%B9%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 2）绝对正确的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A4%A7%E6%A0%B7%E6%9C%AC%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 3）大样本测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.4.</span> <span class="toc-text"> 回溯模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#subsets"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Subsets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subsets-ii-contains-duplicates"><span class="toc-number">2.4.2.</span> <span class="toc-text"> Subsets II (contains duplicates)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permutations"><span class="toc-number">2.4.3.</span> <span class="toc-text"> Permutations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permutations-ii-contains-duplicates"><span class="toc-number">2.4.4.</span> <span class="toc-text"> Permutations II (contains duplicates)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#combination-sum"><span class="toc-number">2.4.5.</span> <span class="toc-text"> Combination Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#combination-sum-ii-cant-reuse-same-element"><span class="toc-number">2.4.6.</span> <span class="toc-text"> Combination Sum II (can’t reuse same element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#palindrome-partitioning"><span class="toc-number">2.4.7.</span> <span class="toc-text"> Palindrome Partitioning</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95"><span class="toc-number">2.5.</span> <span class="toc-text"> 代码随想录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 二分查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.5.2.</span> <span class="toc-text"> KMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-number">2.5.4.</span> <span class="toc-text"> 深度优先遍历（递归）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%AD%E5%B7%A6%E5%8F%B3"><span class="toc-number">2.5.4.1.</span> <span class="toc-text"> 前序遍历（中左右）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%B7%A6%E4%B8%AD%E5%8F%B3"><span class="toc-number">2.5.4.2.</span> <span class="toc-text"> 中序遍历（左中右）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%B7%A6%E5%8F%B3%E4%B8%AD"><span class="toc-number">2.5.4.3.</span> <span class="toc-text"> 后序遍历（左右中）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-4"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 深度优先遍历（迭代法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%B7%A6%E4%B8%AD%E5%8F%B3-2"><span class="toc-number">2.5.5.1.</span> <span class="toc-text"> 中序遍历（左中右）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%B7%A6%E5%8F%B3%E4%B8%AD-2"><span class="toc-number">2.5.5.2.</span> <span class="toc-text"> 后序遍历（左右中）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-5"><span class="toc-number">2.5.6.</span> <span class="toc-text"> 广度优先遍历（队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-6"><span class="toc-number">2.5.7.</span> <span class="toc-text"> 二叉树深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-7"><span class="toc-number">2.5.8.</span> <span class="toc-text"> 二叉树节点数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-8"><span class="toc-number">2.5.9.</span> <span class="toc-text"> 回溯算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-9"><span class="toc-number">2.5.10.</span> <span class="toc-text"> 并查集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text"> 个人看法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-number">3.0.1.</span> <span class="toc-text"> 第一题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="toc-number">3.0.2.</span> <span class="toc-text"> 第二题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC387-first-unique-character-in-a-string"><span class="toc-number">3.0.3.</span> <span class="toc-text"> 第 387. First Unique Character in a String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC91-decode-ways"><span class="toc-number">3.0.4.</span> <span class="toc-text"> 第 91. Decode Ways</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC881-boats-to-save-people"><span class="toc-number">3.0.5.</span> <span class="toc-text"> 第 881. Boats to Save People</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC300-longest-increasing-subsequence"><span class="toc-number">3.0.6.</span> <span class="toc-text"> 第 300. Longest Increasing Subsequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC94-binary-tree-inorder-traversal"><span class="toc-number">3.0.7.</span> <span class="toc-text"> 第 94. Binary Tree Inorder Traversal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC1663-smallest-string-with-a-given-numeric-value"><span class="toc-number">3.0.8.</span> <span class="toc-text"> 第 1663. Smallest String With A Given Numeric Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC22-generate-parentheses"><span class="toc-number">3.0.9.</span> <span class="toc-text"> 第 22. Generate Parentheses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC283-move-zeroes"><span class="toc-number">3.0.10.</span> <span class="toc-text"> 第 283. Move Zeroes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC844-backspace-string-compare"><span class="toc-number">3.0.11.</span> <span class="toc-text"> 第 844. Backspace String Compare</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC209-minimum-size-subarray-sum"><span class="toc-number">3.0.12.</span> <span class="toc-text"> 第 209. Minimum Size Subarray Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC904-fruit-into-baskets"><span class="toc-number">3.0.13.</span> <span class="toc-text"> 第 904. Fruit Into Baskets</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%BE"><span class="toc-number">4.</span> <span class="toc-text"> 算法课</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-number">4.1.</span> <span class="toc-text"> 异或</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E6%8D%A2%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 异或换值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E7%AE%97%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 异或算一个不一样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E7%AE%97%E4%B8%A4%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 异或算两个不一样的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text"> 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.5.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.6.</span> <span class="toc-text"> 堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.7.</span> <span class="toc-text"> 桶排序、计数排序、基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.8.</span> <span class="toc-text"> 排序总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">4.3.</span> <span class="toc-text"> 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 二分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text"> 一些数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%92%8Cjava%E7%9A%84priority-queue"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 优先级队列和 java 的 Priority Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8hashmaphashset"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 哈希表 (hashMap,hashSet)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.</span> <span class="toc-text"> 二叉树以及各种 (先中后序) 递归，非递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%BA%8F"><span class="toc-number">4.4.5.1.</span> <span class="toc-text"> 递归序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.2.</span> <span class="toc-text"> 非递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.2.1.</span> <span class="toc-text"> 前序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.2.2.</span> <span class="toc-text"> 后序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.2.3.</span> <span class="toc-text"> 中序遍历</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.3.</span> <span class="toc-text"> 二叉树的深度优先遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.5.4.</span> <span class="toc-text"> 二叉树的宽度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE-3"><span class="toc-number">4.4.6.</span> <span class="toc-text"> 图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.6.1.</span> <span class="toc-text"> 图的宽度优先遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.6.2.</span> <span class="toc-text"> 图的广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">4.4.7.</span> <span class="toc-text"> 前缀树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#master%E5%85%AC%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text"> Master 公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%AD%89%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text"> 排序，数组等问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 找出数组范围最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 小和问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E9%98%9F%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.3.</span> <span class="toc-text"> 逆序队问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.4.</span> <span class="toc-text"> 荷兰国旗问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%80%E4%B8%AA%E5%87%A0%E4%B9%8E%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.6.5.</span> <span class="toc-text"> 排序一个几乎有序的数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E5%92%8Cjava%E5%BA%95%E5%B1%82%E7%9A%84%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">4.7.</span> <span class="toc-text"> 比较器和 java 底层的排序操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text"> 链表问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%85%B1%E5%90%8C%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">4.8.1.</span> <span class="toc-text"> 找出两个有序链表共同值的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.2.</span> <span class="toc-text"> 两个链表是否有回文结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.8.3.</span> <span class="toc-text"> 逆序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E5%B7%A6%E8%BE%B9%E5%B0%8F%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.8.4.</span> <span class="toc-text"> 单链表按某值划分左边小，中间相等，右边大的形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">4.8.5.</span> <span class="toc-text"> 复制含有随机指针的链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%A6%82%E6%9E%9C%E6%9C%89%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E5%85%A5%E7%8E%AF%E7%82%B9"><span class="toc-number">4.8.6.</span> <span class="toc-text"> 一个链表是否有环，如果有怎么找到入环点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">4.8.7.</span> <span class="toc-text"> 两个单链表相交</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%A4%E6%9D%A1%E9%93%BE%E8%A1%A8%E9%83%BD%E6%97%A0%E7%8E%AF"><span class="toc-number">4.8.7.1.</span> <span class="toc-text"> 如果两条链表都无环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E6%9D%A1%E9%93%BE%E8%A1%A8%E6%97%A0%E7%8E%AF%E4%B8%80%E6%9D%A1%E8%8A%82%E7%82%B9%E6%97%A0%E7%8E%AF"><span class="toc-number">4.8.7.2.</span> <span class="toc-text"> 如果一条链表无环一条节点无环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%83%BD%E6%9C%89%E7%8E%AF"><span class="toc-number">4.8.7.3.</span> <span class="toc-text"> 两个都有环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%BB%99%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9%E5%8F%AA%E7%BB%99%E6%83%B3%E8%A6%81%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E5%B0%B1%E8%83%BD%E5%81%9A%E5%88%B0%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%8A%E6%8A%8A%E8%BF%99%E4%B8%AA%E7%82%B9%E5%88%A0%E6%8E%89"><span class="toc-number">4.8.8.</span> <span class="toc-text"> 能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">4.9.</span> <span class="toc-text"> 二叉树问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-number">4.9.1.</span> <span class="toc-text"> 求一个二叉树的最大宽度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.9.2.</span> <span class="toc-text"> 如何判断一颗二叉树是否是搜索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.9.3.</span> <span class="toc-text"> 如何判断一颗二叉树是否是完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.9.4.</span> <span class="toc-text"> 如何判断一颗二叉树是否是满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8F%8A%E6%A0%91%E5%9E%8Bdp%E5%A5%97%E8%B7%AF%E4%BB%8B%E7%BB%8D%EF%B8%8F%E9%87%8D%E8%A6%81"><span class="toc-number">4.9.5.</span> <span class="toc-text"> 如何判断一颗二叉树是否是平衡二叉树 (以及树型 dp 套路介绍⭐️重要！！！)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E7%90%86%E7%9C%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%A5%97%E8%B7%AF%E9%80%92%E5%BD%92"><span class="toc-number">4.9.5.1.</span> <span class="toc-text"> 同理看是不是搜索二叉树还是使用同一个套路 (递归)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E7%90%86%E7%9C%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%A5%97%E8%B7%AF"><span class="toc-number">4.9.5.2.</span> <span class="toc-text"> 同理看是不是满二叉树还是使用同一个套路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E5%9E%8Bdp%E5%A5%97%E8%B7%AF"><span class="toc-number">4.9.5.3.</span> <span class="toc-text"> 树型 dp 套路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8Bdp%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-number">4.9.6.</span> <span class="toc-text"> 树型 dp 题之二叉树节点间最大距离问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%9E%8Bdp%E9%A2%98%E4%B9%8B%E6%8E%92%E9%98%9F%E6%9C%80%E5%A4%A7%E5%BF%AB%E4%B9%90%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">4.9.7.</span> <span class="toc-text"> 树型 dp 题之排队最大快乐值问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">4.9.8.</span> <span class="toc-text"> 两个二叉树的最低公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E7%9F%AD%E4%BD%86%E6%98%AF%E5%BE%88%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.9.8.1.</span> <span class="toc-text"> 更短，但是很难理解的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">4.9.9.</span> <span class="toc-text"> 二叉树找一个节点的后继节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.9.10.</span> <span class="toc-text"> 二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%B9%E5%87%B8%E6%8A%98%E7%97%95"><span class="toc-number">4.9.11.</span> <span class="toc-text"> 凹凸折痕</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86"><span class="toc-number">4.10.</span> <span class="toc-text"> 二叉树的 Morris 遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.10.1.</span> <span class="toc-text"> 先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">4.10.2.</span> <span class="toc-text"> 中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">4.10.3.</span> <span class="toc-text"> 后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.10.4.</span> <span class="toc-text"> 判断是否为二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6"><span class="toc-number">4.10.5.</span> <span class="toc-text"> 求二叉树最小高度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E9%97%AE%E9%A2%98"><span class="toc-number">4.11.</span> <span class="toc-text"> 图问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95topological-sort"><span class="toc-number">4.11.1.</span> <span class="toc-text"> 括扑排序算法 (topological sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9Bterminologies"><span class="toc-number">4.11.2.</span> <span class="toc-text"> 最小生成树以及相关算法 (和一些 terminologies)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#terminologies"><span class="toc-number">4.11.2.1.</span> <span class="toc-text"> Terminologies</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#definitions-graph-vertices-edges"><span class="toc-number">4.11.2.2.</span> <span class="toc-text"> Definitions: Graph, Vertices, Edges</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#motivation"><span class="toc-number">4.11.2.3.</span> <span class="toc-text"> Motivation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#graph-classifications"><span class="toc-number">4.11.2.4.</span> <span class="toc-text"> Graph Classifications</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kinds-of-graphs-weighted-and-unweighted"><span class="toc-number">4.11.2.5.</span> <span class="toc-text"> Kinds of Graphs: Weighted and Unweighted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kinds-of-graphs-directed-and-undirected"><span class="toc-number">4.11.2.6.</span> <span class="toc-text"> Kinds of Graphs: Directed and Undirected</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undirected-graphs"><span class="toc-number">4.11.2.7.</span> <span class="toc-text"> Undirected Graphs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#directed-graphs"><span class="toc-number">4.11.2.8.</span> <span class="toc-text"> Directed Graphs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#subgraph"><span class="toc-number">4.11.2.9.</span> <span class="toc-text"> Subgraph</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#degree-of-a-node"><span class="toc-number">4.11.2.10.</span> <span class="toc-text"> Degree of a Node</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#graphs-terminology-involving-paths"><span class="toc-number">4.11.2.11.</span> <span class="toc-text"> Graphs: Terminology Involving Paths</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cyclic-and-acyclic-graphs"><span class="toc-number">4.11.2.12.</span> <span class="toc-text"> Cyclic and Acyclic Graphs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connected-and-unconnected-graphs-and-connected-components"><span class="toc-number">4.11.2.13.</span> <span class="toc-text"> Connected and Unconnected Graphs and Connected Components</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#trees-and-minimum-spanning-trees"><span class="toc-number">4.11.2.14.</span> <span class="toc-text"> Trees and Minimum Spanning Trees</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#data-structures-for-representing-graphs"><span class="toc-number">4.11.2.15.</span> <span class="toc-text"> Data Structures for Representing Graphs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#adjacency-list-representation"><span class="toc-number">4.11.2.16.</span> <span class="toc-text"> Adjacency List Representation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#adjacency-matrix-representation"><span class="toc-number">4.11.2.17.</span> <span class="toc-text"> Adjacency Matrix Representation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95k%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%E8%A6%81%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BEundirected-graphgraph"><span class="toc-number">4.11.3.</span> <span class="toc-text"> kruskal 算法（K 算法） 适用范围：要求无向图 (undirected graph&#x2F;graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95p%E7%AE%97%E6%B3%95%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%E8%A6%81%E6%B1%82%E6%97%A0%E5%90%91%E5%9B%BEundirected-graphgraph"><span class="toc-number">4.11.4.</span> <span class="toc-text"> Prim 算法（P 算法）适用范围：要求无向图 (undirected graph&#x2F;graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.5.</span> <span class="toc-text"> 迪杰斯特拉算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.</span> <span class="toc-text"> 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AE%AE%E9%97%AE%E9%A2%98"><span class="toc-number">4.12.1.</span> <span class="toc-text"> 会议问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A5%97%E8%B7%AF"><span class="toc-number">4.12.2.</span> <span class="toc-text"> 贪心题目笔试中套路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E5%BA%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">4.12.3.</span> <span class="toc-text"> 字典序例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E6%9D%A1%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%A0%91"><span class="toc-number">4.12.4.</span> <span class="toc-text"> 金条 (贪心) 问题–&gt; 哈夫曼编码树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%88%A9%E6%B6%A6"><span class="toc-number">4.12.5.</span> <span class="toc-text"> 项目利润</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%BE%97%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.12.6.</span> <span class="toc-text"> 取得中位数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">4.13.</span> <span class="toc-text"> 暴力递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#n%E7%9A%87%E5%90%8E"><span class="toc-number">4.13.1.</span> <span class="toc-text"> N 皇后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">4.13.2.</span> <span class="toc-text"> 汉诺塔问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%90%E5%BA%8F%E5%88%97subsets%E5%8C%85%E6%8B%AC%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.13.3.</span> <span class="toc-text"> 打印一个字符串的全部子序列 (subsets)，包括空字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%90%E5%BA%8F%E5%88%97%E8%A6%81%E6%B1%82%E4%B8%8D%E8%A6%81%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%8D%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.13.4.</span> <span class="toc-text"> 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E6%8E%92%E5%88%97"><span class="toc-number">4.13.5.</span> <span class="toc-text"> 打印一个字符串的全部排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E6%8E%92%E5%88%97%E8%A6%81%E6%B1%82%E4%B8%8D%E8%A6%81%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">4.13.6.</span> <span class="toc-text"> 打印一个字符串的全部排列，要求不要出现重复的排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B8%E7%89%8C"><span class="toc-number">4.13.7.</span> <span class="toc-text"> 纸牌</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E6%A0%88"><span class="toc-number">4.13.8.</span> <span class="toc-text"> 逆序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E5%BA%94"><span class="toc-number">4.13.9.</span> <span class="toc-text"> 数字与字符串对应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E9%87%8D%E9%87%8F%E5%92%8C%E4%BB%B7%E5%80%BC"><span class="toc-number">4.13.10.</span> <span class="toc-text"> 物体重量和价值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">4.14.</span> <span class="toc-text"> 哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.14.1.</span> <span class="toc-text"> 设计一个数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E9%97%AE%E9%A2%98%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.15.</span> <span class="toc-text"> 岛问题和并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-number">4.15.1.</span> <span class="toc-text"> 岛问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.15.2.</span> <span class="toc-text"> 并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.15.2.1.</span> <span class="toc-text"> 路径压缩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E5%86%B3%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-number">4.15.3.</span> <span class="toc-text"> 使用并查集解决岛问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp"><span class="toc-number">4.16.</span> <span class="toc-text"> KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#manacher%E7%AE%97%E6%B3%95"><span class="toc-number">4.17.</span> <span class="toc-text"> Manacher 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98"><span class="toc-number">4.17.1.</span> <span class="toc-text"> 原始问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%A6%82%E5%BF%B5"><span class="toc-number">4.17.2.</span> <span class="toc-text"> 补充概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.17.3.</span> <span class="toc-text"> 【步骤】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81"><span class="toc-number">4.17.4.</span> <span class="toc-text"> 实际代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">4.18.</span> <span class="toc-text"> 滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.18.1.</span> <span class="toc-text"> 解决问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">4.19.</span> <span class="toc-text"> 单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">4.20.</span> <span class="toc-text"> 大数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.20.1.</span> <span class="toc-text"> 布隆过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">4.20.2.</span> <span class="toc-text"> 一致性哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%85%B7%E4%BD%93%E8%BF%98%E6%98%AF%E7%9C%8B%E8%A7%86%E9%A2%91"><span class="toc-number">4.20.3.</span> <span class="toc-text"> 大数据 (具体还是看视频)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%98%E7%9B%AE"><span class="toc-number">4.20.4.</span> <span class="toc-text"> URL 大数据题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">4.21.</span> <span class="toc-text"> 位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E6%9C%89%E7%AC%A6%E5%8F%B732%E4%BD%8D%E6%95%B4%E6%95%B0a%E5%92%8Cb%E8%BF%94%E5%9B%9Ea%E5%92%8Cb%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84"><span class="toc-number">4.21.1.</span> <span class="toc-text"> 1. 给定两个有符号 32 位整数 a 和 b，返回 a 和 b 中较大的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%99%E5%AE%9A32%E4%BD%8D%E6%AD%A3%E6%95%B0%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF2%E7%9A%84%E5%B9%82%E6%98%AF%E5%90%A6%E6%98%AF4%E7%9A%84%E5%B9%82"><span class="toc-number">4.21.2.</span> <span class="toc-text"> 2. 给定 32 位正数，判断是否是 2 的幂，是否是 4 的幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-number">4.21.3.</span> <span class="toc-text"> 3. 加减乘除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.22.</span> <span class="toc-text"> 暴力递归到动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96"><span class="toc-number">4.22.1.</span> <span class="toc-text"> 什么暴力递归可以继续优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.22.2.</span> <span class="toc-text"> 暴力递归和动态规划的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.22.3.</span> <span class="toc-text"> 面试题和动态规划的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%9F%90%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E5%BC%8F"><span class="toc-number">4.22.4.</span> <span class="toc-text"> 如何找到某个问题的动态规划方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">4.22.5.</span> <span class="toc-text"> 面试中设计暴力递归过程的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E5%B0%9D%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.22.6.</span> <span class="toc-text"> 常见的 4 种尝试模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.23.</span> <span class="toc-text"> 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.23.1.</span> <span class="toc-text"> 机器人走路问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%A2%E9%92%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%A7%E5%B8%81%E6%95%B0%E9%87%8F"><span class="toc-number">4.23.2.</span> <span class="toc-text"> 换钱的最小货币数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E8%81%AA%E6%98%8E%E4%BA%BA%E6%8B%BF%E7%89%8C%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.23.3.</span> <span class="toc-text"> 两个聪明人拿牌问题递归到动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-2"><span class="toc-number">4.23.3.1.</span> <span class="toc-text"> 暴力递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E8%A7%84"><span class="toc-number">4.23.3.2.</span> <span class="toc-text"> 动规</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%AC%E8%B5%B0%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98"><span class="toc-number">4.23.4.</span> <span class="toc-text"> 马走棋盘问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-3"><span class="toc-number">4.23.4.1.</span> <span class="toc-text"> 暴力递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.23.4.2.</span> <span class="toc-text"> 改动态规划</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bob%E6%B4%BB%E7%9D%80"><span class="toc-number">4.23.5.</span> <span class="toc-text"> bob 活着</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BF%E9%92%9E%E7%A5%A8%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.23.6.</span> <span class="toc-text"> 拿钞票问题递归到动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">4.24.</span> <span class="toc-text"> 有序表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#balancing-search-tree"><span class="toc-number">4.24.1.</span> <span class="toc-text"> Balancing Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.24.1.1.</span> <span class="toc-text"> 平衡二叉树 &#x2F; AVL 树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%80%A7"><span class="toc-number">4.24.1.1.1.</span> <span class="toc-text"> 平衡性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91avl%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-sbt%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.24.1.2.</span> <span class="toc-text"> 典型搜索二叉树 ——AVL 树、红黑树、SBT 树的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#avl%E6%A0%91"><span class="toc-number">4.24.1.2.1.</span> <span class="toc-text"> AVL 树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">4.24.1.2.2.</span> <span class="toc-text"> 红黑树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sbt%E6%A0%91"><span class="toc-number">4.24.1.2.3.</span> <span class="toc-text"> SBT 树</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%8B%E8%BD%ACrebalance"><span class="toc-number">4.24.1.3.</span> <span class="toc-text"> 旋转 ——Rebalance</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%B8%AD%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.24.1.4.</span> <span class="toc-text"> Java 中红黑树的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">4.24.1.5.</span> <span class="toc-text"> 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#the-skyline-problem"><span class="toc-number">4.24.1.5.1.</span> <span class="toc-text"> The Skyline Problem</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">4.24.1.6.</span> <span class="toc-text"> 跳表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">4.24.1.6.1.</span> <span class="toc-text"> 添加数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="toc-number">4.24.1.6.2.</span> <span class="toc-text"> 查找数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">4.24.1.6.3.</span> <span class="toc-text"> 删除数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE"><span class="toc-number">4.24.1.6.4.</span> <span class="toc-text"> 遍历数据</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%8A%80%E5%B7%A7"><span class="toc-number">5.</span> <span class="toc-text"> 刷题以及技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B3%E5%AD%90%E8%A6%86%E7%9B%96"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 绳子覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E8%99%8E%E4%B9%B0%E8%8B%B9%E6%9E%9C"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 小虎买苹果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%82%E6%AC%A1%E6%96%B9%E5%90%83%E8%8D%89"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 幂次方吃草</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%9B%E7%89%9B%E9%A2%9C%E6%96%99"><span class="toc-number">5.1.4.</span> <span class="toc-text"> 牛牛颜料</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E8%BE%B9%E9%95%BF%E8%BE%B9%E6%A1%86"><span class="toc-number">5.1.5.</span> <span class="toc-text"> 矩阵最大正方形边长边框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%AD%89%E6%A6%82%E7%8E%87%E5%AE%9E%E7%8E%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E7%AD%89%E6%A6%82%E7%8E%87"><span class="toc-number">5.1.6.</span> <span class="toc-text"> 利用等概率实现另外一个等概率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.7.</span> <span class="toc-text"> 形成多少个二叉树结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.8.</span> <span class="toc-text"> 完整括号字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%95%B0%E5%AD%97%E5%AF%B9"><span class="toc-number">5.1.9.</span> <span class="toc-text"> 去重数字对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#magic%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.10.</span> <span class="toc-text"> magic 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.1.11.</span> <span class="toc-text"> 合法括号序列的深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%90%E4%B8%B2"><span class="toc-number">5.1.12.</span> <span class="toc-text"> 最长合法括号子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A0%88%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.13.</span> <span class="toc-text"> 将一个栈里面的数据排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%9C%80%E5%A4%A7%E6%9D%83%E5%80%BC"><span class="toc-number">5.1.14.</span> <span class="toc-text"> 根节点到叶节点最大权值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#matrix%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">5.1.15.</span> <span class="toc-text"> matrix 查找元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#matrix%E6%89%BE%E5%88%B0%E5%90%AB%E6%9C%89%E6%9C%80%E5%A4%9A1%E7%9A%84%E9%82%A3%E4%B8%80%E8%A1%8C"><span class="toc-number">5.1.16.</span> <span class="toc-text"> matrix 找到含有最多 1 的那一行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%9C%BA%E5%99%A8%E6%B4%97%E8%A1%A3%E6%9C%BA%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.17.</span> <span class="toc-text"> 打包机器 (洗衣机问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zigzag%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">5.1.18.</span> <span class="toc-text"> zigzag 打印矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">5.1.19.</span> <span class="toc-text"> 螺旋打印矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E9%A1%BA%E6%97%B6%E9%92%88%E8%BD%AC%E5%8A%A890%E5%BA%A6"><span class="toc-number">5.1.20.</span> <span class="toc-text"> 矩阵中顺时针转动 90 度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5sm"><span class="toc-number">5.1.21.</span> <span class="toc-text"> 拼接 sm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8Dk%E4%B8%AA"><span class="toc-number">5.1.22.</span> <span class="toc-text"> 字符串数组找出现最多的前 k 个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%9A%84%E7%BB%93%E6%9E%84%E9%9A%8F%E6%97%B6%E7%BB%B4%E6%8C%81%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8Dk%E4%B8%AA"><span class="toc-number">5.1.23.</span> <span class="toc-text"> 如何创建一个动态的结构，随时维持次数最多的前 k 个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">5.1.24.</span> <span class="toc-text"> 栈最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.25.</span> <span class="toc-text"> 用队列实现栈结构以及用栈实现队列结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.1.25.1.</span> <span class="toc-text"> 用栈实现队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">5.1.25.2.</span> <span class="toc-text"> 队列实现栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7"><span class="toc-number">5.1.26.</span> <span class="toc-text"> 动态规划的空间压缩技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E6%B0%B4"><span class="toc-number">5.1.27.</span> <span class="toc-text"> 装水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%8D%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%9A%84%E5%B7%A6%E5%8F%B3%E9%83%A8%E5%88%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%B7%AE%E5%80%BC"><span class="toc-number">5.1.28.</span> <span class="toc-text"> 砍数组，最大的左右部分的最大值的差值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.29.</span> <span class="toc-text"> 旋转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%96%E5%95%A1%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.30.</span> <span class="toc-text"> 咖啡问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%B9%98%E4%B8%BA4"><span class="toc-number">5.1.31.</span> <span class="toc-text"> 相乘为 4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%BC%8F%E4%BB%8Eon%E7%AE%80%E5%8C%96%E6%88%90ologn%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.32.</span> <span class="toc-text"> 递归式从 O (N) 简化成 O (logn) 的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3"><span class="toc-number">5.1.32.1.</span> <span class="toc-text"> 斐波那契数列快速幂解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer-10-i-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">5.1.32.1.1.</span> <span class="toc-text"> 剑指 Offer 10- I. 斐波那契数列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BF%86"><span class="toc-number">5.1.32.1.2.</span> <span class="toc-text"> 值得记忆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">5.1.33.</span> <span class="toc-text"> 背包问题的变种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%9B%E7%89%9B%E6%89%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">5.1.34.</span> <span class="toc-text"> 牛牛找工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%90%88%E4%BA%BA%E4%BB%AC%E6%97%A5%E5%B8%B8%E4%B9%A6%E5%86%99"><span class="toc-number">5.1.35.</span> <span class="toc-text"> 符合人们日常书写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA"><span class="toc-number">5.1.36.</span> <span class="toc-text"> 目录显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">5.1.37.</span> <span class="toc-text"> 二叉树变成双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">5.1.38.</span> <span class="toc-text"> 在一个二叉树中找最大搜索二叉树的节点个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF%E5%92%8C%E6%89%93%E5%88%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.39.</span> <span class="toc-text"> 招聘信息和打分系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C"><span class="toc-number">5.1.40.</span> <span class="toc-text"> 整形矩阵的子矩阵最大累加和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%81%AF%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.41.</span> <span class="toc-text"> 路灯问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%95%B0%E7%BB%84%E6%89%BE%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.42.</span> <span class="toc-text"> 二叉树前序数组和中序数组找后序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%89%93%E5%8D%B0%E5%87%BA%E6%88%90%E4%B8%AD%E6%96%87%E7%9A%84%E6%A0%B7%E5%AD%90"><span class="toc-number">5.1.43.</span> <span class="toc-text"> 数字打印出成中文的样子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">5.1.44.</span> <span class="toc-text"> 完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.1.45.</span> <span class="toc-text"> 最长递增的子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E5%99%A8%E7%9A%84%E6%95%B0%E5%88%97"><span class="toc-number">5.1.46.</span> <span class="toc-text"> 神器的数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%88%B01-n%E6%9C%AA%E5%87%BA%E7%8E%B0%E6%95%B4%E6%95%B0"><span class="toc-number">5.1.47.</span> <span class="toc-text"> 找到 1-n 未出现整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%9F%E8%B1%AA%E5%A5%B3%E4%B8%BB%E6%92%AD"><span class="toc-number">5.1.48.</span> <span class="toc-text"> 土豪女主播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cc%E7%9B%B4%E6%92%AD%E8%BF%90%E8%90%A5"><span class="toc-number">5.1.49.</span> <span class="toc-text"> CC 直播运营</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%86%B3%E5%AE%9A%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">5.1.50.</span> <span class="toc-text"> 逻辑决定布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">5.1.51.</span> <span class="toc-text"> 最长不重复子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.1.52.</span> <span class="toc-text"> 编辑距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E6%8E%89%E5%AD%97%E7%AC%A6%E8%8E%B7%E5%BE%97%E6%9C%80%E5%B0%8F%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.53.</span> <span class="toc-text"> 删掉字符获得最小最小字典序的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.1.54.</span> <span class="toc-text"> 子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">5.1.55.</span> <span class="toc-text"> 排序后的相邻两数最大差值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E8%8E%B7%E5%8F%96%E5%8C%BA%E9%97%B4%E6%95%B0%E5%AD%97%E7%9A%84xor%E9%83%BD%E7%AD%89%E4%BA%8E0"><span class="toc-number">5.1.56.</span> <span class="toc-text"> 区分数组获取区间数字的 xor 都等于 0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%E9%9D%A2%E5%80%BC%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%8B%BC%E6%88%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.57.</span> <span class="toc-text"> m 面值的硬币的拼成的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%89%BE%E6%9C%80%E5%A4%A7"><span class="toc-number">5.1.58.</span> <span class="toc-text"> 两个数组找最大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC"><span class="toc-number">5.1.59.</span> <span class="toc-text"> 摩天大楼</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">5.1.60.</span> <span class="toc-text"> 累加和为 k 的最长子数组长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%9C%E6%9D%BF%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.61.</span> <span class="toc-text"> 铜板问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E8%BF%9B%E5%88%B6"><span class="toc-number">5.1.62.</span> <span class="toc-text"> 伪进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9B%87%E8%9B%87"><span class="toc-number">5.1.63.</span> <span class="toc-text"> 蛇蛇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dp%E7%9A%84%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7"><span class="toc-number">5.1.64.</span> <span class="toc-text"> dp 的空间压缩技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.1.65.</span> <span class="toc-text"> 两个字符串最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E8%88%B9"><span class="toc-number">5.1.66.</span> <span class="toc-text"> 坐船</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-%E8%8C%83%E5%9B%B4%E4%B8%8A%E7%9A%84%E5%B0%9D%E8%AF%95"><span class="toc-number">5.1.67.</span> <span class="toc-text"> 最长回文子序列 (范围上的尝试)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6%E5%8F%98%E6%88%90%E5%9B%9E%E6%96%87"><span class="toc-number">5.1.68.</span> <span class="toc-text"> 添加字符变成回文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E6%88%90%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E5%89%B2%E6%95%B0"><span class="toc-number">5.1.69.</span> <span class="toc-text"> 切割成回文子串的最小分割数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E6%9C%80%E5%B0%8F%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="toc-number">5.1.70.</span> <span class="toc-text"> 无序数组中找最小第 k 个数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bfprt"><span class="toc-number">5.1.70.1.</span> <span class="toc-text"> BFPRT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%82%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">5.1.71.</span> <span class="toc-text"> 裂开的方法数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%90%88%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.72.</span> <span class="toc-text"> 符合搜索二叉树的最大拓扑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.73.</span> <span class="toc-text"> 改变数组排序 (完美洗牌问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">5.1.74.</span> <span class="toc-text"> 正则匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">5.1.75.</span> <span class="toc-text"> 子数组的最大异或和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">5.1.76.</span> <span class="toc-text"> 打爆气球</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.77.</span> <span class="toc-text"> 汉诺塔变形问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.78.</span> <span class="toc-text"> 分解字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2"><span class="toc-number">5.1.79.</span> <span class="toc-text"> 包含字符串的最短子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lfu"><span class="toc-number">5.1.80.</span> <span class="toc-text"> LFU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">5.1.81.</span> <span class="toc-text"> 加油站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E7%83%9F%E7%9F%A9%E9%98%B5"><span class="toc-number">5.1.82.</span> <span class="toc-text"> 抽烟矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%BA%BF%E6%AE%B5%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.82.1.</span> <span class="toc-text"> 首先需要了解线段问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98%E7%BB%A7%E7%BB%AD%E8%A7%A3%E7%AD%94"><span class="toc-number">5.1.82.2.</span> <span class="toc-text"> 矩阵问题继续解答</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-number">5.2.</span> <span class="toc-text"> 技巧</span></a></li></ol></li></ol></div></div><div class="card-widget card-map"><div class="card-content"><div class="item-headline"><i class="fa fa-globe-asia" aria-hidden="true"></i><span>Visitor Map</span></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=4LA950xi3DtQgUHPlkO0mo-n_QgrcOu-1BIiVpExg7k"></script></div></div><div class="card-widget card-pixiv"><div class="card-content"><div class="item-headline"><i class="fa fa-image" aria-hidden="true"></i><span>Pixiv Top50</span><iframe src="https://cloud.mokeyjay.com/pixiv" frameborder="0" style="width:99%;height:380px;margin:0;"></iframe></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/Maven/" title="My Maven notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/hello-world.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My Maven notes"/></a><div class="content"><a class="title" href="/2022/07/28/Maven/" title="My Maven notes">My Maven notes</a><time datetime="2022-07-27T12:00:00.000Z" title="Created 2022-07-28 00:00:00">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/nodejs/" title="Nodejs notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/town.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nodejs notes"/></a><div class="content"><a class="title" href="/2022/07/25/nodejs/" title="Nodejs notes">Nodejs notes</a><time datetime="2022-07-24T12:00:00.000Z" title="Created 2022-07-25 00:00:00">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" title="My ultimate data structure and algorithm guide"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/statue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My ultimate data structure and algorithm guide"/></a><div class="content"><a class="title" href="/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" title="My ultimate data structure and algorithm guide">My ultimate data structure and algorithm guide</a><time datetime="2022-06-11T12:00:00.000Z" title="Created 2022-06-12 00:00:00">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Design Patterns"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Design Patterns"/></a><div class="content"><a class="title" href="/2022/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Design Patterns">Design Patterns</a><time datetime="2022-06-11T12:00:00.000Z" title="Created 2022-06-12 00:00:00">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" title="Design Patterns - Factory Method"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-covers/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Design Patterns - Factory Method"/></a><div class="content"><a class="title" href="/2022/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" title="Design Patterns - Factory Method">Design Patterns - Factory Method</a><time datetime="2022-06-10T12:00:00.000Z" title="Created 2022-06-11 00:00:00">2022-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Harry Qu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://harryqu1229.github.io/2022/06/12/%E7%AE%97%E6%B3%95%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/'
    this.page.identifier = '2022/06/12/算法终极指南/'
    this.page.title = 'My ultimate data structure and algorithm guide'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://harry-study-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '5df1e915e0fa867b50de',
      clientSecret: 'ce1cb793fe49078ee9d0102d3326d0d50ff6937b',
      repo: 'blog-comments-storage',
      owner: 'HarryQu1229',
      admin: ['HarryQu1229'],
      id: '5e52183f0ea0e013a60e64fc4b8d8fbe',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Disqus' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[image]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[link]') // replace url
    content = content.replace(/<code>.*?<\/code>/gi, '[code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=harry-study-blog&related=thread&limit=6&api_key=B5XFmdGuVaYDW7OIBakffpXoKorvphwRiwONIol4puEtr8YiwYAMAk2K7QcExNLY')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        saveToLocal.set('disqus-newest-comments', JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "Unable to get the data, please make sure the settings are correct."
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick}</span><time> / ${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += 'No Comment'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('disqus-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="2809513713" data-server="netease" data-type="playlist" data-autoplay="false" data-fixed="true" data-order="random" data-theme="#e9ccd3"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'HarryStudyBlog/community',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (true) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":450},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>